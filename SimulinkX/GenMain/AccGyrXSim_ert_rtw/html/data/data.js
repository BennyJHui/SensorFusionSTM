var DataHeading = 'Code'; var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"AccGyrXSim","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"AccGyrXSim.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n  __enable_irq();\r\n  AccGyrXSim_step();\r\n\r\n  /* Get model outputs here */\r\n  __disable_irq();\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(int argc, char **argv)\r\n{\r\n  float modelBaseRate = 0.02;\r\n  float systemClock = 64.0;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n\r\n#if !defined(MW_FREERTOS) && defined(MW_MULTI_TASKING_MODE) && (MW_MULTI_TASKING_MODE == 1)\r\n\r\n  MW_ASM (\" SVC #1\");\r\n\r\n#endif\r\n\r\n  ;\r\n\r\n  // Start Peripheral initialization imported from STM32CubeMX project;\r\n  HAL_Init();\r\n  SystemClock_Config();\r\n  PeriphCommonClock_Config();\r\n  MX_GPIO_Init();\r\n  MX_SPI1_Init();\r\n  MX_TIM13_Init();\r\n  MX_USART3_UART_Init();\r\n\r\n  // End Peripheral initialization imported from STM32CubeMX project;\r\n  rtmSetErrorStatus(AccGyrXSim_M, 0);\r\n  AccGyrXSim_initialize();\r\n  __disable_irq();\r\n  ARMCM_SysTick_Config(modelBaseRate);\r\n  runModel =\r\n    rtmGetErrorStatus(AccGyrXSim_M) == (NULL);\r\n  __enable_irq();\r\n  __enable_irq();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(AccGyrXSim_M) == (NULL));\r\n    if (stopRequested) {\r\n      SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;\r\n    }\r\n\r\n    ;\r\n  }\r\n\r\n  /* Terminate model */\r\n  AccGyrXSim_terminate();\r\n\r\n#if !defined(MW_FREERTOS) && !defined(USE_RTX)\r\n\r\n  (void) systemClock;\r\n\r\n#endif\r\n\r\n  ;\r\n  __disable_irq();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"AccGyrXSim.c","type":"source","group":"model","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: AccGyrXSim.c\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"AccGyrXSim.h\"\r\n#include \"AccGyrXSim_types.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n#include \"AccGyrXSim_private.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <string.h>\r\n#include \"rt_defines.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_AccGyrXSim_T AccGyrXSim_B;\r\n\r\n/* Block states (default storage) */\r\nDW_AccGyrXSim_T AccGyrXSim_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_AccGyrXSim_T AccGyrXSim_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_AccGyrXSim_T AccGyrXSim_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_AccGyrXSim_T AccGyrXSim_M_;\r\nRT_MODEL_AccGyrXSim_T *const AccGyrXSim_M = &AccGyrXSim_M_;\r\n\r\n/* Forward declaration for local functions */\r\nstatic void AccGyrXSim_NED_ecompass(const real_T a[3], const real_T m[3], real_T\r\n  R[9]);\r\nstatic void AccGyrXSi_quaternion_quaternion(const real_T varargin_1[3], real_T\r\n  *obj_a, real_T *obj_b, real_T *obj_c, real_T *obj_d);\r\nstatic void AccGyrXSim_imufilter_stepImpl(fusion_internal_simulink_imuf_T *obj,\r\n  const real_T accelIn[3], const real_T gyroIn[3], real_T orientOut[4], real_T\r\n  angvel[3]);\r\nstatic void AccGyrXSim_NED_ecompass(const real_T a[3], const real_T m[3], real_T\r\n  R[9])\r\n{\r\n  real_T Reast[3];\r\n  real_T R_0;\r\n  int32_T i2;\r\n  int32_T xpageoffset;\r\n  boolean_T b[9];\r\n  boolean_T y[3];\r\n  boolean_T exitg1;\r\n  boolean_T nanPageIdx;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  Reast[0] = a[1] * m[2] - m[1] * a[2];\r\n  Reast[1] = m[0] * a[2] - a[0] * m[2];\r\n  Reast[2] = a[0] * m[1] - m[0] * a[1];\r\n  R[6] = a[0];\r\n  R[3] = Reast[0];\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  R[7] = a[1];\r\n  R[4] = Reast[1];\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  R[8] = a[2];\r\n  R[5] = Reast[2];\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  R[0] = Reast[1] * a[2] - a[1] * Reast[2];\r\n  R[1] = a[0] * Reast[2] - Reast[0] * a[2];\r\n  R[2] = Reast[0] * a[1] - a[0] * Reast[1];\r\n  for (i2 = 0; i2 < 9; i2++) {\r\n    R_0 = R[i2];\r\n    AccGyrXSim_B.x[i2] = R_0 * R_0;\r\n  }\r\n\r\n  for (i2 = 0; i2 < 3; i2++) {\r\n    xpageoffset = i2 * 3;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    Reast[i2] = sqrt((AccGyrXSim_B.x[xpageoffset + 1] +\r\n                      AccGyrXSim_B.x[xpageoffset]) + AccGyrXSim_B.x[xpageoffset\r\n                     + 2]);\r\n  }\r\n\r\n  memcpy(&AccGyrXSim_B.x[0], &R[0], 9U * sizeof(real_T));\r\n  for (i2 = 0; i2 < 3; i2++) {\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    R_0 = Reast[i2];\r\n    R[3 * i2] = AccGyrXSim_B.x[3 * i2] / R_0;\r\n    xpageoffset = 3 * i2 + 1;\r\n    R[xpageoffset] = AccGyrXSim_B.x[xpageoffset] / R_0;\r\n    xpageoffset = 3 * i2 + 2;\r\n    R[xpageoffset] = AccGyrXSim_B.x[xpageoffset] / R_0;\r\n  }\r\n\r\n  for (i2 = 0; i2 < 9; i2++) {\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    b[i2] = rtIsNaN(R[i2]);\r\n  }\r\n\r\n  y[0] = false;\r\n  y[1] = false;\r\n  y[2] = false;\r\n  i2 = 1;\r\n  for (xpageoffset = 0; xpageoffset < 3; xpageoffset++) {\r\n    int32_T i2_0;\r\n    int32_T ix;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    i2_0 = i2;\r\n    ix = i2;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    i2 += 3;\r\n    exitg1 = false;\r\n    while ((!exitg1) && (ix <= i2_0 + 2)) {\r\n      if (b[ix - 1]) {\r\n        y[xpageoffset] = true;\r\n        exitg1 = true;\r\n      } else {\r\n        ix++;\r\n      }\r\n    }\r\n  }\r\n\r\n  nanPageIdx = false;\r\n  i2 = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (i2 < 3)) {\r\n    if (y[i2]) {\r\n      nanPageIdx = true;\r\n      exitg1 = true;\r\n    } else {\r\n      i2++;\r\n    }\r\n  }\r\n\r\n  if (nanPageIdx) {\r\n    memset(&R[0], 0, 9U * sizeof(real_T));\r\n    R[0] = 1.0;\r\n    R[4] = 1.0;\r\n    R[8] = 1.0;\r\n  }\r\n}\r\n\r\nstatic void AccGyrXSi_quaternion_quaternion(const real_T varargin_1[3], real_T\r\n  *obj_a, real_T *obj_b, real_T *obj_c, real_T *obj_d)\r\n{\r\n  real_T st;\r\n  real_T st_tmp;\r\n  real_T theta;\r\n  *obj_a = 1.0;\r\n  *obj_b = 0.0;\r\n  *obj_c = 0.0;\r\n  *obj_d = 0.0;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  theta = sqrt((varargin_1[0] * varargin_1[0] + varargin_1[1] * varargin_1[1]) +\r\n               varargin_1[2] * varargin_1[2]);\r\n  st_tmp = theta / 2.0;\r\n  st = sin(st_tmp);\r\n  if (theta != 0.0) {\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    *obj_a = cos(st_tmp);\r\n    *obj_b = varargin_1[0] / theta * st;\r\n    *obj_c = varargin_1[1] / theta * st;\r\n    *obj_d = varargin_1[2] / theta * st;\r\n  }\r\n}\r\n\r\nstatic void AccGyrXSim_imufilter_stepImpl(fusion_internal_simulink_imuf_T *obj,\r\n  const real_T accelIn[3], const real_T gyroIn[3], real_T orientOut[4], real_T\r\n  angvel[3])\r\n{\r\n  real_T psquared[4];\r\n  real_T deltaAng[3];\r\n  real_T a21;\r\n  real_T deltaAng_idx_1;\r\n  real_T deltaAng_idx_2;\r\n  real_T e_c;\r\n  real_T e_d;\r\n  real_T invpa;\r\n  real_T invpd;\r\n  real_T maxval;\r\n  real_T n;\r\n  real_T pGyroOffsetIn_idx_0;\r\n  real_T pGyroOffsetIn_idx_1;\r\n  real_T pGyroOffsetIn_idx_2;\r\n  real_T pa;\r\n  real_T pd;\r\n  real_T q_a;\r\n  real_T y;\r\n  real_T y_0;\r\n  int32_T H_tmp;\r\n  int32_T H_tmp_0;\r\n  int32_T H_tmp_1;\r\n  int32_T r1;\r\n  int32_T r2;\r\n  int32_T r3;\r\n  int32_T rtemp;\r\n  static const real_T tmp[3] = { 1.0, 0.0, 0.0 };\r\n\r\n  static const int8_T tmp_0[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };\r\n\r\n  boolean_T exitg1;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  pGyroOffsetIn_idx_0 = obj->pGyroOffset[0];\r\n  pGyroOffsetIn_idx_1 = obj->pGyroOffset[1];\r\n  pGyroOffsetIn_idx_2 = obj->pGyroOffset[2];\r\n  if (obj->pFirstTime) {\r\n    AccGyrXSim_NED_ecompass(accelIn, tmp, AccGyrXSim_B.Rpost);\r\n    pd = (AccGyrXSim_B.Rpost[0] + AccGyrXSim_B.Rpost[4]) + AccGyrXSim_B.Rpost[8];\r\n    psquared[0] = (pd * 2.0 + 1.0) - pd;\r\n    psquared[1] = (2.0 * AccGyrXSim_B.Rpost[0] + 1.0) - pd;\r\n    psquared[2] = (2.0 * AccGyrXSim_B.Rpost[4] + 1.0) - pd;\r\n    psquared[3] = (2.0 * AccGyrXSim_B.Rpost[8] + 1.0) - pd;\r\n    if (!rtIsNaN(psquared[0])) {\r\n      r2 = 1;\r\n    } else {\r\n      r2 = 0;\r\n      r1 = 2;\r\n      exitg1 = false;\r\n      while ((!exitg1) && (r1 < 5)) {\r\n        if (!rtIsNaN(psquared[r1 - 1])) {\r\n          r2 = r1;\r\n          exitg1 = true;\r\n        } else {\r\n          r1++;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (r2 == 0) {\r\n      pd = psquared[0];\r\n      r2 = 1;\r\n    } else {\r\n      pd = psquared[r2 - 1];\r\n      r3 = r2;\r\n      for (r1 = r2 + 1; r1 < 5; r1++) {\r\n        pa = psquared[r1 - 1];\r\n        if (pd < pa) {\r\n          pd = pa;\r\n          r3 = r1;\r\n        }\r\n      }\r\n\r\n      r2 = r3;\r\n    }\r\n\r\n    switch (r2) {\r\n     case 1:\r\n      pa = sqrt(pd);\r\n      pd = 0.5 * pa;\r\n      invpa = 0.5 / pa;\r\n      pa = (AccGyrXSim_B.Rpost[7] - AccGyrXSim_B.Rpost[5]) * invpa;\r\n      invpd = (AccGyrXSim_B.Rpost[2] - AccGyrXSim_B.Rpost[6]) * invpa;\r\n      invpa *= AccGyrXSim_B.Rpost[3] - AccGyrXSim_B.Rpost[1];\r\n      break;\r\n\r\n     case 2:\r\n      pd = sqrt(pd);\r\n      pa = 0.5 * pd;\r\n      invpa = 0.5 / pd;\r\n      pd = (AccGyrXSim_B.Rpost[7] - AccGyrXSim_B.Rpost[5]) * invpa;\r\n      invpd = (AccGyrXSim_B.Rpost[1] + AccGyrXSim_B.Rpost[3]) * invpa;\r\n      invpa *= AccGyrXSim_B.Rpost[2] + AccGyrXSim_B.Rpost[6];\r\n      break;\r\n\r\n     case 3:\r\n      pd = sqrt(pd);\r\n      invpd = 0.5 * pd;\r\n      invpa = 0.5 / pd;\r\n      pd = (AccGyrXSim_B.Rpost[2] - AccGyrXSim_B.Rpost[6]) * invpa;\r\n      pa = (AccGyrXSim_B.Rpost[1] + AccGyrXSim_B.Rpost[3]) * invpa;\r\n      invpa *= AccGyrXSim_B.Rpost[5] + AccGyrXSim_B.Rpost[7];\r\n      break;\r\n\r\n     default:\r\n      pd = sqrt(pd);\r\n      invpa = 0.5 * pd;\r\n      invpd = 0.5 / pd;\r\n      pd = (AccGyrXSim_B.Rpost[3] - AccGyrXSim_B.Rpost[1]) * invpd;\r\n      pa = (AccGyrXSim_B.Rpost[2] + AccGyrXSim_B.Rpost[6]) * invpd;\r\n      invpd *= AccGyrXSim_B.Rpost[5] + AccGyrXSim_B.Rpost[7];\r\n      break;\r\n    }\r\n\r\n    if (pd < 0.0) {\r\n      pd = -pd;\r\n      pa = -pa;\r\n      invpd = -invpd;\r\n      invpa = -invpa;\r\n    }\r\n\r\n    obj->pOrientPost.a = pd;\r\n    obj->pOrientPost.b = pa;\r\n    obj->pOrientPost.c = invpd;\r\n    obj->pOrientPost.d = invpa;\r\n  }\r\n\r\n  deltaAng[0] = (gyroIn[0] - obj->pGyroOffset[0]) * obj->pSensorPeriod;\r\n  deltaAng[1] = (gyroIn[1] - obj->pGyroOffset[1]) * obj->pSensorPeriod;\r\n  deltaAng[2] = (gyroIn[2] - obj->pGyroOffset[2]) * obj->pSensorPeriod;\r\n  AccGyrXSi_quaternion_quaternion(deltaAng, &n, &deltaAng_idx_1, &deltaAng_idx_2,\r\n    &a21);\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  invpd = ((obj->pOrientPost.a * n - obj->pOrientPost.b * deltaAng_idx_1) -\r\n           obj->pOrientPost.c * deltaAng_idx_2) - obj->pOrientPost.d * a21;\r\n  invpa = ((obj->pOrientPost.a * deltaAng_idx_1 + obj->pOrientPost.b * n) +\r\n           obj->pOrientPost.c * a21) - obj->pOrientPost.d * deltaAng_idx_2;\r\n  e_c = ((obj->pOrientPost.a * deltaAng_idx_2 - obj->pOrientPost.b * a21) +\r\n         obj->pOrientPost.c * n) + obj->pOrientPost.d * deltaAng_idx_1;\r\n  e_d = ((obj->pOrientPost.a * a21 + obj->pOrientPost.b * deltaAng_idx_2) -\r\n         obj->pOrientPost.c * deltaAng_idx_1) + obj->pOrientPost.d * n;\r\n  if (((obj->pOrientPost.a * n - obj->pOrientPost.b * deltaAng_idx_1) -\r\n       obj->pOrientPost.c * deltaAng_idx_2) - obj->pOrientPost.d * a21 < 0.0) {\r\n    invpd = -invpd;\r\n    invpa = -invpa;\r\n    e_c = -e_c;\r\n    e_d = -e_d;\r\n  }\r\n\r\n  n = sqrt(((invpd * invpd + invpa * invpa) + e_c * e_c) + e_d * e_d);\r\n  q_a = invpd / n;\r\n  pa = invpa / n;\r\n  deltaAng_idx_1 = e_c / n;\r\n  maxval = e_d / n;\r\n  n = (pa * maxval * 2.0 - q_a * deltaAng_idx_1 * 2.0) * 9.81;\r\n  pd = obj->LinearAccelerationDecayFactor * obj->pLinAccelPost[0];\r\n  deltaAng_idx_1 = (deltaAng_idx_1 * maxval * 2.0 + q_a * pa * 2.0) * 9.81;\r\n  pa = obj->LinearAccelerationDecayFactor * obj->pLinAccelPost[1];\r\n  deltaAng_idx_2 = ((q_a * q_a * 2.0 - 1.0) + maxval * maxval * 2.0) * 9.81;\r\n  q_a = obj->LinearAccelerationDecayFactor * obj->pLinAccelPost[2];\r\n  memset(&AccGyrXSim_B.Rpost[0], 0, 9U * sizeof(real_T));\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  AccGyrXSim_B.Rpost[3] = deltaAng_idx_2;\r\n  AccGyrXSim_B.Rpost[6] = -deltaAng_idx_1;\r\n  AccGyrXSim_B.Rpost[7] = n;\r\n  for (r1 = 0; r1 < 3; r1++) {\r\n    AccGyrXSim_B.Rpost_c[3 * r1] = AccGyrXSim_B.Rpost[3 * r1];\r\n    r2 = 3 * r1 + 1;\r\n    AccGyrXSim_B.Rpost_c[r2] = AccGyrXSim_B.Rpost[r2] - AccGyrXSim_B.Rpost[r1 +\r\n      3];\r\n    r2 = 3 * r1 + 2;\r\n    AccGyrXSim_B.Rpost_c[r2] = AccGyrXSim_B.Rpost[r2] - AccGyrXSim_B.Rpost[r1 +\r\n      6];\r\n  }\r\n\r\n  for (r1 = 0; r1 < 9; r1++) {\r\n    maxval = AccGyrXSim_B.Rpost_c[r1];\r\n    AccGyrXSim_B.H[r1] = maxval;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_B.H[r1 + 9] = -maxval * obj->pKalmanPeriod;\r\n    AccGyrXSim_B.H[r1 + 18] = tmp_0[r1];\r\n    AccGyrXSim_B.y[3 * r1] = 0.0;\r\n    AccGyrXSim_B.y[3 * r1 + 1] = 0.0;\r\n    AccGyrXSim_B.y[3 * r1 + 2] = 0.0;\r\n  }\r\n\r\n  for (r1 = 0; r1 < 9; r1++) {\r\n    a21 = AccGyrXSim_B.y[3 * r1];\r\n    r3 = 3 * r1 + 1;\r\n    y = AccGyrXSim_B.y[r3];\r\n    rtemp = 3 * r1 + 2;\r\n    y_0 = AccGyrXSim_B.y[rtemp];\r\n    for (r2 = 0; r2 < 9; r2++) {\r\n      /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n      maxval = obj->pQw[9 * r1 + r2];\r\n      a21 += AccGyrXSim_B.H[3 * r2] * maxval;\r\n      y += AccGyrXSim_B.H[3 * r2 + 1] * maxval;\r\n      y_0 += AccGyrXSim_B.H[3 * r2 + 2] * maxval;\r\n    }\r\n\r\n    AccGyrXSim_B.y[rtemp] = y_0;\r\n    AccGyrXSim_B.y[r3] = y;\r\n    AccGyrXSim_B.y[3 * r1] = a21;\r\n  }\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  for (r1 = 0; r1 < 3; r1++) {\r\n    maxval = 0.0;\r\n    a21 = 0.0;\r\n    y = 0.0;\r\n    for (r2 = 0; r2 < 9; r2++) {\r\n      y_0 = AccGyrXSim_B.H[3 * r2 + r1];\r\n      AccGyrXSim_B.y_tmp[r2 + 9 * r1] = y_0;\r\n      maxval += AccGyrXSim_B.y[3 * r2] * y_0;\r\n      a21 += AccGyrXSim_B.y[3 * r2 + 1] * y_0;\r\n      y += AccGyrXSim_B.y[3 * r2 + 2] * y_0;\r\n    }\r\n\r\n    AccGyrXSim_B.Rpost_c[3 * r1 + 2] = y;\r\n    AccGyrXSim_B.Rpost_c[3 * r1 + 1] = a21;\r\n    AccGyrXSim_B.Rpost_c[3 * r1] = maxval;\r\n  }\r\n\r\n  for (r1 = 0; r1 < 3; r1++) {\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_B.Rpost[3 * r1] = AccGyrXSim_B.Rpost_c[r1] + obj->pQv[r1];\r\n    AccGyrXSim_B.Rpost[3 * r1 + 1] = AccGyrXSim_B.Rpost_c[r1 + 3] + obj->pQv[r1\r\n      + 3];\r\n    AccGyrXSim_B.Rpost[3 * r1 + 2] = AccGyrXSim_B.Rpost_c[r1 + 6] + obj->pQv[r1\r\n      + 6];\r\n    memset(&AccGyrXSim_B.y_m[r1 * 9], 0, 9U * sizeof(real_T));\r\n    for (r2 = 0; r2 < 9; r2++) {\r\n      maxval = AccGyrXSim_B.y_tmp[9 * r1 + r2];\r\n      for (rtemp = 0; rtemp < 9; rtemp++) {\r\n        r3 = 9 * r1 + rtemp;\r\n\r\n        /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n        AccGyrXSim_B.y_m[r3] += obj->pQw[9 * r2 + rtemp] * maxval;\r\n      }\r\n    }\r\n  }\r\n\r\n  r1 = 0;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  r2 = 1;\r\n  r3 = 2;\r\n  maxval = fabs(AccGyrXSim_B.Rpost[0]);\r\n  a21 = fabs(AccGyrXSim_B.Rpost[1]);\r\n  if (a21 > maxval) {\r\n    maxval = a21;\r\n    r1 = 1;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    r2 = 0;\r\n  }\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  if (fabs(AccGyrXSim_B.Rpost[2]) > maxval) {\r\n    r1 = 2;\r\n    r2 = 1;\r\n    r3 = 0;\r\n  }\r\n\r\n  AccGyrXSim_B.Rpost[r2] /= AccGyrXSim_B.Rpost[r1];\r\n  AccGyrXSim_B.Rpost[r3] /= AccGyrXSim_B.Rpost[r1];\r\n  AccGyrXSim_B.Rpost[r2 + 3] -= AccGyrXSim_B.Rpost[r1 + 3] *\r\n    AccGyrXSim_B.Rpost[r2];\r\n  AccGyrXSim_B.Rpost[r3 + 3] -= AccGyrXSim_B.Rpost[r1 + 3] *\r\n    AccGyrXSim_B.Rpost[r3];\r\n  AccGyrXSim_B.Rpost[r2 + 6] -= AccGyrXSim_B.Rpost[r1 + 6] *\r\n    AccGyrXSim_B.Rpost[r2];\r\n  AccGyrXSim_B.Rpost[r3 + 6] -= AccGyrXSim_B.Rpost[r1 + 6] *\r\n    AccGyrXSim_B.Rpost[r3];\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  if (fabs(AccGyrXSim_B.Rpost[r3 + 3]) > fabs(AccGyrXSim_B.Rpost[r2 + 3])) {\r\n    rtemp = r2 + 1;\r\n    r2 = r3;\r\n    r3 = rtemp - 1;\r\n  }\r\n\r\n  AccGyrXSim_B.Rpost[r3 + 3] /= AccGyrXSim_B.Rpost[r2 + 3];\r\n  AccGyrXSim_B.Rpost[r3 + 6] -= AccGyrXSim_B.Rpost[r3 + 3] *\r\n    AccGyrXSim_B.Rpost[r2 + 6];\r\n  for (rtemp = 0; rtemp < 9; rtemp++) {\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    H_tmp = 9 * r1 + rtemp;\r\n    AccGyrXSim_B.H[H_tmp] = AccGyrXSim_B.y_m[rtemp] / AccGyrXSim_B.Rpost[r1];\r\n    H_tmp_0 = 9 * r2 + rtemp;\r\n    AccGyrXSim_B.H[H_tmp_0] = AccGyrXSim_B.y_m[rtemp + 9] -\r\n      AccGyrXSim_B.Rpost[r1 + 3] * AccGyrXSim_B.H[H_tmp];\r\n    H_tmp_1 = 9 * r3 + rtemp;\r\n    AccGyrXSim_B.H[H_tmp_1] = AccGyrXSim_B.y_m[rtemp + 18] -\r\n      AccGyrXSim_B.Rpost[r1 + 6] * AccGyrXSim_B.H[H_tmp];\r\n    AccGyrXSim_B.H[H_tmp_0] /= AccGyrXSim_B.Rpost[r2 + 3];\r\n    AccGyrXSim_B.H[H_tmp_1] -= AccGyrXSim_B.Rpost[r2 + 6] *\r\n      AccGyrXSim_B.H[H_tmp_0];\r\n    AccGyrXSim_B.H[H_tmp_1] /= AccGyrXSim_B.Rpost[r3 + 6];\r\n    AccGyrXSim_B.H[H_tmp_0] -= AccGyrXSim_B.Rpost[r3 + 3] *\r\n      AccGyrXSim_B.H[H_tmp_1];\r\n    AccGyrXSim_B.H[H_tmp] -= AccGyrXSim_B.H[H_tmp_1] * AccGyrXSim_B.Rpost[r3];\r\n    AccGyrXSim_B.H[H_tmp] -= AccGyrXSim_B.H[H_tmp_0] * AccGyrXSim_B.Rpost[r2];\r\n  }\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  deltaAng[0] = (accelIn[0] + pd) - n;\r\n  deltaAng[1] = (accelIn[1] + pa) - deltaAng_idx_1;\r\n  deltaAng[2] = (accelIn[2] + q_a) - deltaAng_idx_2;\r\n  memset(&AccGyrXSim_B.Rpost[0], 0, 9U * sizeof(real_T));\r\n  for (r1 = 0; r1 < 3; r1++) {\r\n    maxval = deltaAng[r1];\r\n    for (r2 = 0; r2 < 9; r2++) {\r\n      /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n      AccGyrXSim_B.Rpost[r2] += AccGyrXSim_B.H[9 * r1 + r2] * maxval;\r\n    }\r\n  }\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  AccGyrXSi_quaternion_quaternion(&AccGyrXSim_B.Rpost[0], &n, &deltaAng_idx_1,\r\n    &deltaAng_idx_2, &a21);\r\n  maxval = ((invpd * n - invpa * -deltaAng_idx_1) - e_c * -deltaAng_idx_2) - e_d\r\n    * -a21;\r\n  obj->pOrientPost.a = maxval;\r\n  obj->pOrientPost.b = ((invpd * -deltaAng_idx_1 + invpa * n) + e_c * -a21) -\r\n    e_d * -deltaAng_idx_2;\r\n  obj->pOrientPost.c = ((invpd * -deltaAng_idx_2 - invpa * -a21) + e_c * n) +\r\n    e_d * -deltaAng_idx_1;\r\n  obj->pOrientPost.d = ((invpd * -a21 + invpa * -deltaAng_idx_2) - e_c *\r\n                        -deltaAng_idx_1) + e_d * n;\r\n  if (maxval < 0.0) {\r\n    obj->pOrientPost.a = -obj->pOrientPost.a;\r\n    obj->pOrientPost.b = -obj->pOrientPost.b;\r\n    obj->pOrientPost.c = -obj->pOrientPost.c;\r\n    obj->pOrientPost.d = -obj->pOrientPost.d;\r\n  }\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  n = sqrt(((obj->pOrientPost.a * obj->pOrientPost.a + obj->pOrientPost.b *\r\n             obj->pOrientPost.b) + obj->pOrientPost.c * obj->pOrientPost.c) +\r\n           obj->pOrientPost.d * obj->pOrientPost.d);\r\n  obj->pOrientPost.a /= n;\r\n  obj->pOrientPost.b /= n;\r\n  obj->pOrientPost.c /= n;\r\n  obj->pOrientPost.d /= n;\r\n  for (r1 = 0; r1 < 9; r1++) {\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    invpd = AccGyrXSim_B.H[r1 + 9];\r\n    invpa = AccGyrXSim_B.H[r1];\r\n    e_c = AccGyrXSim_B.H[r1 + 18];\r\n    for (r2 = 0; r2 < 9; r2++) {\r\n      /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n      r3 = 9 * r2 + r1;\r\n      AccGyrXSim_B.Ppost[r3] = obj->pQw[r3] - ((AccGyrXSim_B.y[3 * r2 + 1] *\r\n        invpd + AccGyrXSim_B.y[3 * r2] * invpa) + AccGyrXSim_B.y[3 * r2 + 2] *\r\n        e_c);\r\n    }\r\n  }\r\n\r\n  memset(&obj->pQw[0], 0, 81U * sizeof(real_T));\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  a21 = obj->pKalmanPeriod * obj->pKalmanPeriod;\r\n  invpd = obj->GyroscopeDriftNoise + obj->GyroscopeNoise;\r\n  obj->pQw[0] = (AccGyrXSim_B.Ppost[30] + invpd) * a21 + AccGyrXSim_B.Ppost[0];\r\n  obj->pQw[30] = AccGyrXSim_B.Ppost[30] + obj->GyroscopeDriftNoise;\r\n  obj->pQw[10] = (AccGyrXSim_B.Ppost[40] + invpd) * a21 + AccGyrXSim_B.Ppost[10];\r\n  obj->pQw[40] = AccGyrXSim_B.Ppost[40] + obj->GyroscopeDriftNoise;\r\n  obj->pQw[20] = (AccGyrXSim_B.Ppost[50] + invpd) * a21 + AccGyrXSim_B.Ppost[20];\r\n  obj->pQw[50] = AccGyrXSim_B.Ppost[50] + obj->GyroscopeDriftNoise;\r\n  n = -obj->pKalmanPeriod * obj->pQw[30];\r\n  deltaAng_idx_1 = -obj->pKalmanPeriod * obj->pQw[40];\r\n  deltaAng_idx_2 = -obj->pKalmanPeriod * obj->pQw[50];\r\n  a21 = obj->LinearAccelerationDecayFactor * obj->LinearAccelerationDecayFactor;\r\n  obj->pFirstTime = false;\r\n  obj->pQw[3] = n;\r\n  obj->pQw[27] = n;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  obj->pQw[60] = a21 * AccGyrXSim_B.Ppost[60] + obj->LinearAccelerationNoise;\r\n  obj->pGyroOffset[0] -= AccGyrXSim_B.Rpost[3];\r\n  obj->pLinAccelPost[0] = pd - AccGyrXSim_B.Rpost[6];\r\n  angvel[0] = gyroIn[0] - pGyroOffsetIn_idx_0;\r\n  obj->pQw[13] = deltaAng_idx_1;\r\n  obj->pQw[37] = deltaAng_idx_1;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  obj->pQw[70] = a21 * AccGyrXSim_B.Ppost[70] + obj->LinearAccelerationNoise;\r\n  obj->pGyroOffset[1] -= AccGyrXSim_B.Rpost[4];\r\n  obj->pLinAccelPost[1] = pa - AccGyrXSim_B.Rpost[7];\r\n  angvel[1] = gyroIn[1] - pGyroOffsetIn_idx_1;\r\n  obj->pQw[23] = deltaAng_idx_2;\r\n  obj->pQw[47] = deltaAng_idx_2;\r\n\r\n  /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n  obj->pQw[80] = a21 * AccGyrXSim_B.Ppost[80] + obj->LinearAccelerationNoise;\r\n  obj->pGyroOffset[2] -= AccGyrXSim_B.Rpost[5];\r\n  obj->pLinAccelPost[2] = q_a - AccGyrXSim_B.Rpost[8];\r\n  angvel[2] = gyroIn[2] - pGyroOffsetIn_idx_2;\r\n  orientOut[0] = obj->pOrientPost.a;\r\n  orientOut[1] = obj->pOrientPost.b;\r\n  orientOut[2] = obj->pOrientPost.c;\r\n  orientOut[3] = obj->pOrientPost.d;\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    int32_T tmp;\r\n    int32_T tmp_0;\r\n    if (u0 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = atan2(tmp, tmp_0);\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid AccGyrXSim_step(void)\r\n{\r\n  real_T tmp[4];\r\n  real_T rtb_Transpose[3];\r\n  real_T rtb_VectorConcatenate1[3];\r\n  real_T tmp_0[3];\r\n  real_T a_tmp;\r\n  real_T b;\r\n  real_T c;\r\n  real_T f_idx_0;\r\n  real_T n;\r\n  real_T q_c;\r\n  real_T q_d;\r\n  int32_T i;\r\n  int8_T b_I[9];\r\n\r\n  /* Math: '<Root>/Transpose' incorporates:\r\n   *  Inport: '<Root>/AccX'\r\n   *  Inport: '<Root>/AccY'\r\n   *  Inport: '<Root>/AccZ'\r\n   */\r\n  rtb_Transpose[0] = AccGyrXSim_U.AccX;\r\n  rtb_Transpose[1] = AccGyrXSim_U.AccY;\r\n  rtb_Transpose[2] = AccGyrXSim_U.AccZ;\r\n\r\n  /* Gain: '<Root>/Gain' incorporates:\r\n   *  Inport: '<Root>/GyrX'\r\n   */\r\n  rtb_VectorConcatenate1[0] = 0.0010652644360316954 * AccGyrXSim_U.GyrX;\r\n\r\n  /* Gain: '<Root>/Gain1' incorporates:\r\n   *  Inport: '<Root>/GyrY'\r\n   */\r\n  rtb_VectorConcatenate1[1] = 0.0010652644360316954 * AccGyrXSim_U.GyrY;\r\n\r\n  /* Gain: '<Root>/Gain2' incorporates:\r\n   *  Inport: '<Root>/GyrZ'\r\n   */\r\n  rtb_VectorConcatenate1[2] = 0.0010652644360316954 * AccGyrXSim_U.GyrZ;\r\n\r\n  /* MATLABSystem: '<Root>/IMU Filter' incorporates:\r\n   *  Math: '<Root>/Transpose'\r\n   *  Math: '<Root>/Transpose1'\r\n   */\r\n  if (AccGyrXSim_DW.obj.AccelerometerNoise != 0.0001924722) {\r\n    if (AccGyrXSim_DW.obj.isInitialized == 1) {\r\n      AccGyrXSim_DW.obj.TunablePropsChanged = true;\r\n    }\r\n\r\n    AccGyrXSim_DW.obj.AccelerometerNoise = 0.0001924722;\r\n  }\r\n\r\n  if (AccGyrXSim_DW.obj.GyroscopeNoise != 9.1385E-5) {\r\n    if (AccGyrXSim_DW.obj.isInitialized == 1) {\r\n      AccGyrXSim_DW.obj.TunablePropsChanged = true;\r\n    }\r\n\r\n    AccGyrXSim_DW.obj.GyroscopeNoise = 9.1385E-5;\r\n  }\r\n\r\n  if (AccGyrXSim_DW.obj.GyroscopeDriftNoise != 3.0462E-13) {\r\n    if (AccGyrXSim_DW.obj.isInitialized == 1) {\r\n      AccGyrXSim_DW.obj.TunablePropsChanged = true;\r\n    }\r\n\r\n    AccGyrXSim_DW.obj.GyroscopeDriftNoise = 3.0462E-13;\r\n  }\r\n\r\n  if (AccGyrXSim_DW.obj.LinearAccelerationNoise != 0.0096236100000000012) {\r\n    if (AccGyrXSim_DW.obj.isInitialized == 1) {\r\n      AccGyrXSim_DW.obj.TunablePropsChanged = true;\r\n    }\r\n\r\n    AccGyrXSim_DW.obj.LinearAccelerationNoise = 0.0096236100000000012;\r\n  }\r\n\r\n  if (AccGyrXSim_DW.obj.LinearAccelerationDecayFactor != 0.5) {\r\n    if (AccGyrXSim_DW.obj.isInitialized == 1) {\r\n      AccGyrXSim_DW.obj.TunablePropsChanged = true;\r\n    }\r\n\r\n    AccGyrXSim_DW.obj.LinearAccelerationDecayFactor = 0.5;\r\n  }\r\n\r\n  if (AccGyrXSim_DW.obj.TunablePropsChanged) {\r\n    AccGyrXSim_DW.obj.TunablePropsChanged = false;\r\n    AccGyrXSim_DW.obj.pSensorPeriod = 0.02;\r\n    AccGyrXSim_DW.obj.pKalmanPeriod = 0.02;\r\n    for (i = 0; i < 9; i++) {\r\n      b_I[i] = 0;\r\n    }\r\n\r\n    b_I[0] = 1;\r\n    b_I[4] = 1;\r\n    b_I[8] = 1;\r\n    for (i = 0; i < 9; i++) {\r\n      AccGyrXSim_DW.obj.pQv[i] = 0.0098161187540001232 * (real_T)b_I[i];\r\n    }\r\n  }\r\n\r\n  AccGyrXSim_imufilter_stepImpl(&AccGyrXSim_DW.obj, rtb_Transpose,\r\n    rtb_VectorConcatenate1, tmp, tmp_0);\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\r\n   *  MATLABSystem: '<Root>/IMU Filter'\r\n   */\r\n  n = sqrt(((tmp[0] * tmp[0] + tmp[1] * tmp[1]) + tmp[2] * tmp[2]) + tmp[3] *\r\n           tmp[3]);\r\n  c = tmp[0] / n;\r\n  b = tmp[1] / n;\r\n  q_c = tmp[2] / n;\r\n  q_d = tmp[3] / n;\r\n  n = b * q_d * 2.0 - c * q_c * 2.0;\r\n  if (n > 1.0) {\r\n    n = 1.0;\r\n  }\r\n\r\n  f_idx_0 = n;\r\n  if (n < -1.0) {\r\n    f_idx_0 = -1.0;\r\n  }\r\n\r\n  if ((f_idx_0 < 0.0) && (fabs(f_idx_0 + 1.0) < 2.2204460492503131E-15)) {\r\n    n = -2.0 * rt_atan2d_snf(b, c);\r\n    c = 0.0;\r\n    b = 1.5707963267948966;\r\n  } else if ((f_idx_0 > 0.0) && (fabs(f_idx_0 - 1.0) < 2.2204460492503131E-15))\r\n  {\r\n    n = 2.0 * rt_atan2d_snf(b, c);\r\n    c = 0.0;\r\n    b = -1.5707963267948966;\r\n  } else {\r\n    a_tmp = c * c * 2.0 - 1.0;\r\n    n = rt_atan2d_snf(c * q_d * 2.0 + b * q_c * 2.0, b * b * 2.0 + a_tmp);\r\n    c = rt_atan2d_snf(c * b * 2.0 + q_c * q_d * 2.0, q_d * q_d * 2.0 + a_tmp);\r\n    b = -asin(f_idx_0);\r\n  }\r\n\r\n  rtb_VectorConcatenate1[0] = 57.295779513082323 * n;\r\n  rtb_VectorConcatenate1[1] = 57.295779513082323 * b;\r\n  rtb_VectorConcatenate1[2] = 57.295779513082323 * c;\r\n  if (rtIsNaN((rtb_VectorConcatenate1[0] - 45.0) + 180.0)) {\r\n    q_c = (rtNaN);\r\n  } else if (rtIsInf((rtb_VectorConcatenate1[0] - 45.0) + 180.0)) {\r\n    q_c = (rtNaN);\r\n  } else {\r\n    q_c = fmod((rtb_VectorConcatenate1[0] - 45.0) + 180.0, 360.0);\r\n    if (q_c == 0.0) {\r\n      q_c = 0.0;\r\n    } else if (q_c < 0.0) {\r\n      q_c += 360.0;\r\n    }\r\n  }\r\n\r\n  if (rtIsNaN(rtb_VectorConcatenate1[1] + 180.0)) {\r\n    b = (rtNaN);\r\n  } else if (rtIsInf(rtb_VectorConcatenate1[1] + 180.0)) {\r\n    b = (rtNaN);\r\n  } else {\r\n    b = fmod(rtb_VectorConcatenate1[1] + 180.0, 360.0);\r\n    if (b == 0.0) {\r\n      b = 0.0;\r\n    } else if (b < 0.0) {\r\n      b += 360.0;\r\n    }\r\n  }\r\n\r\n  if (rtIsNaN(rtb_VectorConcatenate1[2] + 180.0)) {\r\n    c = (rtNaN);\r\n  } else if (rtIsInf(rtb_VectorConcatenate1[2] + 180.0)) {\r\n    c = (rtNaN);\r\n  } else {\r\n    c = fmod(rtb_VectorConcatenate1[2] + 180.0, 360.0);\r\n    if (c == 0.0) {\r\n      c = 0.0;\r\n    } else if (c < 0.0) {\r\n      c += 360.0;\r\n    }\r\n  }\r\n\r\n  /* Outport: '<Root>/Roll' incorporates:\r\n   *  MATLAB Function: '<Root>/MATLAB Function1'\r\n   */\r\n  AccGyrXSim_Y.Roll = q_c - 180.0;\r\n\r\n  /* Outport: '<Root>/Pitch' incorporates:\r\n   *  MATLAB Function: '<Root>/MATLAB Function1'\r\n   */\r\n  AccGyrXSim_Y.Pitch = b - 180.0;\r\n\r\n  /* Outport: '<Root>/Yaw' incorporates:\r\n   *  MATLAB Function: '<Root>/MATLAB Function1'\r\n   */\r\n  AccGyrXSim_Y.Yaw = c - 180.0;\r\n\r\n  /* Outport: '<Root>/AngX' incorporates:\r\n   *  MATLAB Function: '<Root>/MATLAB Function'\r\n   *  MATLABSystem: '<Root>/IMU Filter'\r\n   */\r\n  AccGyrXSim_Y.AngX = tmp_0[0];\r\n\r\n  /* Outport: '<Root>/AngY' incorporates:\r\n   *  MATLAB Function: '<Root>/MATLAB Function'\r\n   *  MATLABSystem: '<Root>/IMU Filter'\r\n   */\r\n  AccGyrXSim_Y.AngY = tmp_0[1];\r\n\r\n  /* Outport: '<Root>/AngZ' incorporates:\r\n   *  MATLAB Function: '<Root>/MATLAB Function'\r\n   *  MATLABSystem: '<Root>/IMU Filter'\r\n   */\r\n  AccGyrXSim_Y.AngZ = tmp_0[2];\r\n}\r\n\r\n/* Model initialize function */\r\nvoid AccGyrXSim_initialize(void)\r\n{\r\n  {\r\n    int32_T i;\r\n    int8_T b_I[9];\r\n    static const real_T tmp[81] = { 6.0923483957341713E-6, 0.0, 0.0, 0.0, 0.0,\r\n      0.0, 0.0, 0.0, 0.0, 0.0, 6.0923483957341713E-6, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0, 0.0, 0.0, 0.0, 6.0923483957341713E-6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0, 0.0, 0.0, 7.6154354946677142E-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0, 0.0, 7.6154354946677142E-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0, 7.6154354946677142E-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0096236100000000012, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0096236100000000012, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n      0.0096236100000000012 };\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.AccelerometerNoise = 0.0001924722;\r\n    AccGyrXSim_DW.obj.GyroscopeNoise = 9.1385E-5;\r\n    AccGyrXSim_DW.obj.GyroscopeDriftNoise = 3.0462E-13;\r\n    AccGyrXSim_DW.obj.LinearAccelerationNoise = 0.0096236100000000012;\r\n    AccGyrXSim_DW.obj.LinearAccelerationDecayFactor = 0.5;\r\n    AccGyrXSim_DW.obj.isInitialized = 1;\r\n    AccGyrXSim_DW.obj.pSensorPeriod = 0.02;\r\n    AccGyrXSim_DW.obj.pKalmanPeriod = 0.02;\r\n    AccGyrXSim_DW.obj.TunablePropsChanged = false;\r\n\r\n    /* InitializeConditions for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pOrientPost.a = 1.0;\r\n    AccGyrXSim_DW.obj.pOrientPost.b = 0.0;\r\n    AccGyrXSim_DW.obj.pOrientPost.c = 0.0;\r\n    AccGyrXSim_DW.obj.pOrientPost.d = 0.0;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pInputPrototype[0] = 0.0;\r\n\r\n    /* InitializeConditions for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pGyroOffset[0] = 0.0;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pInputPrototype[1] = 0.0;\r\n\r\n    /* InitializeConditions for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pGyroOffset[1] = 0.0;\r\n\r\n    /* Start for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pInputPrototype[2] = 0.0;\r\n\r\n    /* InitializeConditions for MATLABSystem: '<Root>/IMU Filter' */\r\n    AccGyrXSim_DW.obj.pGyroOffset[2] = 0.0;\r\n    for (i = 0; i < 9; i++) {\r\n      b_I[i] = 0;\r\n    }\r\n\r\n    b_I[0] = 1;\r\n    b_I[4] = 1;\r\n    b_I[8] = 1;\r\n    for (i = 0; i < 9; i++) {\r\n      AccGyrXSim_DW.obj.pQv[i] = 0.0098161187540001232 * (real_T)b_I[i];\r\n    }\r\n\r\n    memcpy(&AccGyrXSim_DW.obj.pQw[0], &tmp[0], 81U * sizeof(real_T));\r\n    AccGyrXSim_DW.obj.pLinAccelPost[0] = 0.0;\r\n    AccGyrXSim_DW.obj.pLinAccelPost[1] = 0.0;\r\n    AccGyrXSim_DW.obj.pLinAccelPost[2] = 0.0;\r\n    AccGyrXSim_DW.obj.pFirstTime = true;\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid AccGyrXSim_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"AccGyrXSim.h","type":"header","group":"model","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: AccGyrXSim.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef AccGyrXSim_h_\r\n#define AccGyrXSim_h_\r\n#ifndef AccGyrXSim_COMMON_INCLUDES_\r\n#define AccGyrXSim_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n#endif                                 /* AccGyrXSim_COMMON_INCLUDES_ */\r\n\r\n#include \"AccGyrXSim_types.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Ppost[81];\r\n  real_T H[27];\r\n  real_T y[27];\r\n  real_T y_m[27];\r\n  real_T y_tmp[27];\r\n  real_T Rpost[9];\r\n  real_T Rpost_c[9];\r\n  real_T x[9];\r\n} B_AccGyrXSim_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  fusion_internal_simulink_imuf_T obj; /* '<Root>/IMU Filter' */\r\n} DW_AccGyrXSim_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T AccX;                         /* '<Root>/AccX' */\r\n  real_T AccY;                         /* '<Root>/AccY' */\r\n  real_T AccZ;                         /* '<Root>/AccZ' */\r\n  real_T GyrX;                         /* '<Root>/GyrX' */\r\n  real_T GyrY;                         /* '<Root>/GyrY' */\r\n  real_T GyrZ;                         /* '<Root>/GyrZ' */\r\n} ExtU_AccGyrXSim_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T Roll;                         /* '<Root>/Roll' */\r\n  real_T Pitch;                        /* '<Root>/Pitch' */\r\n  real_T Yaw;                          /* '<Root>/Yaw' */\r\n  real_T AngX;                         /* '<Root>/AngX' */\r\n  real_T AngY;                         /* '<Root>/AngY' */\r\n  real_T AngZ;                         /* '<Root>/AngZ' */\r\n} ExtY_AccGyrXSim_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_AccGyrXSim_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_AccGyrXSim_T AccGyrXSim_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_AccGyrXSim_T AccGyrXSim_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_AccGyrXSim_T AccGyrXSim_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_AccGyrXSim_T AccGyrXSim_Y;\r\n\r\n/* Model entry point functions */\r\nextern void AccGyrXSim_initialize(void);\r\nextern void AccGyrXSim_step(void);\r\nextern void AccGyrXSim_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_AccGyrXSim_T *const AccGyrXSim_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Zero-Order Hold3' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Zero-Order Hold4' : Eliminated since input and output rates are identical\r\n * Block '<Root>/Zero-Order Hold5' : Eliminated since input and output rates are identical\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'AccGyrXSim'\r\n * '<S1>'   : 'AccGyrXSim/MATLAB Function'\r\n * '<S2>'   : 'AccGyrXSim/MATLAB Function1'\r\n */\r\n#endif                                 /* AccGyrXSim_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"AccGyrXSim_private.h","type":"header","group":"model","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: AccGyrXSim_private.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef AccGyrXSim_private_h_\r\n#define AccGyrXSim_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"AccGyrXSim_types.h\"\r\n\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\n\r\n#endif                                 /* AccGyrXSim_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"AccGyrXSim_types.h","type":"header","group":"model","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: AccGyrXSim_types.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef AccGyrXSim_types_h_\r\n#define AccGyrXSim_types_h_\r\n#include \"rtwtypes.h\"\r\n#ifndef struct_tag_PNHAOeXMeBDLyeZaJKzdBF\r\n#define struct_tag_PNHAOeXMeBDLyeZaJKzdBF\r\n\r\nstruct tag_PNHAOeXMeBDLyeZaJKzdBF\r\n{\r\n  real_T a;\r\n  real_T b;\r\n  real_T c;\r\n  real_T d;\r\n};\r\n\r\n#endif                                 /* struct_tag_PNHAOeXMeBDLyeZaJKzdBF */\r\n\r\n#ifndef typedef_d_quaternion_AccGyrXSim_T\r\n#define typedef_d_quaternion_AccGyrXSim_T\r\n\r\ntypedef struct tag_PNHAOeXMeBDLyeZaJKzdBF d_quaternion_AccGyrXSim_T;\r\n\r\n#endif                                 /* typedef_d_quaternion_AccGyrXSim_T */\r\n\r\n#ifndef struct_tag_rE0p9RRszDGqA6Mm8JUyIH\r\n#define struct_tag_rE0p9RRszDGqA6Mm8JUyIH\r\n\r\nstruct tag_rE0p9RRszDGqA6Mm8JUyIH\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_rE0p9RRszDGqA6Mm8JUyIH */\r\n\r\n#ifndef typedef_c_fusion_internal_frames_NED__T\r\n#define typedef_c_fusion_internal_frames_NED__T\r\n\r\ntypedef struct tag_rE0p9RRszDGqA6Mm8JUyIH c_fusion_internal_frames_NED__T;\r\n\r\n#endif                             /* typedef_c_fusion_internal_frames_NED__T */\r\n\r\n#ifndef struct_tag_zPI27RVtJmMPrEpr7VhydH\r\n#define struct_tag_zPI27RVtJmMPrEpr7VhydH\r\n\r\nstruct tag_zPI27RVtJmMPrEpr7VhydH\r\n{\r\n  int32_T isInitialized;\r\n  boolean_T TunablePropsChanged;\r\n  real_T AccelerometerNoise;\r\n  real_T GyroscopeNoise;\r\n  real_T GyroscopeDriftNoise;\r\n  real_T LinearAccelerationNoise;\r\n  real_T LinearAccelerationDecayFactor;\r\n  real_T pQw[81];\r\n  real_T pQv[9];\r\n  d_quaternion_AccGyrXSim_T pOrientPost;\r\n  boolean_T pFirstTime;\r\n  c_fusion_internal_frames_NED__T pRefSys;\r\n  real_T pSensorPeriod;\r\n  real_T pKalmanPeriod;\r\n  real_T pGyroOffset[3];\r\n  real_T pLinAccelPost[3];\r\n  real_T pInputPrototype[3];\r\n};\r\n\r\n#endif                                 /* struct_tag_zPI27RVtJmMPrEpr7VhydH */\r\n\r\n#ifndef typedef_fusion_internal_simulink_imuf_T\r\n#define typedef_fusion_internal_simulink_imuf_T\r\n\r\ntypedef struct tag_zPI27RVtJmMPrEpr7VhydH fusion_internal_simulink_imuf_T;\r\n\r\n#endif                             /* typedef_fusion_internal_simulink_imuf_T */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_AccGyrXSim_T RT_MODEL_AccGyrXSim_T;\r\n\r\n#endif                                 /* AccGyrXSim_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n\r\n/* Return rtNaN needed by the generated code. */\r\nreal_T rtGetNaN(void)\r\n{\r\n  return rtNaN;\r\n}\r\n\r\n/* Return rtNaNF needed by the generated code. */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  return rtNaNF;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetNaN_h_\r\n#define rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_defines.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_defines_h_\r\n#define rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* rt_defines_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"math.h\"\r\n\r\nreal_T rtNaN = -(real_T)NAN;\r\nreal_T rtInf = (real_T)INFINITY;\r\nreal_T rtMinusInf = -(real_T)INFINITY;\r\nreal32_T rtNaNF = -(real32_T)NAN;\r\nreal32_T rtInfF = (real32_T)INFINITY;\r\nreal32_T rtMinusInfF = -(real32_T)INFINITY;\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)isinf(value);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  return (boolean_T)(isnan(value) != 0);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\n\r\n#endif                                 /* rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex-M\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'AccGyrXSim'.\r\n *\r\n * Model version                  : 1.74\r\n * Simulink Coder version         : 25.2 (R2025b) 28-Jul-2025\r\n * C/C++ source code generated on : Mon Feb 23 16:50:48 2026\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"AccGyrXSim.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"mw_stm32_board_header.h\"\n#include \"SysTickScheduler.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE STM32H7xx Based (Single-core)\n#define MW_EXTMODEPROTOCOLINFO_CAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_CAN_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_CAN_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_SERIAL_BAUDRATE stm32cube.codegen.getConnectivityBaudrate(hCS)\n#define MW_CONNECTIONINFO_SERIAL_COMPORT stm32cube.codegen.getConnectivityCOMPort(hCS)\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 1\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS stm32cube.parameters.EthernetConfigIPAddressExternalMode\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 1\n#define MW_CONNECTIONINFO_CAN_CANVENDOR matlab:stm32cube.codegen.getXCPonCANConnectivity(hCS,'Vendor')\n#define MW_CONNECTIONINFO_CAN_CANDEVICE matlab:stm32cube.codegen.getXCPonCANConnectivity(hCS,'Device')\n#define MW_CONNECTIONINFO_CAN_CANCHANNEL stm32cube.codegen.getXCPonCANConnectivity(hCS,'Channel')\n#define MW_CONNECTIONINFO_CAN_BUSSPEED stm32cube.codegen.getXCPonCANConnectivity(hCS,'Baudrate')\n#define MW_CONNECTIONINFO_CAN_CANIDCOMMAND stm32cube.codegen.getXCPonCANConnectivity(hCS,'CANIDCommand')\n#define MW_CONNECTIONINFO_CAN_CANIDRESPONSE stm32cube.codegen.getXCPonCANConnectivity(hCS,'CANIDResponse')\n#define MW_CONNECTIONINFO_CAN_ISCANIDEXTENDED stm32cube.codegen.getXCPonCANConnectivity(hCS,'IsCANIDExtended')\n#define MW_CONNECTIONINFO_CAN_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION Serial\n#define MW_EXTMODE_SIGNALBUFFERSIZE 2048.000000\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 1\n#define MW_RTOS Baremetal\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_RUNTIMELIBRARY 0\n#define MW_RUNTIME_FFPCONTRACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_STM32CUBEMX_PROJECTFILEBUTTON \n#define MW_STM32CUBEMX_CREATEPROJECTFILEBUTTON \n#define MW_STM32CUBEMX_LAUNCHPROJECTFILEBUTTON \n#define MW_STM32CUBEMX_PROJECTFILE C:/Users/HUB4RT/Desktop/WorkStuff - Copy/STM32_IMU/STM32_IMU.ioc\n#define MW_STM32CUBEMX_DEVICEID STM32H753ZITx\n#define MW_STM32CUBEMX_FAMILY STM32H7\n#define MW_STM32CUBEMX_CONNECTIVITYMODE 0\n#define MW_STM32CUBEMX_CONNECTIONPORT 0\n#define MW_STM32CUBEMX_MODE 0\n#define MW_STM32CUBEMX_ACCESSPORT 0\n#define MW_STM32CUBEMX_RESETMODE 0\n#define MW_STM32CUBEMX_AUTODETECTBOARD 1\n#define MW_STM32CUBEMX_DEVICELIST -1\n#define MW_STM32CUBEMX_DEVICELISTREFRESH \n#define MW_CLOCKING_CPUCLOCKRATEMHZ 64.000000\n#define MW_CONNECTION_SERIALCONFIGUREMODULE 48\n#define MW_CONNECTION_SERIALMODULE 2\n#define MW_CONNECTION_SERIALPORT COM1\n#define MW_CONNECTION_ETHERNETCONFIGUREMODULE 48\n#define MW_CONNECTION_ETHERNETPORT 17725.000000\n#define MW_CONNECTION_CANCONFIGUREMODULE 48\n#define MW_CONNECTION_CANMODULE 0\n#define MW_CONNECTION_BAUDRATE 1000000\n#define MW_CONNECTION_CANREADSOURCE 0\n#define MW_CONNECTION_BUFFERNUMBER 0\n#define MW_CONNECTION_CANVENDOR -1\n#define MW_CONNECTION_CANDEVICE -1\n#define MW_CONNECTION_CANCHANNEL -1\n#define MW_CONNECTION_ISCANIDEXTENDED 48\n#define MW_CONNECTION_CANIDCOMMAND 2\n#define MW_CONNECTION_CANIDRESPONSE 3\n#define MW_CONNECTIVITY_REFRESH \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN stm32cube.connectedIO.getConfigSetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN stm32cube.connectedIO.updateServer\n#define MW_SIMULINKIO_VALIDATESERVERFCN stm32cube.connectedIO.validateIoServer\n#define MW_SIMULINKIO_INTERFACE 0\n#define MW_SIMULINKIO_VALIDATEBEFORECONNECTFCN stm32cube.connectedIO.connectedIOModelValidation\n#define MW_SIMULINKIO_CONNECTEDIOSUPPORTEDBLOCKS DigitalPortRead,DigitalPortWrite,PWMOutput,AnalogInput,AnalogInputForH7,I2CControllerRead,I2CControllerWrite,LSM6DS3Block,LSM6DS3HBlock,LSM6DSLBlock,LSM6DSMBlock,LSM6DSRBlock,LSM6DSOBlock,LSM303CBlock,LIS3MDLBlock,LPS22HBBlock,HTS221Block,BMI160Block,ADXL34xBlock,CCS811Block,ICM20948Block,LIS3DHBlock\n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_USART_USART1CONFIGUREMODULE 48\n#define MW_USART_USART1TRANSMITMODE 0\n#define MW_USART_USART1RECEIVEMODE 0\n#define MW_USART_USART1TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART1RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART1DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART2CONFIGUREMODULE 48\n#define MW_USART_USART2TRANSMITMODE 0\n#define MW_USART_USART2RECEIVEMODE 0\n#define MW_USART_USART2TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART2RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART2DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART3CONFIGUREMODULE 48\n#define MW_USART_USART3TRANSMITMODE 0\n#define MW_USART_USART3RECEIVEMODE 0\n#define MW_USART_USART3TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART3RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART3DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART4CONFIGUREMODULE 48\n#define MW_USART_UART4TRANSMITMODE 0\n#define MW_USART_UART4RECEIVEMODE 0\n#define MW_USART_UART4TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART4RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART4DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART5CONFIGUREMODULE 48\n#define MW_USART_UART5TRANSMITMODE 0\n#define MW_USART_UART5RECEIVEMODE 0\n#define MW_USART_UART5TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART5RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART5DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART6CONFIGUREMODULE 48\n#define MW_USART_USART6TRANSMITMODE 0\n#define MW_USART_USART6RECEIVEMODE 0\n#define MW_USART_USART6TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART6RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART6DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART7CONFIGUREMODULE 48\n#define MW_USART_UART7TRANSMITMODE 0\n#define MW_USART_UART7RECEIVEMODE 0\n#define MW_USART_UART7TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART7RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART7DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART8CONFIGUREMODULE 48\n#define MW_USART_UART8TRANSMITMODE 0\n#define MW_USART_UART8RECEIVEMODE 0\n#define MW_USART_UART8TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART8RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART8DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_UART9CONFIGUREMODULE 48\n#define MW_USART_UART9TRANSMITMODE 0\n#define MW_USART_UART9RECEIVEMODE 0\n#define MW_USART_UART9TRANSMITBUFFERLENGTH 128\n#define MW_USART_UART9RECEIVEBUFFERLENGTH 128\n#define MW_USART_UART9DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_USART10CONFIGUREMODULE 48\n#define MW_USART_USART10TRANSMITMODE 0\n#define MW_USART_USART10RECEIVEMODE 0\n#define MW_USART_USART10TRANSMITBUFFERLENGTH 128\n#define MW_USART_USART10RECEIVEBUFFERLENGTH 128\n#define MW_USART_USART10DISABLEDMAINTERRUPTONERROR 48\n#define MW_USART_LPUART1CONFIGUREMODULE 48\n#define MW_USART_LPUART1TRANSMITMODE 0\n#define MW_USART_LPUART1RECEIVEMODE 0\n#define MW_USART_LPUART1TRANSMITBUFFERLENGTH 128\n#define MW_USART_LPUART1RECEIVEBUFFERLENGTH 128\n#define MW_USART_LPUART1DISABLEDMAINTERRUPTONERROR 48\n#define MW_ETHERNET_HOSTNAME STM32H7xx\n#define MW_ETHERNET_MACADDR 00:80:E1:00:00:00\n#define MW_ETHERNET_DHCPENABLED 1\n#define MW_ETHERNET_LOCALIPADDRESS 0.0.0.0\n#define MW_ETHERNET_SUBNETMASK 0.0.0.0\n#define MW_ETHERNET_GATEWAY 0.0.0.0\n#define MW_ADC1_USEDMA 0\n#define MW_ADC1_EOCENABLEINTERRUPT 0\n#define MW_ADC1_JEOCENABLEINTERRUPT 48\n#define MW_ADC1_OVRENABLEINTERRUPT 48\n#define MW_ADC1_CALIBRATE 1\n#define MW_ADC1_CALIBRATIONMETHOD 0\n#define MW_ADC1_CALIBRATIONMODE 0\n#define MW_ADC1_CALIBRATIONMODEMANUAL 0\n#define MW_ADC1_ADCCONVERSIONMODE 0\n#define MW_ADC1_OFFSETCALIBRATIONFACTORSINGLEENDED 0\n#define MW_ADC1_OFFSETCALIBRATIONFACTORDIFFENDED 0\n#define MW_ADC1_LINEARCALIBRATIONFACTORWORD1 0\n#define MW_ADC1_LINEARCALIBRATIONFACTORWORD2 0\n#define MW_ADC1_LINEARCALIBRATIONFACTORWORD3 0\n#define MW_ADC1_LINEARCALIBRATIONFACTORWORD4 0\n#define MW_ADC1_LINEARCALIBRATIONFACTORWORD5 0\n#define MW_ADC1_LINEARCALIBRATIONFACTORWORD6 0\n#define MW_ADC1_PROJECTFILEBUTTON \n#define MW_ADC2_USEDMA 0\n#define MW_ADC2_EOCENABLEINTERRUPT 0\n#define MW_ADC2_JEOCENABLEINTERRUPT 48\n#define MW_ADC2_OVRENABLEINTERRUPT 48\n#define MW_ADC2_CALIBRATE 1\n#define MW_ADC2_CALIBRATIONMETHOD 0\n#define MW_ADC2_CALIBRATIONMODE 0\n#define MW_ADC2_CALIBRATIONMODEMANUAL 0\n#define MW_ADC2_ADCCONVERSIONMODE 0\n#define MW_ADC2_OFFSETCALIBRATIONFACTORSINGLEENDED 0\n#define MW_ADC2_OFFSETCALIBRATIONFACTORDIFFENDED 0\n#define MW_ADC2_LINEARCALIBRATIONFACTORWORD1 0\n#define MW_ADC2_LINEARCALIBRATIONFACTORWORD2 0\n#define MW_ADC2_LINEARCALIBRATIONFACTORWORD3 0\n#define MW_ADC2_LINEARCALIBRATIONFACTORWORD4 0\n#define MW_ADC2_LINEARCALIBRATIONFACTORWORD5 0\n#define MW_ADC2_LINEARCALIBRATIONFACTORWORD6 0\n#define MW_ADC2_PROJECTFILEBUTTON \n#define MW_ADC3_USEDMA 0\n#define MW_ADC3_EOCENABLEINTERRUPT 0\n#define MW_ADC3_JEOCENABLEINTERRUPT 48\n#define MW_ADC3_OVRENABLEINTERRUPT 48\n#define MW_ADC3_CALIBRATE 1\n#define MW_ADC3_CALIBRATIONMETHOD 0\n#define MW_ADC3_CALIBRATIONMODE 0\n#define MW_ADC3_CALIBRATIONMODEMANUAL 0\n#define MW_ADC3_ADCCONVERSIONMODE 0\n#define MW_ADC3_OFFSETCALIBRATIONFACTORSINGLEENDED 0\n#define MW_ADC3_OFFSETCALIBRATIONFACTORDIFFENDED 0\n#define MW_ADC3_LINEARCALIBRATIONFACTORWORD1 0\n#define MW_ADC3_LINEARCALIBRATIONFACTORWORD2 0\n#define MW_ADC3_LINEARCALIBRATIONFACTORWORD3 0\n#define MW_ADC3_LINEARCALIBRATIONFACTORWORD4 0\n#define MW_ADC3_LINEARCALIBRATIONFACTORWORD5 0\n#define MW_ADC3_LINEARCALIBRATIONFACTORWORD6 0\n#define MW_ADC3_PROJECTFILEBUTTON \n#define MW_SPI_SPIMODULESELECT 0\n#define MW_SPI_SPI1TRANSMITMODE 2\n#define MW_SPI_SPI1TRANSMITBUFFERLENGTH 128\n#define MW_SPI_SPI1RECEIVEMODE 2\n#define MW_SPI_SPI1RECEIVEBUFFERLENGTH 128\n#define MW_SPI_SPI1TXFIFOINTERRUPT 0\n#define MW_SPI_SPI1RXFIFOINTERRUPT 0\n#define MW_SPI_SPI1TXRXREADYINTERRUPT 0\n#define MW_SPI_SPI1TXFAILEDINTERRUPT 0\n#define MW_SPI_SPI1UNDERRUNINTERRUPT 0\n#define MW_SPI_SPI1OVERRUNINTERRUPT 0\n#define MW_SPI_SPI1CRCERRORINTERRUPT 0\n#define MW_SPI_SPI1TIFRAMEERRORINTERRUPT 0\n#define MW_SPI_SPI1MODEFAULTINTERRUPT 0\n#define MW_SPI_SPI1ENDOFTXINTERRUPT 0\n#define MW_SPI_SPI1MASTERMODESUSPENDINTERRUPT 0\n#define MW_SPI_SPI1TXFIFOEMPTYINTERRUPT 0\n#define MW_SPI_SPI1TSERINTERRUPT 0\n#define MW_SPI_SPI2TRANSMITMODE 2\n#define MW_SPI_SPI2TRANSMITBUFFERLENGTH 128\n#define MW_SPI_SPI2RECEIVEMODE 2\n#define MW_SPI_SPI2RECEIVEBUFFERLENGTH 128\n#define MW_SPI_SPI2TXFIFOINTERRUPT 0\n#define MW_SPI_SPI2RXFIFOINTERRUPT 0\n#define MW_SPI_SPI2TXRXREADYINTERRUPT 0\n#define MW_SPI_SPI2TXFAILEDINTERRUPT 0\n#define MW_SPI_SPI2UNDERRUNINTERRUPT 0\n#define MW_SPI_SPI2OVERRUNINTERRUPT 0\n#define MW_SPI_SPI2CRCERRORINTERRUPT 0\n#define MW_SPI_SPI2TIFRAMEERRORINTERRUPT 0\n#define MW_SPI_SPI2MODEFAULTINTERRUPT 0\n#define MW_SPI_SPI2ENDOFTXINTERRUPT 0\n#define MW_SPI_SPI2MASTERMODESUSPENDINTERRUPT 0\n#define MW_SPI_SPI2TXFIFOEMPTYINTERRUPT 0\n#define MW_SPI_SPI2TSERINTERRUPT 0\n#define MW_SPI_SPI3TRANSMITMODE 2\n#define MW_SPI_SPI3TRANSMITBUFFERLENGTH 128\n#define MW_SPI_SPI3RECEIVEMODE 2\n#define MW_SPI_SPI3RECEIVEBUFFERLENGTH 128\n#define MW_SPI_SPI3TXFIFOINTERRUPT 0\n#define MW_SPI_SPI3RXFIFOINTERRUPT 0\n#define MW_SPI_SPI3TXRXREADYINTERRUPT 0\n#define MW_SPI_SPI3TXFAILEDINTERRUPT 0\n#define MW_SPI_SPI3UNDERRUNINTERRUPT 0\n#define MW_SPI_SPI3OVERRUNINTERRUPT 0\n#define MW_SPI_SPI3CRCERRORINTERRUPT 0\n#define MW_SPI_SPI3TIFRAMEERRORINTERRUPT 0\n#define MW_SPI_SPI3MODEFAULTINTERRUPT 0\n#define MW_SPI_SPI3ENDOFTXINTERRUPT 0\n#define MW_SPI_SPI3MASTERMODESUSPENDINTERRUPT 0\n#define MW_SPI_SPI3TXFIFOEMPTYINTERRUPT 0\n#define MW_SPI_SPI3TSERINTERRUPT 0\n#define MW_SPI_SPI4TRANSMITMODE 2\n#define MW_SPI_SPI4TRANSMITBUFFERLENGTH 128\n#define MW_SPI_SPI4RECEIVEMODE 2\n#define MW_SPI_SPI4RECEIVEBUFFERLENGTH 128\n#define MW_SPI_SPI4TXFIFOINTERRUPT 0\n#define MW_SPI_SPI4RXFIFOINTERRUPT 0\n#define MW_SPI_SPI4TXRXREADYINTERRUPT 0\n#define MW_SPI_SPI4TXFAILEDINTERRUPT 0\n#define MW_SPI_SPI4UNDERRUNINTERRUPT 0\n#define MW_SPI_SPI4OVERRUNINTERRUPT 0\n#define MW_SPI_SPI4CRCERRORINTERRUPT 0\n#define MW_SPI_SPI4TIFRAMEERRORINTERRUPT 0\n#define MW_SPI_SPI4MODEFAULTINTERRUPT 0\n#define MW_SPI_SPI4ENDOFTXINTERRUPT 0\n#define MW_SPI_SPI4MASTERMODESUSPENDINTERRUPT 0\n#define MW_SPI_SPI4TXFIFOEMPTYINTERRUPT 0\n#define MW_SPI_SPI4TSERINTERRUPT 0\n#define MW_SPI_SPI5TRANSMITMODE 2\n#define MW_SPI_SPI5TRANSMITBUFFERLENGTH 128\n#define MW_SPI_SPI5RECEIVEMODE 2\n#define MW_SPI_SPI5RECEIVEBUFFERLENGTH 128\n#define MW_SPI_SPI5TXFIFOINTERRUPT 0\n#define MW_SPI_SPI5RXFIFOINTERRUPT 0\n#define MW_SPI_SPI5TXRXREADYINTERRUPT 0\n#define MW_SPI_SPI5TXFAILEDINTERRUPT 0\n#define MW_SPI_SPI5UNDERRUNINTERRUPT 0\n#define MW_SPI_SPI5OVERRUNINTERRUPT 0\n#define MW_SPI_SPI5CRCERRORINTERRUPT 0\n#define MW_SPI_SPI5TIFRAMEERRORINTERRUPT 0\n#define MW_SPI_SPI5MODEFAULTINTERRUPT 0\n#define MW_SPI_SPI5ENDOFTXINTERRUPT 0\n#define MW_SPI_SPI5MASTERMODESUSPENDINTERRUPT 0\n#define MW_SPI_SPI5TXFIFOEMPTYINTERRUPT 0\n#define MW_SPI_SPI5TSERINTERRUPT 0\n#define MW_SPI_SPI6TRANSMITMODE 2\n#define MW_SPI_SPI6TRANSMITBUFFERLENGTH 128\n#define MW_SPI_SPI6RECEIVEMODE 2\n#define MW_SPI_SPI6RECEIVEBUFFERLENGTH 128\n#define MW_SPI_SPI6TXFIFOINTERRUPT 0\n#define MW_SPI_SPI6RXFIFOINTERRUPT 0\n#define MW_SPI_SPI6TXRXREADYINTERRUPT 0\n#define MW_SPI_SPI6TXFAILEDINTERRUPT 0\n#define MW_SPI_SPI6UNDERRUNINTERRUPT 0\n#define MW_SPI_SPI6OVERRUNINTERRUPT 0\n#define MW_SPI_SPI6CRCERRORINTERRUPT 0\n#define MW_SPI_SPI6TIFRAMEERRORINTERRUPT 0\n#define MW_SPI_SPI6MODEFAULTINTERRUPT 0\n#define MW_SPI_SPI6ENDOFTXINTERRUPT 0\n#define MW_SPI_SPI6MASTERMODESUSPENDINTERRUPT 0\n#define MW_SPI_SPI6TXFIFOEMPTYINTERRUPT 0\n#define MW_SPI_SPI6TSERINTERRUPT 0\n#define MW_HRTIM_UPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTTIMERAFORUPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTTIMERBFORUPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTTIMERCFORUPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTTIMERDFORUPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTTIMEREFORUPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTMAINTIMERFORUPDATEEVENTSUSPENDED 48\n#define MW_HRTIM_SELECTTIMERSFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_SELECTTIMERAFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_SELECTTIMERBFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_SELECTTIMERCFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_SELECTTIMERDFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_SELECTTIMEREFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_SELECTMAINTIMERFORSYNCCOUNTERSTART 0\n#define MW_HRTIM_TIMERINTERRUPTSELECT 0\n#define MW_HRTIM_TIMERADELAYEDPROTECTIONINTERRUPT 0\n#define MW_HRTIM_TIMERARESETROLLOVERINTERRUPT 0\n#define MW_HRTIM_TIMERAOUTPUT1RESETINTERRUPT 0\n#define MW_HRTIM_TIMERAOUTPUT2RESETINTERRUPT 0\n#define MW_HRTIM_TIMERAOUTPUT1SETINTERRUPT 0\n#define MW_HRTIM_TIMERAOUTPUT2SETINTERRUPT 0\n#define MW_HRTIM_TIMERACAPTURE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERACAPTURE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERAUPDATEEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERAREPETITIONEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERACOMPARE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERACOMPARE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERACOMPARE3EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERACOMPARE4EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBDELAYEDPROTECTIONINTERRUPT 0\n#define MW_HRTIM_TIMERBRESETROLLOVERINTERRUPT 0\n#define MW_HRTIM_TIMERBOUTPUT1RESETINTERRUPT 0\n#define MW_HRTIM_TIMERBOUTPUT2RESETINTERRUPT 0\n#define MW_HRTIM_TIMERBOUTPUT1SETINTERRUPT 0\n#define MW_HRTIM_TIMERBOUTPUT2SETINTERRUPT 0\n#define MW_HRTIM_TIMERBCAPTURE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBCAPTURE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBUPDATEEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBREPETITIONEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBCOMPARE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBCOMPARE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBCOMPARE3EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERBCOMPARE4EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCDELAYEDPROTECTIONINTERRUPT 0\n#define MW_HRTIM_TIMERCRESETROLLOVERINTERRUPT 0\n#define MW_HRTIM_TIMERCOUTPUT1RESETINTERRUPT 0\n#define MW_HRTIM_TIMERCOUTPUT2RESETINTERRUPT 0\n#define MW_HRTIM_TIMERCOUTPUT1SETINTERRUPT 0\n#define MW_HRTIM_TIMERCOUTPUT2SETINTERRUPT 0\n#define MW_HRTIM_TIMERCCAPTURE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCCAPTURE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCUPDATEEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCREPETITIONEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCCOMPARE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCCOMPARE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCCOMPARE3EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERCCOMPARE4EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDDELAYEDPROTECTIONINTERRUPT 0\n#define MW_HRTIM_TIMERDRESETROLLOVERINTERRUPT 0\n#define MW_HRTIM_TIMERDOUTPUT1RESETINTERRUPT 0\n#define MW_HRTIM_TIMERDOUTPUT2RESETINTERRUPT 0\n#define MW_HRTIM_TIMERDOUTPUT1SETINTERRUPT 0\n#define MW_HRTIM_TIMERDOUTPUT2SETINTERRUPT 0\n#define MW_HRTIM_TIMERDCAPTURE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDCAPTURE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDUPDATEEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDREPETITIONEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDCOMPARE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDCOMPARE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDCOMPARE3EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERDCOMPARE4EVENTINTERRUPT 0\n#define MW_HRTIM_TIMEREDELAYEDPROTECTIONINTERRUPT 0\n#define MW_HRTIM_TIMERERESETROLLOVERINTERRUPT 0\n#define MW_HRTIM_TIMEREOUTPUT1RESETINTERRUPT 0\n#define MW_HRTIM_TIMEREOUTPUT2RESETINTERRUPT 0\n#define MW_HRTIM_TIMEREOUTPUT1SETINTERRUPT 0\n#define MW_HRTIM_TIMEREOUTPUT2SETINTERRUPT 0\n#define MW_HRTIM_TIMERECAPTURE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERECAPTURE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMEREUPDATEEVENTINTERRUPT 0\n#define MW_HRTIM_TIMEREREPETITIONEVENTINTERRUPT 0\n#define MW_HRTIM_TIMERECOMPARE1EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERECOMPARE2EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERECOMPARE3EVENTINTERRUPT 0\n#define MW_HRTIM_TIMERECOMPARE4EVENTINTERRUPT 0\n#define MW_HRTIM_MAINTIMERRREGISTERUPDATEINTERRUPT 0\n#define MW_HRTIM_MAINTIMERSYNCEVENTINTERRUPT 0\n#define MW_HRTIM_MAINTIMERREPETITIONEVENTINTERRUPT 0\n#define MW_HRTIM_MAINTIMERCOMPARE1EVENTINTERRUPT 0\n#define MW_HRTIM_MAINTIMERCOMPARE2EVENTINTERRUPT 0\n#define MW_HRTIM_MAINTIMERCOMPARE3EVENTINTERRUPT 0\n#define MW_HRTIM_MAINTIMERCOMPARE4EVENTINTERRUPT 0\n#define MW_HRTIM_BURSTPRDDONETINTERRUPT 0\n#define MW_HRTIM_SYSFAULTEVENTINTERRUPT 0\n#define MW_HRTIM_FAULT1EVENTINTERRUPT 0\n#define MW_HRTIM_FAULT2EVENTINTERRUPT 0\n#define MW_HRTIM_FAULT3EVENTINTERRUPT 0\n#define MW_HRTIM_FAULT4EVENTINTERRUPT 0\n#define MW_HRTIM_FAULT5EVENTINTERRUPT 0\n#define MW_TIMER_TIMERGROUP 0\n#define MW_TIMER_TIM1CONFIGUREMODULE 48\n#define MW_TIMER_TIM8CONFIGUREMODULE 48\n#define MW_TIMER_TIM2CONFIGUREMODULE 48\n#define MW_TIMER_TIM3CONFIGUREMODULE 48\n#define MW_TIMER_TIM4CONFIGUREMODULE 48\n#define MW_TIMER_TIM5CONFIGUREMODULE 48\n#define MW_TIMER_TIM6CONFIGUREMODULE 48\n#define MW_TIMER_TIM7CONFIGUREMODULE 48\n#define MW_TIMER_TIM12CONFIGUREMODULE 48\n#define MW_TIMER_TIM13CONFIGUREMODULE 48\n#define MW_TIMER_TIM14CONFIGUREMODULE 48\n#define MW_TIMER_TIM15CONFIGUREMODULE 48\n#define MW_TIMER_TIM16CONFIGUREMODULE 48\n#define MW_TIMER_TIM17CONFIGUREMODULE 48\n#define MW_TIMER_TIM23CONFIGUREMODULE 48\n#define MW_TIMER_TIM24CONFIGUREMODULE 48\n#define MW_TIM1_STARTTIMER 49\n#define MW_TIM1_TRIGGERINTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM1_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM1_UPDATEINTERRUPT 48\n#define MW_TIM1_BREAKINTERRUPT 48\n#define MW_TIM1_COMINTERRUPT 48\n#define MW_TIM8_STARTTIMER 49\n#define MW_TIM8_TRIGGERINTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM8_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM8_UPDATEINTERRUPT 48\n#define MW_TIM8_BREAKINTERRUPT 48\n#define MW_TIM8_COMINTERRUPT 48\n#define MW_TIM2_STARTTIMER 49\n#define MW_TIM2_TRIGGERINTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM2_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM2_UPDATEINTERRUPT 48\n#define MW_TIM3_STARTTIMER 49\n#define MW_TIM3_TRIGGERINTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM3_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM3_UPDATEINTERRUPT 48\n#define MW_TIM4_STARTTIMER 49\n#define MW_TIM4_TRIGGERINTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM4_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM4_UPDATEINTERRUPT 48\n#define MW_TIM5_STARTTIMER 49\n#define MW_TIM5_TRIGGERINTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM5_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM5_UPDATEINTERRUPT 48\n#define MW_TIM6_STARTTIMER 49\n#define MW_TIM6_UPDATEINTERRUPT 48\n#define MW_TIM7_STARTTIMER 49\n#define MW_TIM7_UPDATEINTERRUPT 48\n#define MW_TIM12_STARTTIMER 49\n#define MW_TIM12_TRIGGERINTERRUPT 48\n#define MW_TIM12_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM12_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM12_UPDATEINTERRUPT 48\n#define MW_TIM13_STARTTIMER 49\n#define MW_TIM13_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM13_UPDATEINTERRUPT 48\n#define MW_TIM14_STARTTIMER 49\n#define MW_TIM14_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM14_UPDATEINTERRUPT 48\n#define MW_TIM15_STARTTIMER 49\n#define MW_TIM15_TRIGGERINTERRUPT 48\n#define MW_TIM15_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM15_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM15_UPDATEINTERRUPT 48\n#define MW_TIM15_BREAKINTERRUPT 48\n#define MW_TIM15_COMINTERRUPT 48\n#define MW_TIM16_STARTTIMER 49\n#define MW_TIM16_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM16_UPDATEINTERRUPT 48\n#define MW_TIM16_BREAKINTERRUPT 48\n#define MW_TIM16_COMINTERRUPT 48\n#define MW_TIM17_STARTTIMER 49\n#define MW_TIM17_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM17_UPDATEINTERRUPT 48\n#define MW_TIM17_BREAKINTERRUPT 48\n#define MW_TIM17_COMINTERRUPT 48\n#define MW_TIM23_STARTTIMER 49\n#define MW_TIM23_TRIGGERINTERRUPT 48\n#define MW_TIM23_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM23_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM23_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM23_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM23_UPDATEINTERRUPT 48\n#define MW_TIM24_STARTTIMER 49\n#define MW_TIM24_TRIGGERINTERRUPT 48\n#define MW_TIM24_CAPTURECOMPARE1INTERRUPT 48\n#define MW_TIM24_CAPTURECOMPARE2INTERRUPT 48\n#define MW_TIM24_CAPTURECOMPARE3INTERRUPT 48\n#define MW_TIM24_CAPTURECOMPARE4INTERRUPT 48\n#define MW_TIM24_UPDATEINTERRUPT 48\n#define MW_FDCAN_MODULE 0\n#define MW_FDCAN1_NOMINALBAUDRATE 1000000\n#define MW_FDCAN1_DATABAUDRATE 1000000\n#define MW_FDCAN1_ENABLEEDGEFILTER 0\n#define MW_FDCAN1_RXF0BLOCK 0\n#define MW_FDCAN1_RXF1BLOCK 0\n#define MW_FDCAN1_INTENRX 0\n#define MW_FDCAN1_INTENRXB 0\n#define MW_FDCAN1_INTRXBFNM 0\n#define MW_FDCAN1_INTENRXF0 0\n#define MW_FDCAN1_INTRXF0NM 0\n#define MW_FDCAN1_INTRXF0FL 0\n#define MW_FDCAN1_INTRXF0ML 0\n#define MW_FDCAN1_INTRXF0WM 0\n#define MW_FDCAN1_RXF0WMLVL 0\n#define MW_FDCAN1_INTENRXF1 0\n#define MW_FDCAN1_INTRXF1NM 0\n#define MW_FDCAN1_INTRXF1FL 0\n#define MW_FDCAN1_INTRXF1ML 0\n#define MW_FDCAN1_INTRXF1WM 0\n#define MW_FDCAN1_RXF1WMLVL 0\n#define MW_FDCAN1_INTHIPRIM 0\n#define MW_FDCAN1_INTENTX 0\n#define MW_FDCAN1_INTENTXF 0\n#define MW_FDCAN1_INTTXCOMP 0\n#define MW_FDCAN1_INTTXCNCL 0\n#define MW_FDCAN1_INTTXFEMP 0\n#define MW_FDCAN1_INTENTXEVF 0\n#define MW_FDCAN1_INTTXEVNE 0\n#define MW_FDCAN1_INTTXEVML 0\n#define MW_FDCAN1_INTTXEVFL 0\n#define MW_FDCAN1_INTTXEVWM 0\n#define MW_FDCAN1_TXEVFWMLVL 32\n#define MW_FDCAN1_INTENOTH 0\n#define MW_FDCAN1_INTTSWRAP 0\n#define MW_FDCAN1_INTMSRMAF 0\n#define MW_FDCAN1_INTTIMOUT 0\n#define MW_FDCAN1_INTERLGOV 0\n#define MW_FDCAN1_INTERRPSV 0\n#define MW_FDCAN1_INTWRNSTS 0\n#define MW_FDCAN1_INTBOFSTS 0\n#define MW_FDCAN1_INTWACHDG 0\n#define MW_FDCAN1_INTERRARB 0\n#define MW_FDCAN1_INTERRDTA 0\n#define MW_FDCAN1_INTRSVADD 0\n#define MW_FDCAN1_GFC 0\n#define MW_FDCAN1_RRFS 1\n#define MW_FDCAN1_RRFE 1\n#define MW_FDCAN1_NMFS 2\n#define MW_FDCAN1_NMFE 2\n#define MW_FDCAN1_SF 0\n#define MW_FDCAN1_SFNUMBER 0\n#define MW_FDCAN1_SF0C 0\n#define MW_FDCAN1_SF0TYPE 2\n#define MW_FDCAN1_SF0ID1 0\n#define MW_FDCAN1_SF0ID2 0\n#define MW_FDCAN1_SF1C 0\n#define MW_FDCAN1_SF1TYPE 2\n#define MW_FDCAN1_SF1ID1 0\n#define MW_FDCAN1_SF1ID2 0\n#define MW_FDCAN1_SF2C 0\n#define MW_FDCAN1_SF2TYPE 2\n#define MW_FDCAN1_SF2ID1 0\n#define MW_FDCAN1_SF2ID2 0\n#define MW_FDCAN1_SF3C 0\n#define MW_FDCAN1_SF3TYPE 2\n#define MW_FDCAN1_SF3ID1 0\n#define MW_FDCAN1_SF3ID2 0\n#define MW_FDCAN1_SF4C 0\n#define MW_FDCAN1_SF4TYPE 2\n#define MW_FDCAN1_SF4ID1 0\n#define MW_FDCAN1_SF4ID2 0\n#define MW_FDCAN1_SF5C 0\n#define MW_FDCAN1_SF5TYPE 2\n#define MW_FDCAN1_SF5ID1 0\n#define MW_FDCAN1_SF5ID2 0\n#define MW_FDCAN1_SF6C 0\n#define MW_FDCAN1_SF6TYPE 2\n#define MW_FDCAN1_SF6ID1 0\n#define MW_FDCAN1_SF6ID2 0\n#define MW_FDCAN1_SF7C 0\n#define MW_FDCAN1_SF7TYPE 2\n#define MW_FDCAN1_SF7ID1 0\n#define MW_FDCAN1_SF7ID2 0\n#define MW_FDCAN1_SF8C 0\n#define MW_FDCAN1_SF8TYPE 2\n#define MW_FDCAN1_SF8ID1 0\n#define MW_FDCAN1_SF8ID2 0\n#define MW_FDCAN1_SF9C 0\n#define MW_FDCAN1_SF9TYPE 2\n#define MW_FDCAN1_SF9ID1 0\n#define MW_FDCAN1_SF9ID2 0\n#define MW_FDCAN1_SF10C 0\n#define MW_FDCAN1_SF10TYPE 2\n#define MW_FDCAN1_SF10ID1 0\n#define MW_FDCAN1_SF10ID2 0\n#define MW_FDCAN1_SF11C 0\n#define MW_FDCAN1_SF11TYPE 2\n#define MW_FDCAN1_SF11ID1 0\n#define MW_FDCAN1_SF11ID2 0\n#define MW_FDCAN1_SF12C 0\n#define MW_FDCAN1_SF12TYPE 2\n#define MW_FDCAN1_SF12ID1 0\n#define MW_FDCAN1_SF12ID2 0\n#define MW_FDCAN1_SF13C 0\n#define MW_FDCAN1_SF13TYPE 2\n#define MW_FDCAN1_SF13ID1 0\n#define MW_FDCAN1_SF13ID2 0\n#define MW_FDCAN1_SF14C 0\n#define MW_FDCAN1_SF14TYPE 2\n#define MW_FDCAN1_SF14ID1 0\n#define MW_FDCAN1_SF14ID2 0\n#define MW_FDCAN1_SF15C 0\n#define MW_FDCAN1_SF15TYPE 2\n#define MW_FDCAN1_SF15ID1 0\n#define MW_FDCAN1_SF15ID2 0\n#define MW_FDCAN1_SF16C 0\n#define MW_FDCAN1_SF16TYPE 2\n#define MW_FDCAN1_SF16ID1 0\n#define MW_FDCAN1_SF16ID2 0\n#define MW_FDCAN1_SF17C 0\n#define MW_FDCAN1_SF17TYPE 2\n#define MW_FDCAN1_SF17ID1 0\n#define MW_FDCAN1_SF17ID2 0\n#define MW_FDCAN1_SF18C 0\n#define MW_FDCAN1_SF18TYPE 2\n#define MW_FDCAN1_SF18ID1 0\n#define MW_FDCAN1_SF18ID2 0\n#define MW_FDCAN1_SF19C 0\n#define MW_FDCAN1_SF19TYPE 2\n#define MW_FDCAN1_SF19ID1 0\n#define MW_FDCAN1_SF19ID2 0\n#define MW_FDCAN1_SF20C 0\n#define MW_FDCAN1_SF20TYPE 2\n#define MW_FDCAN1_SF20ID1 0\n#define MW_FDCAN1_SF20ID2 0\n#define MW_FDCAN1_SF21C 0\n#define MW_FDCAN1_SF21TYPE 2\n#define MW_FDCAN1_SF21ID1 0\n#define MW_FDCAN1_SF21ID2 0\n#define MW_FDCAN1_SF22C 0\n#define MW_FDCAN1_SF22TYPE 2\n#define MW_FDCAN1_SF22ID1 0\n#define MW_FDCAN1_SF22ID2 0\n#define MW_FDCAN1_SF23C 0\n#define MW_FDCAN1_SF23TYPE 2\n#define MW_FDCAN1_SF23ID1 0\n#define MW_FDCAN1_SF23ID2 0\n#define MW_FDCAN1_SF24C 0\n#define MW_FDCAN1_SF24TYPE 2\n#define MW_FDCAN1_SF24ID1 0\n#define MW_FDCAN1_SF24ID2 0\n#define MW_FDCAN1_SF25C 0\n#define MW_FDCAN1_SF25TYPE 2\n#define MW_FDCAN1_SF25ID1 0\n#define MW_FDCAN1_SF25ID2 0\n#define MW_FDCAN1_SF26C 0\n#define MW_FDCAN1_SF26TYPE 2\n#define MW_FDCAN1_SF26ID1 0\n#define MW_FDCAN1_SF26ID2 0\n#define MW_FDCAN1_SF27C 0\n#define MW_FDCAN1_SF27TYPE 2\n#define MW_FDCAN1_SF27ID1 0\n#define MW_FDCAN1_SF27ID2 0\n#define MW_FDCAN1_SF28C 0\n#define MW_FDCAN1_SF28TYPE 2\n#define MW_FDCAN1_SF28ID1 0\n#define MW_FDCAN1_SF28ID2 0\n#define MW_FDCAN1_SF29C 0\n#define MW_FDCAN1_SF29TYPE 2\n#define MW_FDCAN1_SF29ID1 0\n#define MW_FDCAN1_SF29ID2 0\n#define MW_FDCAN1_SF30C 0\n#define MW_FDCAN1_SF30TYPE 2\n#define MW_FDCAN1_SF30ID1 0\n#define MW_FDCAN1_SF30ID2 0\n#define MW_FDCAN1_SF31C 0\n#define MW_FDCAN1_SF31TYPE 2\n#define MW_FDCAN1_SF31ID1 0\n#define MW_FDCAN1_SF31ID2 0\n#define MW_FDCAN1_SF32C 0\n#define MW_FDCAN1_SF32TYPE 2\n#define MW_FDCAN1_SF32ID1 0\n#define MW_FDCAN1_SF32ID2 0\n#define MW_FDCAN1_SF33C 0\n#define MW_FDCAN1_SF33TYPE 2\n#define MW_FDCAN1_SF33ID1 0\n#define MW_FDCAN1_SF33ID2 0\n#define MW_FDCAN1_SF34C 0\n#define MW_FDCAN1_SF34TYPE 2\n#define MW_FDCAN1_SF34ID1 0\n#define MW_FDCAN1_SF34ID2 0\n#define MW_FDCAN1_SF35C 0\n#define MW_FDCAN1_SF35TYPE 2\n#define MW_FDCAN1_SF35ID1 0\n#define MW_FDCAN1_SF35ID2 0\n#define MW_FDCAN1_SF36C 0\n#define MW_FDCAN1_SF36TYPE 2\n#define MW_FDCAN1_SF36ID1 0\n#define MW_FDCAN1_SF36ID2 0\n#define MW_FDCAN1_SF37C 0\n#define MW_FDCAN1_SF37TYPE 2\n#define MW_FDCAN1_SF37ID1 0\n#define MW_FDCAN1_SF37ID2 0\n#define MW_FDCAN1_SF38C 0\n#define MW_FDCAN1_SF38TYPE 2\n#define MW_FDCAN1_SF38ID1 0\n#define MW_FDCAN1_SF38ID2 0\n#define MW_FDCAN1_SF39C 0\n#define MW_FDCAN1_SF39TYPE 2\n#define MW_FDCAN1_SF39ID1 0\n#define MW_FDCAN1_SF39ID2 0\n#define MW_FDCAN1_SF40C 0\n#define MW_FDCAN1_SF40TYPE 2\n#define MW_FDCAN1_SF40ID1 0\n#define MW_FDCAN1_SF40ID2 0\n#define MW_FDCAN1_SF41C 0\n#define MW_FDCAN1_SF41TYPE 2\n#define MW_FDCAN1_SF41ID1 0\n#define MW_FDCAN1_SF41ID2 0\n#define MW_FDCAN1_SF42C 0\n#define MW_FDCAN1_SF42TYPE 2\n#define MW_FDCAN1_SF42ID1 0\n#define MW_FDCAN1_SF42ID2 0\n#define MW_FDCAN1_SF43C 0\n#define MW_FDCAN1_SF43TYPE 2\n#define MW_FDCAN1_SF43ID1 0\n#define MW_FDCAN1_SF43ID2 0\n#define MW_FDCAN1_SF44C 0\n#define MW_FDCAN1_SF44TYPE 2\n#define MW_FDCAN1_SF44ID1 0\n#define MW_FDCAN1_SF44ID2 0\n#define MW_FDCAN1_SF45C 0\n#define MW_FDCAN1_SF45TYPE 2\n#define MW_FDCAN1_SF45ID1 0\n#define MW_FDCAN1_SF45ID2 0\n#define MW_FDCAN1_SF46C 0\n#define MW_FDCAN1_SF46TYPE 2\n#define MW_FDCAN1_SF46ID1 0\n#define MW_FDCAN1_SF46ID2 0\n#define MW_FDCAN1_SF47C 0\n#define MW_FDCAN1_SF47TYPE 2\n#define MW_FDCAN1_SF47ID1 0\n#define MW_FDCAN1_SF47ID2 0\n#define MW_FDCAN1_SF48C 0\n#define MW_FDCAN1_SF48TYPE 2\n#define MW_FDCAN1_SF48ID1 0\n#define MW_FDCAN1_SF48ID2 0\n#define MW_FDCAN1_SF49C 0\n#define MW_FDCAN1_SF49TYPE 2\n#define MW_FDCAN1_SF49ID1 0\n#define MW_FDCAN1_SF49ID2 0\n#define MW_FDCAN1_SF50C 0\n#define MW_FDCAN1_SF50TYPE 2\n#define MW_FDCAN1_SF50ID1 0\n#define MW_FDCAN1_SF50ID2 0\n#define MW_FDCAN1_SF51C 0\n#define MW_FDCAN1_SF51TYPE 2\n#define MW_FDCAN1_SF51ID1 0\n#define MW_FDCAN1_SF51ID2 0\n#define MW_FDCAN1_SF52C 0\n#define MW_FDCAN1_SF52TYPE 2\n#define MW_FDCAN1_SF52ID1 0\n#define MW_FDCAN1_SF52ID2 0\n#define MW_FDCAN1_SF53C 0\n#define MW_FDCAN1_SF53TYPE 2\n#define MW_FDCAN1_SF53ID1 0\n#define MW_FDCAN1_SF53ID2 0\n#define MW_FDCAN1_SF54C 0\n#define MW_FDCAN1_SF54TYPE 2\n#define MW_FDCAN1_SF54ID1 0\n#define MW_FDCAN1_SF54ID2 0\n#define MW_FDCAN1_SF55C 0\n#define MW_FDCAN1_SF55TYPE 2\n#define MW_FDCAN1_SF55ID1 0\n#define MW_FDCAN1_SF55ID2 0\n#define MW_FDCAN1_SF56C 0\n#define MW_FDCAN1_SF56TYPE 2\n#define MW_FDCAN1_SF56ID1 0\n#define MW_FDCAN1_SF56ID2 0\n#define MW_FDCAN1_SF57C 0\n#define MW_FDCAN1_SF57TYPE 2\n#define MW_FDCAN1_SF57ID1 0\n#define MW_FDCAN1_SF57ID2 0\n#define MW_FDCAN1_SF58C 0\n#define MW_FDCAN1_SF58TYPE 2\n#define MW_FDCAN1_SF58ID1 0\n#define MW_FDCAN1_SF58ID2 0\n#define MW_FDCAN1_SF59C 0\n#define MW_FDCAN1_SF59TYPE 2\n#define MW_FDCAN1_SF59ID1 0\n#define MW_FDCAN1_SF59ID2 0\n#define MW_FDCAN1_SF60C 0\n#define MW_FDCAN1_SF60TYPE 2\n#define MW_FDCAN1_SF60ID1 0\n#define MW_FDCAN1_SF60ID2 0\n#define MW_FDCAN1_SF61C 0\n#define MW_FDCAN1_SF61TYPE 2\n#define MW_FDCAN1_SF61ID1 0\n#define MW_FDCAN1_SF61ID2 0\n#define MW_FDCAN1_SF62C 0\n#define MW_FDCAN1_SF62TYPE 2\n#define MW_FDCAN1_SF62ID1 0\n#define MW_FDCAN1_SF62ID2 0\n#define MW_FDCAN1_SF63C 0\n#define MW_FDCAN1_SF63TYPE 2\n#define MW_FDCAN1_SF63ID1 0\n#define MW_FDCAN1_SF63ID2 0\n#define MW_FDCAN1_SF64C 0\n#define MW_FDCAN1_SF64TYPE 2\n#define MW_FDCAN1_SF64ID1 0\n#define MW_FDCAN1_SF64ID2 0\n#define MW_FDCAN1_SF65C 0\n#define MW_FDCAN1_SF65TYPE 2\n#define MW_FDCAN1_SF65ID1 0\n#define MW_FDCAN1_SF65ID2 0\n#define MW_FDCAN1_SF66C 0\n#define MW_FDCAN1_SF66TYPE 2\n#define MW_FDCAN1_SF66ID1 0\n#define MW_FDCAN1_SF66ID2 0\n#define MW_FDCAN1_SF67C 0\n#define MW_FDCAN1_SF67TYPE 2\n#define MW_FDCAN1_SF67ID1 0\n#define MW_FDCAN1_SF67ID2 0\n#define MW_FDCAN1_SF68C 0\n#define MW_FDCAN1_SF68TYPE 2\n#define MW_FDCAN1_SF68ID1 0\n#define MW_FDCAN1_SF68ID2 0\n#define MW_FDCAN1_SF69C 0\n#define MW_FDCAN1_SF69TYPE 2\n#define MW_FDCAN1_SF69ID1 0\n#define MW_FDCAN1_SF69ID2 0\n#define MW_FDCAN1_SF70C 0\n#define MW_FDCAN1_SF70TYPE 2\n#define MW_FDCAN1_SF70ID1 0\n#define MW_FDCAN1_SF70ID2 0\n#define MW_FDCAN1_SF71C 0\n#define MW_FDCAN1_SF71TYPE 2\n#define MW_FDCAN1_SF71ID1 0\n#define MW_FDCAN1_SF71ID2 0\n#define MW_FDCAN1_SF72C 0\n#define MW_FDCAN1_SF72TYPE 2\n#define MW_FDCAN1_SF72ID1 0\n#define MW_FDCAN1_SF72ID2 0\n#define MW_FDCAN1_SF73C 0\n#define MW_FDCAN1_SF73TYPE 2\n#define MW_FDCAN1_SF73ID1 0\n#define MW_FDCAN1_SF73ID2 0\n#define MW_FDCAN1_SF74C 0\n#define MW_FDCAN1_SF74TYPE 2\n#define MW_FDCAN1_SF74ID1 0\n#define MW_FDCAN1_SF74ID2 0\n#define MW_FDCAN1_SF75C 0\n#define MW_FDCAN1_SF75TYPE 2\n#define MW_FDCAN1_SF75ID1 0\n#define MW_FDCAN1_SF75ID2 0\n#define MW_FDCAN1_SF76C 0\n#define MW_FDCAN1_SF76TYPE 2\n#define MW_FDCAN1_SF76ID1 0\n#define MW_FDCAN1_SF76ID2 0\n#define MW_FDCAN1_SF77C 0\n#define MW_FDCAN1_SF77TYPE 2\n#define MW_FDCAN1_SF77ID1 0\n#define MW_FDCAN1_SF77ID2 0\n#define MW_FDCAN1_SF78C 0\n#define MW_FDCAN1_SF78TYPE 2\n#define MW_FDCAN1_SF78ID1 0\n#define MW_FDCAN1_SF78ID2 0\n#define MW_FDCAN1_SF79C 0\n#define MW_FDCAN1_SF79TYPE 2\n#define MW_FDCAN1_SF79ID1 0\n#define MW_FDCAN1_SF79ID2 0\n#define MW_FDCAN1_SF80C 0\n#define MW_FDCAN1_SF80TYPE 2\n#define MW_FDCAN1_SF80ID1 0\n#define MW_FDCAN1_SF80ID2 0\n#define MW_FDCAN1_SF81C 0\n#define MW_FDCAN1_SF81TYPE 2\n#define MW_FDCAN1_SF81ID1 0\n#define MW_FDCAN1_SF81ID2 0\n#define MW_FDCAN1_SF82C 0\n#define MW_FDCAN1_SF82TYPE 2\n#define MW_FDCAN1_SF82ID1 0\n#define MW_FDCAN1_SF82ID2 0\n#define MW_FDCAN1_SF83C 0\n#define MW_FDCAN1_SF83TYPE 2\n#define MW_FDCAN1_SF83ID1 0\n#define MW_FDCAN1_SF83ID2 0\n#define MW_FDCAN1_SF84C 0\n#define MW_FDCAN1_SF84TYPE 2\n#define MW_FDCAN1_SF84ID1 0\n#define MW_FDCAN1_SF84ID2 0\n#define MW_FDCAN1_SF85C 0\n#define MW_FDCAN1_SF85TYPE 2\n#define MW_FDCAN1_SF85ID1 0\n#define MW_FDCAN1_SF85ID2 0\n#define MW_FDCAN1_SF86C 0\n#define MW_FDCAN1_SF86TYPE 2\n#define MW_FDCAN1_SF86ID1 0\n#define MW_FDCAN1_SF86ID2 0\n#define MW_FDCAN1_SF87C 0\n#define MW_FDCAN1_SF87TYPE 2\n#define MW_FDCAN1_SF87ID1 0\n#define MW_FDCAN1_SF87ID2 0\n#define MW_FDCAN1_SF88C 0\n#define MW_FDCAN1_SF88TYPE 2\n#define MW_FDCAN1_SF88ID1 0\n#define MW_FDCAN1_SF88ID2 0\n#define MW_FDCAN1_SF89C 0\n#define MW_FDCAN1_SF89TYPE 2\n#define MW_FDCAN1_SF89ID1 0\n#define MW_FDCAN1_SF89ID2 0\n#define MW_FDCAN1_SF90C 0\n#define MW_FDCAN1_SF90TYPE 2\n#define MW_FDCAN1_SF90ID1 0\n#define MW_FDCAN1_SF90ID2 0\n#define MW_FDCAN1_SF91C 0\n#define MW_FDCAN1_SF91TYPE 2\n#define MW_FDCAN1_SF91ID1 0\n#define MW_FDCAN1_SF91ID2 0\n#define MW_FDCAN1_SF92C 0\n#define MW_FDCAN1_SF92TYPE 2\n#define MW_FDCAN1_SF92ID1 0\n#define MW_FDCAN1_SF92ID2 0\n#define MW_FDCAN1_SF93C 0\n#define MW_FDCAN1_SF93TYPE 2\n#define MW_FDCAN1_SF93ID1 0\n#define MW_FDCAN1_SF93ID2 0\n#define MW_FDCAN1_SF94C 0\n#define MW_FDCAN1_SF94TYPE 2\n#define MW_FDCAN1_SF94ID1 0\n#define MW_FDCAN1_SF94ID2 0\n#define MW_FDCAN1_SF95C 0\n#define MW_FDCAN1_SF95TYPE 2\n#define MW_FDCAN1_SF95ID1 0\n#define MW_FDCAN1_SF95ID2 0\n#define MW_FDCAN1_SF96C 0\n#define MW_FDCAN1_SF96TYPE 2\n#define MW_FDCAN1_SF96ID1 0\n#define MW_FDCAN1_SF96ID2 0\n#define MW_FDCAN1_SF97C 0\n#define MW_FDCAN1_SF97TYPE 2\n#define MW_FDCAN1_SF97ID1 0\n#define MW_FDCAN1_SF97ID2 0\n#define MW_FDCAN1_SF98C 0\n#define MW_FDCAN1_SF98TYPE 2\n#define MW_FDCAN1_SF98ID1 0\n#define MW_FDCAN1_SF98ID2 0\n#define MW_FDCAN1_SF99C 0\n#define MW_FDCAN1_SF99TYPE 2\n#define MW_FDCAN1_SF99ID1 0\n#define MW_FDCAN1_SF99ID2 0\n#define MW_FDCAN1_SF100C 0\n#define MW_FDCAN1_SF100TYPE 2\n#define MW_FDCAN1_SF100ID1 0\n#define MW_FDCAN1_SF100ID2 0\n#define MW_FDCAN1_SF101C 0\n#define MW_FDCAN1_SF101TYPE 2\n#define MW_FDCAN1_SF101ID1 0\n#define MW_FDCAN1_SF101ID2 0\n#define MW_FDCAN1_SF102C 0\n#define MW_FDCAN1_SF102TYPE 2\n#define MW_FDCAN1_SF102ID1 0\n#define MW_FDCAN1_SF102ID2 0\n#define MW_FDCAN1_SF103C 0\n#define MW_FDCAN1_SF103TYPE 2\n#define MW_FDCAN1_SF103ID1 0\n#define MW_FDCAN1_SF103ID2 0\n#define MW_FDCAN1_SF104C 0\n#define MW_FDCAN1_SF104TYPE 2\n#define MW_FDCAN1_SF104ID1 0\n#define MW_FDCAN1_SF104ID2 0\n#define MW_FDCAN1_SF105C 0\n#define MW_FDCAN1_SF105TYPE 2\n#define MW_FDCAN1_SF105ID1 0\n#define MW_FDCAN1_SF105ID2 0\n#define MW_FDCAN1_SF106C 0\n#define MW_FDCAN1_SF106TYPE 2\n#define MW_FDCAN1_SF106ID1 0\n#define MW_FDCAN1_SF106ID2 0\n#define MW_FDCAN1_SF107C 0\n#define MW_FDCAN1_SF107TYPE 2\n#define MW_FDCAN1_SF107ID1 0\n#define MW_FDCAN1_SF107ID2 0\n#define MW_FDCAN1_SF108C 0\n#define MW_FDCAN1_SF108TYPE 2\n#define MW_FDCAN1_SF108ID1 0\n#define MW_FDCAN1_SF108ID2 0\n#define MW_FDCAN1_SF109C 0\n#define MW_FDCAN1_SF109TYPE 2\n#define MW_FDCAN1_SF109ID1 0\n#define MW_FDCAN1_SF109ID2 0\n#define MW_FDCAN1_SF110C 0\n#define MW_FDCAN1_SF110TYPE 2\n#define MW_FDCAN1_SF110ID1 0\n#define MW_FDCAN1_SF110ID2 0\n#define MW_FDCAN1_SF111C 0\n#define MW_FDCAN1_SF111TYPE 2\n#define MW_FDCAN1_SF111ID1 0\n#define MW_FDCAN1_SF111ID2 0\n#define MW_FDCAN1_SF112C 0\n#define MW_FDCAN1_SF112TYPE 2\n#define MW_FDCAN1_SF112ID1 0\n#define MW_FDCAN1_SF112ID2 0\n#define MW_FDCAN1_SF113C 0\n#define MW_FDCAN1_SF113TYPE 2\n#define MW_FDCAN1_SF113ID1 0\n#define MW_FDCAN1_SF113ID2 0\n#define MW_FDCAN1_SF114C 0\n#define MW_FDCAN1_SF114TYPE 2\n#define MW_FDCAN1_SF114ID1 0\n#define MW_FDCAN1_SF114ID2 0\n#define MW_FDCAN1_SF115C 0\n#define MW_FDCAN1_SF115TYPE 2\n#define MW_FDCAN1_SF115ID1 0\n#define MW_FDCAN1_SF115ID2 0\n#define MW_FDCAN1_SF116C 0\n#define MW_FDCAN1_SF116TYPE 2\n#define MW_FDCAN1_SF116ID1 0\n#define MW_FDCAN1_SF116ID2 0\n#define MW_FDCAN1_SF117C 0\n#define MW_FDCAN1_SF117TYPE 2\n#define MW_FDCAN1_SF117ID1 0\n#define MW_FDCAN1_SF117ID2 0\n#define MW_FDCAN1_SF118C 0\n#define MW_FDCAN1_SF118TYPE 2\n#define MW_FDCAN1_SF118ID1 0\n#define MW_FDCAN1_SF118ID2 0\n#define MW_FDCAN1_SF119C 0\n#define MW_FDCAN1_SF119TYPE 2\n#define MW_FDCAN1_SF119ID1 0\n#define MW_FDCAN1_SF119ID2 0\n#define MW_FDCAN1_SF120C 0\n#define MW_FDCAN1_SF120TYPE 2\n#define MW_FDCAN1_SF120ID1 0\n#define MW_FDCAN1_SF120ID2 0\n#define MW_FDCAN1_SF121C 0\n#define MW_FDCAN1_SF121TYPE 2\n#define MW_FDCAN1_SF121ID1 0\n#define MW_FDCAN1_SF121ID2 0\n#define MW_FDCAN1_SF122C 0\n#define MW_FDCAN1_SF122TYPE 2\n#define MW_FDCAN1_SF122ID1 0\n#define MW_FDCAN1_SF122ID2 0\n#define MW_FDCAN1_SF123C 0\n#define MW_FDCAN1_SF123TYPE 2\n#define MW_FDCAN1_SF123ID1 0\n#define MW_FDCAN1_SF123ID2 0\n#define MW_FDCAN1_SF124C 0\n#define MW_FDCAN1_SF124TYPE 2\n#define MW_FDCAN1_SF124ID1 0\n#define MW_FDCAN1_SF124ID2 0\n#define MW_FDCAN1_SF125C 0\n#define MW_FDCAN1_SF125TYPE 2\n#define MW_FDCAN1_SF125ID1 0\n#define MW_FDCAN1_SF125ID2 0\n#define MW_FDCAN1_SF126C 0\n#define MW_FDCAN1_SF126TYPE 2\n#define MW_FDCAN1_SF126ID1 0\n#define MW_FDCAN1_SF126ID2 0\n#define MW_FDCAN1_SF127C 0\n#define MW_FDCAN1_SF127TYPE 2\n#define MW_FDCAN1_SF127ID1 0\n#define MW_FDCAN1_SF127ID2 0\n#define MW_FDCAN1_EF 0\n#define MW_FDCAN1_EFNUMBER 0\n#define MW_FDCAN1_EF0C 0\n#define MW_FDCAN1_EF0TYPE 2\n#define MW_FDCAN1_EF0ID1 0\n#define MW_FDCAN1_EF0ID2 0\n#define MW_FDCAN1_EF1C 0\n#define MW_FDCAN1_EF1TYPE 2\n#define MW_FDCAN1_EF1ID1 0\n#define MW_FDCAN1_EF1ID2 0\n#define MW_FDCAN1_EF2C 0\n#define MW_FDCAN1_EF2TYPE 2\n#define MW_FDCAN1_EF2ID1 0\n#define MW_FDCAN1_EF2ID2 0\n#define MW_FDCAN1_EF3C 0\n#define MW_FDCAN1_EF3TYPE 2\n#define MW_FDCAN1_EF3ID1 0\n#define MW_FDCAN1_EF3ID2 0\n#define MW_FDCAN1_EF4C 0\n#define MW_FDCAN1_EF4TYPE 2\n#define MW_FDCAN1_EF4ID1 0\n#define MW_FDCAN1_EF4ID2 0\n#define MW_FDCAN1_EF5C 0\n#define MW_FDCAN1_EF5TYPE 2\n#define MW_FDCAN1_EF5ID1 0\n#define MW_FDCAN1_EF5ID2 0\n#define MW_FDCAN1_EF6C 0\n#define MW_FDCAN1_EF6TYPE 2\n#define MW_FDCAN1_EF6ID1 0\n#define MW_FDCAN1_EF6ID2 0\n#define MW_FDCAN1_EF7C 0\n#define MW_FDCAN1_EF7TYPE 2\n#define MW_FDCAN1_EF7ID1 0\n#define MW_FDCAN1_EF7ID2 0\n#define MW_FDCAN1_EF8C 0\n#define MW_FDCAN1_EF8TYPE 2\n#define MW_FDCAN1_EF8ID1 0\n#define MW_FDCAN1_EF8ID2 0\n#define MW_FDCAN1_EF9C 0\n#define MW_FDCAN1_EF9TYPE 2\n#define MW_FDCAN1_EF9ID1 0\n#define MW_FDCAN1_EF9ID2 0\n#define MW_FDCAN1_EF10C 0\n#define MW_FDCAN1_EF10TYPE 2\n#define MW_FDCAN1_EF10ID1 0\n#define MW_FDCAN1_EF10ID2 0\n#define MW_FDCAN1_EF11C 0\n#define MW_FDCAN1_EF11TYPE 2\n#define MW_FDCAN1_EF11ID1 0\n#define MW_FDCAN1_EF11ID2 0\n#define MW_FDCAN1_EF12C 0\n#define MW_FDCAN1_EF12TYPE 2\n#define MW_FDCAN1_EF12ID1 0\n#define MW_FDCAN1_EF12ID2 0\n#define MW_FDCAN1_EF13C 0\n#define MW_FDCAN1_EF13TYPE 2\n#define MW_FDCAN1_EF13ID1 0\n#define MW_FDCAN1_EF13ID2 0\n#define MW_FDCAN1_EF14C 0\n#define MW_FDCAN1_EF14TYPE 2\n#define MW_FDCAN1_EF14ID1 0\n#define MW_FDCAN1_EF14ID2 0\n#define MW_FDCAN1_EF15C 0\n#define MW_FDCAN1_EF15TYPE 2\n#define MW_FDCAN1_EF15ID1 0\n#define MW_FDCAN1_EF15ID2 0\n#define MW_FDCAN1_EF16C 0\n#define MW_FDCAN1_EF16TYPE 2\n#define MW_FDCAN1_EF16ID1 0\n#define MW_FDCAN1_EF16ID2 0\n#define MW_FDCAN1_EF17C 0\n#define MW_FDCAN1_EF17TYPE 2\n#define MW_FDCAN1_EF17ID1 0\n#define MW_FDCAN1_EF17ID2 0\n#define MW_FDCAN1_EF18C 0\n#define MW_FDCAN1_EF18TYPE 2\n#define MW_FDCAN1_EF18ID1 0\n#define MW_FDCAN1_EF18ID2 0\n#define MW_FDCAN1_EF19C 0\n#define MW_FDCAN1_EF19TYPE 2\n#define MW_FDCAN1_EF19ID1 0\n#define MW_FDCAN1_EF19ID2 0\n#define MW_FDCAN1_EF20C 0\n#define MW_FDCAN1_EF20TYPE 2\n#define MW_FDCAN1_EF20ID1 0\n#define MW_FDCAN1_EF20ID2 0\n#define MW_FDCAN1_EF21C 0\n#define MW_FDCAN1_EF21TYPE 2\n#define MW_FDCAN1_EF21ID1 0\n#define MW_FDCAN1_EF21ID2 0\n#define MW_FDCAN1_EF22C 0\n#define MW_FDCAN1_EF22TYPE 2\n#define MW_FDCAN1_EF22ID1 0\n#define MW_FDCAN1_EF22ID2 0\n#define MW_FDCAN1_EF23C 0\n#define MW_FDCAN1_EF23TYPE 2\n#define MW_FDCAN1_EF23ID1 0\n#define MW_FDCAN1_EF23ID2 0\n#define MW_FDCAN1_EF24C 0\n#define MW_FDCAN1_EF24TYPE 2\n#define MW_FDCAN1_EF24ID1 0\n#define MW_FDCAN1_EF24ID2 0\n#define MW_FDCAN1_EF25C 0\n#define MW_FDCAN1_EF25TYPE 2\n#define MW_FDCAN1_EF25ID1 0\n#define MW_FDCAN1_EF25ID2 0\n#define MW_FDCAN1_EF26C 0\n#define MW_FDCAN1_EF26TYPE 2\n#define MW_FDCAN1_EF26ID1 0\n#define MW_FDCAN1_EF26ID2 0\n#define MW_FDCAN1_EF27C 0\n#define MW_FDCAN1_EF27TYPE 2\n#define MW_FDCAN1_EF27ID1 0\n#define MW_FDCAN1_EF27ID2 0\n#define MW_FDCAN1_EF28C 0\n#define MW_FDCAN1_EF28TYPE 2\n#define MW_FDCAN1_EF28ID1 0\n#define MW_FDCAN1_EF28ID2 0\n#define MW_FDCAN1_EF29C 0\n#define MW_FDCAN1_EF29TYPE 2\n#define MW_FDCAN1_EF29ID1 0\n#define MW_FDCAN1_EF29ID2 0\n#define MW_FDCAN1_EF30C 0\n#define MW_FDCAN1_EF30TYPE 2\n#define MW_FDCAN1_EF30ID1 0\n#define MW_FDCAN1_EF30ID2 0\n#define MW_FDCAN1_EF31C 0\n#define MW_FDCAN1_EF31TYPE 2\n#define MW_FDCAN1_EF31ID1 0\n#define MW_FDCAN1_EF31ID2 0\n#define MW_FDCAN1_EF32C 0\n#define MW_FDCAN1_EF32TYPE 2\n#define MW_FDCAN1_EF32ID1 0\n#define MW_FDCAN1_EF32ID2 0\n#define MW_FDCAN1_EF33C 0\n#define MW_FDCAN1_EF33TYPE 2\n#define MW_FDCAN1_EF33ID1 0\n#define MW_FDCAN1_EF33ID2 0\n#define MW_FDCAN1_EF34C 0\n#define MW_FDCAN1_EF34TYPE 2\n#define MW_FDCAN1_EF34ID1 0\n#define MW_FDCAN1_EF34ID2 0\n#define MW_FDCAN1_EF35C 0\n#define MW_FDCAN1_EF35TYPE 2\n#define MW_FDCAN1_EF35ID1 0\n#define MW_FDCAN1_EF35ID2 0\n#define MW_FDCAN1_EF36C 0\n#define MW_FDCAN1_EF36TYPE 2\n#define MW_FDCAN1_EF36ID1 0\n#define MW_FDCAN1_EF36ID2 0\n#define MW_FDCAN1_EF37C 0\n#define MW_FDCAN1_EF37TYPE 2\n#define MW_FDCAN1_EF37ID1 0\n#define MW_FDCAN1_EF37ID2 0\n#define MW_FDCAN1_EF38C 0\n#define MW_FDCAN1_EF38TYPE 2\n#define MW_FDCAN1_EF38ID1 0\n#define MW_FDCAN1_EF38ID2 0\n#define MW_FDCAN1_EF39C 0\n#define MW_FDCAN1_EF39TYPE 2\n#define MW_FDCAN1_EF39ID1 0\n#define MW_FDCAN1_EF39ID2 0\n#define MW_FDCAN1_EF40C 0\n#define MW_FDCAN1_EF40TYPE 2\n#define MW_FDCAN1_EF40ID1 0\n#define MW_FDCAN1_EF40ID2 0\n#define MW_FDCAN1_EF41C 0\n#define MW_FDCAN1_EF41TYPE 2\n#define MW_FDCAN1_EF41ID1 0\n#define MW_FDCAN1_EF41ID2 0\n#define MW_FDCAN1_EF42C 0\n#define MW_FDCAN1_EF42TYPE 2\n#define MW_FDCAN1_EF42ID1 0\n#define MW_FDCAN1_EF42ID2 0\n#define MW_FDCAN1_EF43C 0\n#define MW_FDCAN1_EF43TYPE 2\n#define MW_FDCAN1_EF43ID1 0\n#define MW_FDCAN1_EF43ID2 0\n#define MW_FDCAN1_EF44C 0\n#define MW_FDCAN1_EF44TYPE 2\n#define MW_FDCAN1_EF44ID1 0\n#define MW_FDCAN1_EF44ID2 0\n#define MW_FDCAN1_EF45C 0\n#define MW_FDCAN1_EF45TYPE 2\n#define MW_FDCAN1_EF45ID1 0\n#define MW_FDCAN1_EF45ID2 0\n#define MW_FDCAN1_EF46C 0\n#define MW_FDCAN1_EF46TYPE 2\n#define MW_FDCAN1_EF46ID1 0\n#define MW_FDCAN1_EF46ID2 0\n#define MW_FDCAN1_EF47C 0\n#define MW_FDCAN1_EF47TYPE 2\n#define MW_FDCAN1_EF47ID1 0\n#define MW_FDCAN1_EF47ID2 0\n#define MW_FDCAN1_EF48C 0\n#define MW_FDCAN1_EF48TYPE 2\n#define MW_FDCAN1_EF48ID1 0\n#define MW_FDCAN1_EF48ID2 0\n#define MW_FDCAN1_EF49C 0\n#define MW_FDCAN1_EF49TYPE 2\n#define MW_FDCAN1_EF49ID1 0\n#define MW_FDCAN1_EF49ID2 0\n#define MW_FDCAN1_EF50C 0\n#define MW_FDCAN1_EF50TYPE 2\n#define MW_FDCAN1_EF50ID1 0\n#define MW_FDCAN1_EF50ID2 0\n#define MW_FDCAN1_EF51C 0\n#define MW_FDCAN1_EF51TYPE 2\n#define MW_FDCAN1_EF51ID1 0\n#define MW_FDCAN1_EF51ID2 0\n#define MW_FDCAN1_EF52C 0\n#define MW_FDCAN1_EF52TYPE 2\n#define MW_FDCAN1_EF52ID1 0\n#define MW_FDCAN1_EF52ID2 0\n#define MW_FDCAN1_EF53C 0\n#define MW_FDCAN1_EF53TYPE 2\n#define MW_FDCAN1_EF53ID1 0\n#define MW_FDCAN1_EF53ID2 0\n#define MW_FDCAN1_EF54C 0\n#define MW_FDCAN1_EF54TYPE 2\n#define MW_FDCAN1_EF54ID1 0\n#define MW_FDCAN1_EF54ID2 0\n#define MW_FDCAN1_EF55C 0\n#define MW_FDCAN1_EF55TYPE 2\n#define MW_FDCAN1_EF55ID1 0\n#define MW_FDCAN1_EF55ID2 0\n#define MW_FDCAN1_EF56C 0\n#define MW_FDCAN1_EF56TYPE 2\n#define MW_FDCAN1_EF56ID1 0\n#define MW_FDCAN1_EF56ID2 0\n#define MW_FDCAN1_EF57C 0\n#define MW_FDCAN1_EF57TYPE 2\n#define MW_FDCAN1_EF57ID1 0\n#define MW_FDCAN1_EF57ID2 0\n#define MW_FDCAN1_EF58C 0\n#define MW_FDCAN1_EF58TYPE 2\n#define MW_FDCAN1_EF58ID1 0\n#define MW_FDCAN1_EF58ID2 0\n#define MW_FDCAN1_EF59C 0\n#define MW_FDCAN1_EF59TYPE 2\n#define MW_FDCAN1_EF59ID1 0\n#define MW_FDCAN1_EF59ID2 0\n#define MW_FDCAN1_EF60C 0\n#define MW_FDCAN1_EF60TYPE 2\n#define MW_FDCAN1_EF60ID1 0\n#define MW_FDCAN1_EF60ID2 0\n#define MW_FDCAN1_EF61C 0\n#define MW_FDCAN1_EF61TYPE 2\n#define MW_FDCAN1_EF61ID1 0\n#define MW_FDCAN1_EF61ID2 0\n#define MW_FDCAN1_EF62C 0\n#define MW_FDCAN1_EF62TYPE 2\n#define MW_FDCAN1_EF62ID1 0\n#define MW_FDCAN1_EF62ID2 0\n#define MW_FDCAN1_EF63C 0\n#define MW_FDCAN1_EF63TYPE 2\n#define MW_FDCAN1_EF63ID1 0\n#define MW_FDCAN1_EF63ID2 0\n#define MW_FDCAN2_NOMINALBAUDRATE 1000000\n#define MW_FDCAN2_DATABAUDRATE 1000000\n#define MW_FDCAN2_ENABLEEDGEFILTER 0\n#define MW_FDCAN2_RXF0BLOCK 0\n#define MW_FDCAN2_RXF1BLOCK 0\n#define MW_FDCAN2_INTENRX 0\n#define MW_FDCAN2_INTENRXB 0\n#define MW_FDCAN2_INTRXBFNM 0\n#define MW_FDCAN2_INTENRXF0 0\n#define MW_FDCAN2_INTRXF0NM 0\n#define MW_FDCAN2_INTRXF0FL 0\n#define MW_FDCAN2_INTRXF0ML 0\n#define MW_FDCAN2_INTRXF0WM 0\n#define MW_FDCAN2_RXF0WMLVL 0\n#define MW_FDCAN2_INTENRXF1 0\n#define MW_FDCAN2_INTRXF1NM 0\n#define MW_FDCAN2_INTRXF1FL 0\n#define MW_FDCAN2_INTRXF1ML 0\n#define MW_FDCAN2_INTRXF1WM 0\n#define MW_FDCAN2_RXF1WMLVL 0\n#define MW_FDCAN2_INTHIPRIM 0\n#define MW_FDCAN2_INTENTX 0\n#define MW_FDCAN2_INTENTXF 0\n#define MW_FDCAN2_INTTXCOMP 0\n#define MW_FDCAN2_INTTXCNCL 0\n#define MW_FDCAN2_INTTXFEMP 0\n#define MW_FDCAN2_INTENTXEVF 0\n#define MW_FDCAN2_INTTXEVNE 0\n#define MW_FDCAN2_INTTXEVML 0\n#define MW_FDCAN2_INTTXEVFL 0\n#define MW_FDCAN2_INTTXEVWM 0\n#define MW_FDCAN2_TXEVFWMLVL 32\n#define MW_FDCAN2_INTENOTH 0\n#define MW_FDCAN2_INTTSWRAP 0\n#define MW_FDCAN2_INTMSRMAF 0\n#define MW_FDCAN2_INTTIMOUT 0\n#define MW_FDCAN2_INTERLGOV 0\n#define MW_FDCAN2_INTERRPSV 0\n#define MW_FDCAN2_INTWRNSTS 0\n#define MW_FDCAN2_INTBOFSTS 0\n#define MW_FDCAN2_INTWACHDG 0\n#define MW_FDCAN2_INTERRARB 0\n#define MW_FDCAN2_INTERRDTA 0\n#define MW_FDCAN2_INTRSVADD 0\n#define MW_FDCAN2_GFC 0\n#define MW_FDCAN2_RRFS 1\n#define MW_FDCAN2_RRFE 1\n#define MW_FDCAN2_NMFS 2\n#define MW_FDCAN2_NMFE 2\n#define MW_FDCAN2_SF 0\n#define MW_FDCAN2_SFNUMBER 0\n#define MW_FDCAN2_SF0C 0\n#define MW_FDCAN2_SF0TYPE 2\n#define MW_FDCAN2_SF0ID1 0\n#define MW_FDCAN2_SF0ID2 0\n#define MW_FDCAN2_SF1C 0\n#define MW_FDCAN2_SF1TYPE 2\n#define MW_FDCAN2_SF1ID1 0\n#define MW_FDCAN2_SF1ID2 0\n#define MW_FDCAN2_SF2C 0\n#define MW_FDCAN2_SF2TYPE 2\n#define MW_FDCAN2_SF2ID1 0\n#define MW_FDCAN2_SF2ID2 0\n#define MW_FDCAN2_SF3C 0\n#define MW_FDCAN2_SF3TYPE 2\n#define MW_FDCAN2_SF3ID1 0\n#define MW_FDCAN2_SF3ID2 0\n#define MW_FDCAN2_SF4C 0\n#define MW_FDCAN2_SF4TYPE 2\n#define MW_FDCAN2_SF4ID1 0\n#define MW_FDCAN2_SF4ID2 0\n#define MW_FDCAN2_SF5C 0\n#define MW_FDCAN2_SF5TYPE 2\n#define MW_FDCAN2_SF5ID1 0\n#define MW_FDCAN2_SF5ID2 0\n#define MW_FDCAN2_SF6C 0\n#define MW_FDCAN2_SF6TYPE 2\n#define MW_FDCAN2_SF6ID1 0\n#define MW_FDCAN2_SF6ID2 0\n#define MW_FDCAN2_SF7C 0\n#define MW_FDCAN2_SF7TYPE 2\n#define MW_FDCAN2_SF7ID1 0\n#define MW_FDCAN2_SF7ID2 0\n#define MW_FDCAN2_SF8C 0\n#define MW_FDCAN2_SF8TYPE 2\n#define MW_FDCAN2_SF8ID1 0\n#define MW_FDCAN2_SF8ID2 0\n#define MW_FDCAN2_SF9C 0\n#define MW_FDCAN2_SF9TYPE 2\n#define MW_FDCAN2_SF9ID1 0\n#define MW_FDCAN2_SF9ID2 0\n#define MW_FDCAN2_SF10C 0\n#define MW_FDCAN2_SF10TYPE 2\n#define MW_FDCAN2_SF10ID1 0\n#define MW_FDCAN2_SF10ID2 0\n#define MW_FDCAN2_SF11C 0\n#define MW_FDCAN2_SF11TYPE 2\n#define MW_FDCAN2_SF11ID1 0\n#define MW_FDCAN2_SF11ID2 0\n#define MW_FDCAN2_SF12C 0\n#define MW_FDCAN2_SF12TYPE 2\n#define MW_FDCAN2_SF12ID1 0\n#define MW_FDCAN2_SF12ID2 0\n#define MW_FDCAN2_SF13C 0\n#define MW_FDCAN2_SF13TYPE 2\n#define MW_FDCAN2_SF13ID1 0\n#define MW_FDCAN2_SF13ID2 0\n#define MW_FDCAN2_SF14C 0\n#define MW_FDCAN2_SF14TYPE 2\n#define MW_FDCAN2_SF14ID1 0\n#define MW_FDCAN2_SF14ID2 0\n#define MW_FDCAN2_SF15C 0\n#define MW_FDCAN2_SF15TYPE 2\n#define MW_FDCAN2_SF15ID1 0\n#define MW_FDCAN2_SF15ID2 0\n#define MW_FDCAN2_SF16C 0\n#define MW_FDCAN2_SF16TYPE 2\n#define MW_FDCAN2_SF16ID1 0\n#define MW_FDCAN2_SF16ID2 0\n#define MW_FDCAN2_SF17C 0\n#define MW_FDCAN2_SF17TYPE 2\n#define MW_FDCAN2_SF17ID1 0\n#define MW_FDCAN2_SF17ID2 0\n#define MW_FDCAN2_SF18C 0\n#define MW_FDCAN2_SF18TYPE 2\n#define MW_FDCAN2_SF18ID1 0\n#define MW_FDCAN2_SF18ID2 0\n#define MW_FDCAN2_SF19C 0\n#define MW_FDCAN2_SF19TYPE 2\n#define MW_FDCAN2_SF19ID1 0\n#define MW_FDCAN2_SF19ID2 0\n#define MW_FDCAN2_SF20C 0\n#define MW_FDCAN2_SF20TYPE 2\n#define MW_FDCAN2_SF20ID1 0\n#define MW_FDCAN2_SF20ID2 0\n#define MW_FDCAN2_SF21C 0\n#define MW_FDCAN2_SF21TYPE 2\n#define MW_FDCAN2_SF21ID1 0\n#define MW_FDCAN2_SF21ID2 0\n#define MW_FDCAN2_SF22C 0\n#define MW_FDCAN2_SF22TYPE 2\n#define MW_FDCAN2_SF22ID1 0\n#define MW_FDCAN2_SF22ID2 0\n#define MW_FDCAN2_SF23C 0\n#define MW_FDCAN2_SF23TYPE 2\n#define MW_FDCAN2_SF23ID1 0\n#define MW_FDCAN2_SF23ID2 0\n#define MW_FDCAN2_SF24C 0\n#define MW_FDCAN2_SF24TYPE 2\n#define MW_FDCAN2_SF24ID1 0\n#define MW_FDCAN2_SF24ID2 0\n#define MW_FDCAN2_SF25C 0\n#define MW_FDCAN2_SF25TYPE 2\n#define MW_FDCAN2_SF25ID1 0\n#define MW_FDCAN2_SF25ID2 0\n#define MW_FDCAN2_SF26C 0\n#define MW_FDCAN2_SF26TYPE 2\n#define MW_FDCAN2_SF26ID1 0\n#define MW_FDCAN2_SF26ID2 0\n#define MW_FDCAN2_SF27C 0\n#define MW_FDCAN2_SF27TYPE 2\n#define MW_FDCAN2_SF27ID1 0\n#define MW_FDCAN2_SF27ID2 0\n#define MW_FDCAN2_SF28C 0\n#define MW_FDCAN2_SF28TYPE 2\n#define MW_FDCAN2_SF28ID1 0\n#define MW_FDCAN2_SF28ID2 0\n#define MW_FDCAN2_SF29C 0\n#define MW_FDCAN2_SF29TYPE 2\n#define MW_FDCAN2_SF29ID1 0\n#define MW_FDCAN2_SF29ID2 0\n#define MW_FDCAN2_SF30C 0\n#define MW_FDCAN2_SF30TYPE 2\n#define MW_FDCAN2_SF30ID1 0\n#define MW_FDCAN2_SF30ID2 0\n#define MW_FDCAN2_SF31C 0\n#define MW_FDCAN2_SF31TYPE 2\n#define MW_FDCAN2_SF31ID1 0\n#define MW_FDCAN2_SF31ID2 0\n#define MW_FDCAN2_SF32C 0\n#define MW_FDCAN2_SF32TYPE 2\n#define MW_FDCAN2_SF32ID1 0\n#define MW_FDCAN2_SF32ID2 0\n#define MW_FDCAN2_SF33C 0\n#define MW_FDCAN2_SF33TYPE 2\n#define MW_FDCAN2_SF33ID1 0\n#define MW_FDCAN2_SF33ID2 0\n#define MW_FDCAN2_SF34C 0\n#define MW_FDCAN2_SF34TYPE 2\n#define MW_FDCAN2_SF34ID1 0\n#define MW_FDCAN2_SF34ID2 0\n#define MW_FDCAN2_SF35C 0\n#define MW_FDCAN2_SF35TYPE 2\n#define MW_FDCAN2_SF35ID1 0\n#define MW_FDCAN2_SF35ID2 0\n#define MW_FDCAN2_SF36C 0\n#define MW_FDCAN2_SF36TYPE 2\n#define MW_FDCAN2_SF36ID1 0\n#define MW_FDCAN2_SF36ID2 0\n#define MW_FDCAN2_SF37C 0\n#define MW_FDCAN2_SF37TYPE 2\n#define MW_FDCAN2_SF37ID1 0\n#define MW_FDCAN2_SF37ID2 0\n#define MW_FDCAN2_SF38C 0\n#define MW_FDCAN2_SF38TYPE 2\n#define MW_FDCAN2_SF38ID1 0\n#define MW_FDCAN2_SF38ID2 0\n#define MW_FDCAN2_SF39C 0\n#define MW_FDCAN2_SF39TYPE 2\n#define MW_FDCAN2_SF39ID1 0\n#define MW_FDCAN2_SF39ID2 0\n#define MW_FDCAN2_SF40C 0\n#define MW_FDCAN2_SF40TYPE 2\n#define MW_FDCAN2_SF40ID1 0\n#define MW_FDCAN2_SF40ID2 0\n#define MW_FDCAN2_SF41C 0\n#define MW_FDCAN2_SF41TYPE 2\n#define MW_FDCAN2_SF41ID1 0\n#define MW_FDCAN2_SF41ID2 0\n#define MW_FDCAN2_SF42C 0\n#define MW_FDCAN2_SF42TYPE 2\n#define MW_FDCAN2_SF42ID1 0\n#define MW_FDCAN2_SF42ID2 0\n#define MW_FDCAN2_SF43C 0\n#define MW_FDCAN2_SF43TYPE 2\n#define MW_FDCAN2_SF43ID1 0\n#define MW_FDCAN2_SF43ID2 0\n#define MW_FDCAN2_SF44C 0\n#define MW_FDCAN2_SF44TYPE 2\n#define MW_FDCAN2_SF44ID1 0\n#define MW_FDCAN2_SF44ID2 0\n#define MW_FDCAN2_SF45C 0\n#define MW_FDCAN2_SF45TYPE 2\n#define MW_FDCAN2_SF45ID1 0\n#define MW_FDCAN2_SF45ID2 0\n#define MW_FDCAN2_SF46C 0\n#define MW_FDCAN2_SF46TYPE 2\n#define MW_FDCAN2_SF46ID1 0\n#define MW_FDCAN2_SF46ID2 0\n#define MW_FDCAN2_SF47C 0\n#define MW_FDCAN2_SF47TYPE 2\n#define MW_FDCAN2_SF47ID1 0\n#define MW_FDCAN2_SF47ID2 0\n#define MW_FDCAN2_SF48C 0\n#define MW_FDCAN2_SF48TYPE 2\n#define MW_FDCAN2_SF48ID1 0\n#define MW_FDCAN2_SF48ID2 0\n#define MW_FDCAN2_SF49C 0\n#define MW_FDCAN2_SF49TYPE 2\n#define MW_FDCAN2_SF49ID1 0\n#define MW_FDCAN2_SF49ID2 0\n#define MW_FDCAN2_SF50C 0\n#define MW_FDCAN2_SF50TYPE 2\n#define MW_FDCAN2_SF50ID1 0\n#define MW_FDCAN2_SF50ID2 0\n#define MW_FDCAN2_SF51C 0\n#define MW_FDCAN2_SF51TYPE 2\n#define MW_FDCAN2_SF51ID1 0\n#define MW_FDCAN2_SF51ID2 0\n#define MW_FDCAN2_SF52C 0\n#define MW_FDCAN2_SF52TYPE 2\n#define MW_FDCAN2_SF52ID1 0\n#define MW_FDCAN2_SF52ID2 0\n#define MW_FDCAN2_SF53C 0\n#define MW_FDCAN2_SF53TYPE 2\n#define MW_FDCAN2_SF53ID1 0\n#define MW_FDCAN2_SF53ID2 0\n#define MW_FDCAN2_SF54C 0\n#define MW_FDCAN2_SF54TYPE 2\n#define MW_FDCAN2_SF54ID1 0\n#define MW_FDCAN2_SF54ID2 0\n#define MW_FDCAN2_SF55C 0\n#define MW_FDCAN2_SF55TYPE 2\n#define MW_FDCAN2_SF55ID1 0\n#define MW_FDCAN2_SF55ID2 0\n#define MW_FDCAN2_SF56C 0\n#define MW_FDCAN2_SF56TYPE 2\n#define MW_FDCAN2_SF56ID1 0\n#define MW_FDCAN2_SF56ID2 0\n#define MW_FDCAN2_SF57C 0\n#define MW_FDCAN2_SF57TYPE 2\n#define MW_FDCAN2_SF57ID1 0\n#define MW_FDCAN2_SF57ID2 0\n#define MW_FDCAN2_SF58C 0\n#define MW_FDCAN2_SF58TYPE 2\n#define MW_FDCAN2_SF58ID1 0\n#define MW_FDCAN2_SF58ID2 0\n#define MW_FDCAN2_SF59C 0\n#define MW_FDCAN2_SF59TYPE 2\n#define MW_FDCAN2_SF59ID1 0\n#define MW_FDCAN2_SF59ID2 0\n#define MW_FDCAN2_SF60C 0\n#define MW_FDCAN2_SF60TYPE 2\n#define MW_FDCAN2_SF60ID1 0\n#define MW_FDCAN2_SF60ID2 0\n#define MW_FDCAN2_SF61C 0\n#define MW_FDCAN2_SF61TYPE 2\n#define MW_FDCAN2_SF61ID1 0\n#define MW_FDCAN2_SF61ID2 0\n#define MW_FDCAN2_SF62C 0\n#define MW_FDCAN2_SF62TYPE 2\n#define MW_FDCAN2_SF62ID1 0\n#define MW_FDCAN2_SF62ID2 0\n#define MW_FDCAN2_SF63C 0\n#define MW_FDCAN2_SF63TYPE 2\n#define MW_FDCAN2_SF63ID1 0\n#define MW_FDCAN2_SF63ID2 0\n#define MW_FDCAN2_SF64C 0\n#define MW_FDCAN2_SF64TYPE 2\n#define MW_FDCAN2_SF64ID1 0\n#define MW_FDCAN2_SF64ID2 0\n#define MW_FDCAN2_SF65C 0\n#define MW_FDCAN2_SF65TYPE 2\n#define MW_FDCAN2_SF65ID1 0\n#define MW_FDCAN2_SF65ID2 0\n#define MW_FDCAN2_SF66C 0\n#define MW_FDCAN2_SF66TYPE 2\n#define MW_FDCAN2_SF66ID1 0\n#define MW_FDCAN2_SF66ID2 0\n#define MW_FDCAN2_SF67C 0\n#define MW_FDCAN2_SF67TYPE 2\n#define MW_FDCAN2_SF67ID1 0\n#define MW_FDCAN2_SF67ID2 0\n#define MW_FDCAN2_SF68C 0\n#define MW_FDCAN2_SF68TYPE 2\n#define MW_FDCAN2_SF68ID1 0\n#define MW_FDCAN2_SF68ID2 0\n#define MW_FDCAN2_SF69C 0\n#define MW_FDCAN2_SF69TYPE 2\n#define MW_FDCAN2_SF69ID1 0\n#define MW_FDCAN2_SF69ID2 0\n#define MW_FDCAN2_SF70C 0\n#define MW_FDCAN2_SF70TYPE 2\n#define MW_FDCAN2_SF70ID1 0\n#define MW_FDCAN2_SF70ID2 0\n#define MW_FDCAN2_SF71C 0\n#define MW_FDCAN2_SF71TYPE 2\n#define MW_FDCAN2_SF71ID1 0\n#define MW_FDCAN2_SF71ID2 0\n#define MW_FDCAN2_SF72C 0\n#define MW_FDCAN2_SF72TYPE 2\n#define MW_FDCAN2_SF72ID1 0\n#define MW_FDCAN2_SF72ID2 0\n#define MW_FDCAN2_SF73C 0\n#define MW_FDCAN2_SF73TYPE 2\n#define MW_FDCAN2_SF73ID1 0\n#define MW_FDCAN2_SF73ID2 0\n#define MW_FDCAN2_SF74C 0\n#define MW_FDCAN2_SF74TYPE 2\n#define MW_FDCAN2_SF74ID1 0\n#define MW_FDCAN2_SF74ID2 0\n#define MW_FDCAN2_SF75C 0\n#define MW_FDCAN2_SF75TYPE 2\n#define MW_FDCAN2_SF75ID1 0\n#define MW_FDCAN2_SF75ID2 0\n#define MW_FDCAN2_SF76C 0\n#define MW_FDCAN2_SF76TYPE 2\n#define MW_FDCAN2_SF76ID1 0\n#define MW_FDCAN2_SF76ID2 0\n#define MW_FDCAN2_SF77C 0\n#define MW_FDCAN2_SF77TYPE 2\n#define MW_FDCAN2_SF77ID1 0\n#define MW_FDCAN2_SF77ID2 0\n#define MW_FDCAN2_SF78C 0\n#define MW_FDCAN2_SF78TYPE 2\n#define MW_FDCAN2_SF78ID1 0\n#define MW_FDCAN2_SF78ID2 0\n#define MW_FDCAN2_SF79C 0\n#define MW_FDCAN2_SF79TYPE 2\n#define MW_FDCAN2_SF79ID1 0\n#define MW_FDCAN2_SF79ID2 0\n#define MW_FDCAN2_SF80C 0\n#define MW_FDCAN2_SF80TYPE 2\n#define MW_FDCAN2_SF80ID1 0\n#define MW_FDCAN2_SF80ID2 0\n#define MW_FDCAN2_SF81C 0\n#define MW_FDCAN2_SF81TYPE 2\n#define MW_FDCAN2_SF81ID1 0\n#define MW_FDCAN2_SF81ID2 0\n#define MW_FDCAN2_SF82C 0\n#define MW_FDCAN2_SF82TYPE 2\n#define MW_FDCAN2_SF82ID1 0\n#define MW_FDCAN2_SF82ID2 0\n#define MW_FDCAN2_SF83C 0\n#define MW_FDCAN2_SF83TYPE 2\n#define MW_FDCAN2_SF83ID1 0\n#define MW_FDCAN2_SF83ID2 0\n#define MW_FDCAN2_SF84C 0\n#define MW_FDCAN2_SF84TYPE 2\n#define MW_FDCAN2_SF84ID1 0\n#define MW_FDCAN2_SF84ID2 0\n#define MW_FDCAN2_SF85C 0\n#define MW_FDCAN2_SF85TYPE 2\n#define MW_FDCAN2_SF85ID1 0\n#define MW_FDCAN2_SF85ID2 0\n#define MW_FDCAN2_SF86C 0\n#define MW_FDCAN2_SF86TYPE 2\n#define MW_FDCAN2_SF86ID1 0\n#define MW_FDCAN2_SF86ID2 0\n#define MW_FDCAN2_SF87C 0\n#define MW_FDCAN2_SF87TYPE 2\n#define MW_FDCAN2_SF87ID1 0\n#define MW_FDCAN2_SF87ID2 0\n#define MW_FDCAN2_SF88C 0\n#define MW_FDCAN2_SF88TYPE 2\n#define MW_FDCAN2_SF88ID1 0\n#define MW_FDCAN2_SF88ID2 0\n#define MW_FDCAN2_SF89C 0\n#define MW_FDCAN2_SF89TYPE 2\n#define MW_FDCAN2_SF89ID1 0\n#define MW_FDCAN2_SF89ID2 0\n#define MW_FDCAN2_SF90C 0\n#define MW_FDCAN2_SF90TYPE 2\n#define MW_FDCAN2_SF90ID1 0\n#define MW_FDCAN2_SF90ID2 0\n#define MW_FDCAN2_SF91C 0\n#define MW_FDCAN2_SF91TYPE 2\n#define MW_FDCAN2_SF91ID1 0\n#define MW_FDCAN2_SF91ID2 0\n#define MW_FDCAN2_SF92C 0\n#define MW_FDCAN2_SF92TYPE 2\n#define MW_FDCAN2_SF92ID1 0\n#define MW_FDCAN2_SF92ID2 0\n#define MW_FDCAN2_SF93C 0\n#define MW_FDCAN2_SF93TYPE 2\n#define MW_FDCAN2_SF93ID1 0\n#define MW_FDCAN2_SF93ID2 0\n#define MW_FDCAN2_SF94C 0\n#define MW_FDCAN2_SF94TYPE 2\n#define MW_FDCAN2_SF94ID1 0\n#define MW_FDCAN2_SF94ID2 0\n#define MW_FDCAN2_SF95C 0\n#define MW_FDCAN2_SF95TYPE 2\n#define MW_FDCAN2_SF95ID1 0\n#define MW_FDCAN2_SF95ID2 0\n#define MW_FDCAN2_SF96C 0\n#define MW_FDCAN2_SF96TYPE 2\n#define MW_FDCAN2_SF96ID1 0\n#define MW_FDCAN2_SF96ID2 0\n#define MW_FDCAN2_SF97C 0\n#define MW_FDCAN2_SF97TYPE 2\n#define MW_FDCAN2_SF97ID1 0\n#define MW_FDCAN2_SF97ID2 0\n#define MW_FDCAN2_SF98C 0\n#define MW_FDCAN2_SF98TYPE 2\n#define MW_FDCAN2_SF98ID1 0\n#define MW_FDCAN2_SF98ID2 0\n#define MW_FDCAN2_SF99C 0\n#define MW_FDCAN2_SF99TYPE 2\n#define MW_FDCAN2_SF99ID1 0\n#define MW_FDCAN2_SF99ID2 0\n#define MW_FDCAN2_SF100C 0\n#define MW_FDCAN2_SF100TYPE 2\n#define MW_FDCAN2_SF100ID1 0\n#define MW_FDCAN2_SF100ID2 0\n#define MW_FDCAN2_SF101C 0\n#define MW_FDCAN2_SF101TYPE 2\n#define MW_FDCAN2_SF101ID1 0\n#define MW_FDCAN2_SF101ID2 0\n#define MW_FDCAN2_SF102C 0\n#define MW_FDCAN2_SF102TYPE 2\n#define MW_FDCAN2_SF102ID1 0\n#define MW_FDCAN2_SF102ID2 0\n#define MW_FDCAN2_SF103C 0\n#define MW_FDCAN2_SF103TYPE 2\n#define MW_FDCAN2_SF103ID1 0\n#define MW_FDCAN2_SF103ID2 0\n#define MW_FDCAN2_SF104C 0\n#define MW_FDCAN2_SF104TYPE 2\n#define MW_FDCAN2_SF104ID1 0\n#define MW_FDCAN2_SF104ID2 0\n#define MW_FDCAN2_SF105C 0\n#define MW_FDCAN2_SF105TYPE 2\n#define MW_FDCAN2_SF105ID1 0\n#define MW_FDCAN2_SF105ID2 0\n#define MW_FDCAN2_SF106C 0\n#define MW_FDCAN2_SF106TYPE 2\n#define MW_FDCAN2_SF106ID1 0\n#define MW_FDCAN2_SF106ID2 0\n#define MW_FDCAN2_SF107C 0\n#define MW_FDCAN2_SF107TYPE 2\n#define MW_FDCAN2_SF107ID1 0\n#define MW_FDCAN2_SF107ID2 0\n#define MW_FDCAN2_SF108C 0\n#define MW_FDCAN2_SF108TYPE 2\n#define MW_FDCAN2_SF108ID1 0\n#define MW_FDCAN2_SF108ID2 0\n#define MW_FDCAN2_SF109C 0\n#define MW_FDCAN2_SF109TYPE 2\n#define MW_FDCAN2_SF109ID1 0\n#define MW_FDCAN2_SF109ID2 0\n#define MW_FDCAN2_SF110C 0\n#define MW_FDCAN2_SF110TYPE 2\n#define MW_FDCAN2_SF110ID1 0\n#define MW_FDCAN2_SF110ID2 0\n#define MW_FDCAN2_SF111C 0\n#define MW_FDCAN2_SF111TYPE 2\n#define MW_FDCAN2_SF111ID1 0\n#define MW_FDCAN2_SF111ID2 0\n#define MW_FDCAN2_SF112C 0\n#define MW_FDCAN2_SF112TYPE 2\n#define MW_FDCAN2_SF112ID1 0\n#define MW_FDCAN2_SF112ID2 0\n#define MW_FDCAN2_SF113C 0\n#define MW_FDCAN2_SF113TYPE 2\n#define MW_FDCAN2_SF113ID1 0\n#define MW_FDCAN2_SF113ID2 0\n#define MW_FDCAN2_SF114C 0\n#define MW_FDCAN2_SF114TYPE 2\n#define MW_FDCAN2_SF114ID1 0\n#define MW_FDCAN2_SF114ID2 0\n#define MW_FDCAN2_SF115C 0\n#define MW_FDCAN2_SF115TYPE 2\n#define MW_FDCAN2_SF115ID1 0\n#define MW_FDCAN2_SF115ID2 0\n#define MW_FDCAN2_SF116C 0\n#define MW_FDCAN2_SF116TYPE 2\n#define MW_FDCAN2_SF116ID1 0\n#define MW_FDCAN2_SF116ID2 0\n#define MW_FDCAN2_SF117C 0\n#define MW_FDCAN2_SF117TYPE 2\n#define MW_FDCAN2_SF117ID1 0\n#define MW_FDCAN2_SF117ID2 0\n#define MW_FDCAN2_SF118C 0\n#define MW_FDCAN2_SF118TYPE 2\n#define MW_FDCAN2_SF118ID1 0\n#define MW_FDCAN2_SF118ID2 0\n#define MW_FDCAN2_SF119C 0\n#define MW_FDCAN2_SF119TYPE 2\n#define MW_FDCAN2_SF119ID1 0\n#define MW_FDCAN2_SF119ID2 0\n#define MW_FDCAN2_SF120C 0\n#define MW_FDCAN2_SF120TYPE 2\n#define MW_FDCAN2_SF120ID1 0\n#define MW_FDCAN2_SF120ID2 0\n#define MW_FDCAN2_SF121C 0\n#define MW_FDCAN2_SF121TYPE 2\n#define MW_FDCAN2_SF121ID1 0\n#define MW_FDCAN2_SF121ID2 0\n#define MW_FDCAN2_SF122C 0\n#define MW_FDCAN2_SF122TYPE 2\n#define MW_FDCAN2_SF122ID1 0\n#define MW_FDCAN2_SF122ID2 0\n#define MW_FDCAN2_SF123C 0\n#define MW_FDCAN2_SF123TYPE 2\n#define MW_FDCAN2_SF123ID1 0\n#define MW_FDCAN2_SF123ID2 0\n#define MW_FDCAN2_SF124C 0\n#define MW_FDCAN2_SF124TYPE 2\n#define MW_FDCAN2_SF124ID1 0\n#define MW_FDCAN2_SF124ID2 0\n#define MW_FDCAN2_SF125C 0\n#define MW_FDCAN2_SF125TYPE 2\n#define MW_FDCAN2_SF125ID1 0\n#define MW_FDCAN2_SF125ID2 0\n#define MW_FDCAN2_SF126C 0\n#define MW_FDCAN2_SF126TYPE 2\n#define MW_FDCAN2_SF126ID1 0\n#define MW_FDCAN2_SF126ID2 0\n#define MW_FDCAN2_SF127C 0\n#define MW_FDCAN2_SF127TYPE 2\n#define MW_FDCAN2_SF127ID1 0\n#define MW_FDCAN2_SF127ID2 0\n#define MW_FDCAN2_EF 0\n#define MW_FDCAN2_EFNUMBER 0\n#define MW_FDCAN2_EF0C 0\n#define MW_FDCAN2_EF0TYPE 2\n#define MW_FDCAN2_EF0ID1 0\n#define MW_FDCAN2_EF0ID2 0\n#define MW_FDCAN2_EF1C 0\n#define MW_FDCAN2_EF1TYPE 2\n#define MW_FDCAN2_EF1ID1 0\n#define MW_FDCAN2_EF1ID2 0\n#define MW_FDCAN2_EF2C 0\n#define MW_FDCAN2_EF2TYPE 2\n#define MW_FDCAN2_EF2ID1 0\n#define MW_FDCAN2_EF2ID2 0\n#define MW_FDCAN2_EF3C 0\n#define MW_FDCAN2_EF3TYPE 2\n#define MW_FDCAN2_EF3ID1 0\n#define MW_FDCAN2_EF3ID2 0\n#define MW_FDCAN2_EF4C 0\n#define MW_FDCAN2_EF4TYPE 2\n#define MW_FDCAN2_EF4ID1 0\n#define MW_FDCAN2_EF4ID2 0\n#define MW_FDCAN2_EF5C 0\n#define MW_FDCAN2_EF5TYPE 2\n#define MW_FDCAN2_EF5ID1 0\n#define MW_FDCAN2_EF5ID2 0\n#define MW_FDCAN2_EF6C 0\n#define MW_FDCAN2_EF6TYPE 2\n#define MW_FDCAN2_EF6ID1 0\n#define MW_FDCAN2_EF6ID2 0\n#define MW_FDCAN2_EF7C 0\n#define MW_FDCAN2_EF7TYPE 2\n#define MW_FDCAN2_EF7ID1 0\n#define MW_FDCAN2_EF7ID2 0\n#define MW_FDCAN2_EF8C 0\n#define MW_FDCAN2_EF8TYPE 2\n#define MW_FDCAN2_EF8ID1 0\n#define MW_FDCAN2_EF8ID2 0\n#define MW_FDCAN2_EF9C 0\n#define MW_FDCAN2_EF9TYPE 2\n#define MW_FDCAN2_EF9ID1 0\n#define MW_FDCAN2_EF9ID2 0\n#define MW_FDCAN2_EF10C 0\n#define MW_FDCAN2_EF10TYPE 2\n#define MW_FDCAN2_EF10ID1 0\n#define MW_FDCAN2_EF10ID2 0\n#define MW_FDCAN2_EF11C 0\n#define MW_FDCAN2_EF11TYPE 2\n#define MW_FDCAN2_EF11ID1 0\n#define MW_FDCAN2_EF11ID2 0\n#define MW_FDCAN2_EF12C 0\n#define MW_FDCAN2_EF12TYPE 2\n#define MW_FDCAN2_EF12ID1 0\n#define MW_FDCAN2_EF12ID2 0\n#define MW_FDCAN2_EF13C 0\n#define MW_FDCAN2_EF13TYPE 2\n#define MW_FDCAN2_EF13ID1 0\n#define MW_FDCAN2_EF13ID2 0\n#define MW_FDCAN2_EF14C 0\n#define MW_FDCAN2_EF14TYPE 2\n#define MW_FDCAN2_EF14ID1 0\n#define MW_FDCAN2_EF14ID2 0\n#define MW_FDCAN2_EF15C 0\n#define MW_FDCAN2_EF15TYPE 2\n#define MW_FDCAN2_EF15ID1 0\n#define MW_FDCAN2_EF15ID2 0\n#define MW_FDCAN2_EF16C 0\n#define MW_FDCAN2_EF16TYPE 2\n#define MW_FDCAN2_EF16ID1 0\n#define MW_FDCAN2_EF16ID2 0\n#define MW_FDCAN2_EF17C 0\n#define MW_FDCAN2_EF17TYPE 2\n#define MW_FDCAN2_EF17ID1 0\n#define MW_FDCAN2_EF17ID2 0\n#define MW_FDCAN2_EF18C 0\n#define MW_FDCAN2_EF18TYPE 2\n#define MW_FDCAN2_EF18ID1 0\n#define MW_FDCAN2_EF18ID2 0\n#define MW_FDCAN2_EF19C 0\n#define MW_FDCAN2_EF19TYPE 2\n#define MW_FDCAN2_EF19ID1 0\n#define MW_FDCAN2_EF19ID2 0\n#define MW_FDCAN2_EF20C 0\n#define MW_FDCAN2_EF20TYPE 2\n#define MW_FDCAN2_EF20ID1 0\n#define MW_FDCAN2_EF20ID2 0\n#define MW_FDCAN2_EF21C 0\n#define MW_FDCAN2_EF21TYPE 2\n#define MW_FDCAN2_EF21ID1 0\n#define MW_FDCAN2_EF21ID2 0\n#define MW_FDCAN2_EF22C 0\n#define MW_FDCAN2_EF22TYPE 2\n#define MW_FDCAN2_EF22ID1 0\n#define MW_FDCAN2_EF22ID2 0\n#define MW_FDCAN2_EF23C 0\n#define MW_FDCAN2_EF23TYPE 2\n#define MW_FDCAN2_EF23ID1 0\n#define MW_FDCAN2_EF23ID2 0\n#define MW_FDCAN2_EF24C 0\n#define MW_FDCAN2_EF24TYPE 2\n#define MW_FDCAN2_EF24ID1 0\n#define MW_FDCAN2_EF24ID2 0\n#define MW_FDCAN2_EF25C 0\n#define MW_FDCAN2_EF25TYPE 2\n#define MW_FDCAN2_EF25ID1 0\n#define MW_FDCAN2_EF25ID2 0\n#define MW_FDCAN2_EF26C 0\n#define MW_FDCAN2_EF26TYPE 2\n#define MW_FDCAN2_EF26ID1 0\n#define MW_FDCAN2_EF26ID2 0\n#define MW_FDCAN2_EF27C 0\n#define MW_FDCAN2_EF27TYPE 2\n#define MW_FDCAN2_EF27ID1 0\n#define MW_FDCAN2_EF27ID2 0\n#define MW_FDCAN2_EF28C 0\n#define MW_FDCAN2_EF28TYPE 2\n#define MW_FDCAN2_EF28ID1 0\n#define MW_FDCAN2_EF28ID2 0\n#define MW_FDCAN2_EF29C 0\n#define MW_FDCAN2_EF29TYPE 2\n#define MW_FDCAN2_EF29ID1 0\n#define MW_FDCAN2_EF29ID2 0\n#define MW_FDCAN2_EF30C 0\n#define MW_FDCAN2_EF30TYPE 2\n#define MW_FDCAN2_EF30ID1 0\n#define MW_FDCAN2_EF30ID2 0\n#define MW_FDCAN2_EF31C 0\n#define MW_FDCAN2_EF31TYPE 2\n#define MW_FDCAN2_EF31ID1 0\n#define MW_FDCAN2_EF31ID2 0\n#define MW_FDCAN2_EF32C 0\n#define MW_FDCAN2_EF32TYPE 2\n#define MW_FDCAN2_EF32ID1 0\n#define MW_FDCAN2_EF32ID2 0\n#define MW_FDCAN2_EF33C 0\n#define MW_FDCAN2_EF33TYPE 2\n#define MW_FDCAN2_EF33ID1 0\n#define MW_FDCAN2_EF33ID2 0\n#define MW_FDCAN2_EF34C 0\n#define MW_FDCAN2_EF34TYPE 2\n#define MW_FDCAN2_EF34ID1 0\n#define MW_FDCAN2_EF34ID2 0\n#define MW_FDCAN2_EF35C 0\n#define MW_FDCAN2_EF35TYPE 2\n#define MW_FDCAN2_EF35ID1 0\n#define MW_FDCAN2_EF35ID2 0\n#define MW_FDCAN2_EF36C 0\n#define MW_FDCAN2_EF36TYPE 2\n#define MW_FDCAN2_EF36ID1 0\n#define MW_FDCAN2_EF36ID2 0\n#define MW_FDCAN2_EF37C 0\n#define MW_FDCAN2_EF37TYPE 2\n#define MW_FDCAN2_EF37ID1 0\n#define MW_FDCAN2_EF37ID2 0\n#define MW_FDCAN2_EF38C 0\n#define MW_FDCAN2_EF38TYPE 2\n#define MW_FDCAN2_EF38ID1 0\n#define MW_FDCAN2_EF38ID2 0\n#define MW_FDCAN2_EF39C 0\n#define MW_FDCAN2_EF39TYPE 2\n#define MW_FDCAN2_EF39ID1 0\n#define MW_FDCAN2_EF39ID2 0\n#define MW_FDCAN2_EF40C 0\n#define MW_FDCAN2_EF40TYPE 2\n#define MW_FDCAN2_EF40ID1 0\n#define MW_FDCAN2_EF40ID2 0\n#define MW_FDCAN2_EF41C 0\n#define MW_FDCAN2_EF41TYPE 2\n#define MW_FDCAN2_EF41ID1 0\n#define MW_FDCAN2_EF41ID2 0\n#define MW_FDCAN2_EF42C 0\n#define MW_FDCAN2_EF42TYPE 2\n#define MW_FDCAN2_EF42ID1 0\n#define MW_FDCAN2_EF42ID2 0\n#define MW_FDCAN2_EF43C 0\n#define MW_FDCAN2_EF43TYPE 2\n#define MW_FDCAN2_EF43ID1 0\n#define MW_FDCAN2_EF43ID2 0\n#define MW_FDCAN2_EF44C 0\n#define MW_FDCAN2_EF44TYPE 2\n#define MW_FDCAN2_EF44ID1 0\n#define MW_FDCAN2_EF44ID2 0\n#define MW_FDCAN2_EF45C 0\n#define MW_FDCAN2_EF45TYPE 2\n#define MW_FDCAN2_EF45ID1 0\n#define MW_FDCAN2_EF45ID2 0\n#define MW_FDCAN2_EF46C 0\n#define MW_FDCAN2_EF46TYPE 2\n#define MW_FDCAN2_EF46ID1 0\n#define MW_FDCAN2_EF46ID2 0\n#define MW_FDCAN2_EF47C 0\n#define MW_FDCAN2_EF47TYPE 2\n#define MW_FDCAN2_EF47ID1 0\n#define MW_FDCAN2_EF47ID2 0\n#define MW_FDCAN2_EF48C 0\n#define MW_FDCAN2_EF48TYPE 2\n#define MW_FDCAN2_EF48ID1 0\n#define MW_FDCAN2_EF48ID2 0\n#define MW_FDCAN2_EF49C 0\n#define MW_FDCAN2_EF49TYPE 2\n#define MW_FDCAN2_EF49ID1 0\n#define MW_FDCAN2_EF49ID2 0\n#define MW_FDCAN2_EF50C 0\n#define MW_FDCAN2_EF50TYPE 2\n#define MW_FDCAN2_EF50ID1 0\n#define MW_FDCAN2_EF50ID2 0\n#define MW_FDCAN2_EF51C 0\n#define MW_FDCAN2_EF51TYPE 2\n#define MW_FDCAN2_EF51ID1 0\n#define MW_FDCAN2_EF51ID2 0\n#define MW_FDCAN2_EF52C 0\n#define MW_FDCAN2_EF52TYPE 2\n#define MW_FDCAN2_EF52ID1 0\n#define MW_FDCAN2_EF52ID2 0\n#define MW_FDCAN2_EF53C 0\n#define MW_FDCAN2_EF53TYPE 2\n#define MW_FDCAN2_EF53ID1 0\n#define MW_FDCAN2_EF53ID2 0\n#define MW_FDCAN2_EF54C 0\n#define MW_FDCAN2_EF54TYPE 2\n#define MW_FDCAN2_EF54ID1 0\n#define MW_FDCAN2_EF54ID2 0\n#define MW_FDCAN2_EF55C 0\n#define MW_FDCAN2_EF55TYPE 2\n#define MW_FDCAN2_EF55ID1 0\n#define MW_FDCAN2_EF55ID2 0\n#define MW_FDCAN2_EF56C 0\n#define MW_FDCAN2_EF56TYPE 2\n#define MW_FDCAN2_EF56ID1 0\n#define MW_FDCAN2_EF56ID2 0\n#define MW_FDCAN2_EF57C 0\n#define MW_FDCAN2_EF57TYPE 2\n#define MW_FDCAN2_EF57ID1 0\n#define MW_FDCAN2_EF57ID2 0\n#define MW_FDCAN2_EF58C 0\n#define MW_FDCAN2_EF58TYPE 2\n#define MW_FDCAN2_EF58ID1 0\n#define MW_FDCAN2_EF58ID2 0\n#define MW_FDCAN2_EF59C 0\n#define MW_FDCAN2_EF59TYPE 2\n#define MW_FDCAN2_EF59ID1 0\n#define MW_FDCAN2_EF59ID2 0\n#define MW_FDCAN2_EF60C 0\n#define MW_FDCAN2_EF60TYPE 2\n#define MW_FDCAN2_EF60ID1 0\n#define MW_FDCAN2_EF60ID2 0\n#define MW_FDCAN2_EF61C 0\n#define MW_FDCAN2_EF61TYPE 2\n#define MW_FDCAN2_EF61ID1 0\n#define MW_FDCAN2_EF61ID2 0\n#define MW_FDCAN2_EF62C 0\n#define MW_FDCAN2_EF62TYPE 2\n#define MW_FDCAN2_EF62ID1 0\n#define MW_FDCAN2_EF62ID2 0\n#define MW_FDCAN2_EF63C 0\n#define MW_FDCAN2_EF63TYPE 2\n#define MW_FDCAN2_EF63ID1 0\n#define MW_FDCAN2_EF63ID2 0\n#define MW_FDCAN3_NOMINALBAUDRATE 1000000\n#define MW_FDCAN3_DATABAUDRATE 1000000\n#define MW_FDCAN3_ENABLEEDGEFILTER 0\n#define MW_FDCAN3_RXF0BLOCK 0\n#define MW_FDCAN3_RXF1BLOCK 0\n#define MW_FDCAN3_INTENRX 0\n#define MW_FDCAN3_INTENRXB 0\n#define MW_FDCAN3_INTRXBFNM 0\n#define MW_FDCAN3_INTENRXF0 0\n#define MW_FDCAN3_INTRXF0NM 0\n#define MW_FDCAN3_INTRXF0FL 0\n#define MW_FDCAN3_INTRXF0ML 0\n#define MW_FDCAN3_INTRXF0WM 0\n#define MW_FDCAN3_RXF0WMLVL 0\n#define MW_FDCAN3_INTENRXF1 0\n#define MW_FDCAN3_INTRXF1NM 0\n#define MW_FDCAN3_INTRXF1FL 0\n#define MW_FDCAN3_INTRXF1ML 0\n#define MW_FDCAN3_INTRXF1WM 0\n#define MW_FDCAN3_RXF1WMLVL 0\n#define MW_FDCAN3_INTHIPRIM 0\n#define MW_FDCAN3_INTENTX 0\n#define MW_FDCAN3_INTENTXF 0\n#define MW_FDCAN3_INTTXCOMP 0\n#define MW_FDCAN3_INTTXCNCL 0\n#define MW_FDCAN3_INTTXFEMP 0\n#define MW_FDCAN3_INTENTXEVF 0\n#define MW_FDCAN3_INTTXEVNE 0\n#define MW_FDCAN3_INTTXEVML 0\n#define MW_FDCAN3_INTTXEVFL 0\n#define MW_FDCAN3_INTTXEVWM 0\n#define MW_FDCAN3_TXEVFWMLVL 32\n#define MW_FDCAN3_INTENOTH 0\n#define MW_FDCAN3_INTTSWRAP 0\n#define MW_FDCAN3_INTMSRMAF 0\n#define MW_FDCAN3_INTTIMOUT 0\n#define MW_FDCAN3_INTERLGOV 0\n#define MW_FDCAN3_INTERRPSV 0\n#define MW_FDCAN3_INTWRNSTS 0\n#define MW_FDCAN3_INTBOFSTS 0\n#define MW_FDCAN3_INTWACHDG 0\n#define MW_FDCAN3_INTERRARB 0\n#define MW_FDCAN3_INTERRDTA 0\n#define MW_FDCAN3_INTRSVADD 0\n#define MW_FDCAN3_GFC 0\n#define MW_FDCAN3_RRFS 1\n#define MW_FDCAN3_RRFE 1\n#define MW_FDCAN3_NMFS 2\n#define MW_FDCAN3_NMFE 2\n#define MW_FDCAN3_SF 0\n#define MW_FDCAN3_SFNUMBER 0\n#define MW_FDCAN3_SF0C 0\n#define MW_FDCAN3_SF0TYPE 2\n#define MW_FDCAN3_SF0ID1 0\n#define MW_FDCAN3_SF0ID2 0\n#define MW_FDCAN3_SF1C 0\n#define MW_FDCAN3_SF1TYPE 2\n#define MW_FDCAN3_SF1ID1 0\n#define MW_FDCAN3_SF1ID2 0\n#define MW_FDCAN3_SF2C 0\n#define MW_FDCAN3_SF2TYPE 2\n#define MW_FDCAN3_SF2ID1 0\n#define MW_FDCAN3_SF2ID2 0\n#define MW_FDCAN3_SF3C 0\n#define MW_FDCAN3_SF3TYPE 2\n#define MW_FDCAN3_SF3ID1 0\n#define MW_FDCAN3_SF3ID2 0\n#define MW_FDCAN3_SF4C 0\n#define MW_FDCAN3_SF4TYPE 2\n#define MW_FDCAN3_SF4ID1 0\n#define MW_FDCAN3_SF4ID2 0\n#define MW_FDCAN3_SF5C 0\n#define MW_FDCAN3_SF5TYPE 2\n#define MW_FDCAN3_SF5ID1 0\n#define MW_FDCAN3_SF5ID2 0\n#define MW_FDCAN3_SF6C 0\n#define MW_FDCAN3_SF6TYPE 2\n#define MW_FDCAN3_SF6ID1 0\n#define MW_FDCAN3_SF6ID2 0\n#define MW_FDCAN3_SF7C 0\n#define MW_FDCAN3_SF7TYPE 2\n#define MW_FDCAN3_SF7ID1 0\n#define MW_FDCAN3_SF7ID2 0\n#define MW_FDCAN3_SF8C 0\n#define MW_FDCAN3_SF8TYPE 2\n#define MW_FDCAN3_SF8ID1 0\n#define MW_FDCAN3_SF8ID2 0\n#define MW_FDCAN3_SF9C 0\n#define MW_FDCAN3_SF9TYPE 2\n#define MW_FDCAN3_SF9ID1 0\n#define MW_FDCAN3_SF9ID2 0\n#define MW_FDCAN3_SF10C 0\n#define MW_FDCAN3_SF10TYPE 2\n#define MW_FDCAN3_SF10ID1 0\n#define MW_FDCAN3_SF10ID2 0\n#define MW_FDCAN3_SF11C 0\n#define MW_FDCAN3_SF11TYPE 2\n#define MW_FDCAN3_SF11ID1 0\n#define MW_FDCAN3_SF11ID2 0\n#define MW_FDCAN3_SF12C 0\n#define MW_FDCAN3_SF12TYPE 2\n#define MW_FDCAN3_SF12ID1 0\n#define MW_FDCAN3_SF12ID2 0\n#define MW_FDCAN3_SF13C 0\n#define MW_FDCAN3_SF13TYPE 2\n#define MW_FDCAN3_SF13ID1 0\n#define MW_FDCAN3_SF13ID2 0\n#define MW_FDCAN3_SF14C 0\n#define MW_FDCAN3_SF14TYPE 2\n#define MW_FDCAN3_SF14ID1 0\n#define MW_FDCAN3_SF14ID2 0\n#define MW_FDCAN3_SF15C 0\n#define MW_FDCAN3_SF15TYPE 2\n#define MW_FDCAN3_SF15ID1 0\n#define MW_FDCAN3_SF15ID2 0\n#define MW_FDCAN3_SF16C 0\n#define MW_FDCAN3_SF16TYPE 2\n#define MW_FDCAN3_SF16ID1 0\n#define MW_FDCAN3_SF16ID2 0\n#define MW_FDCAN3_SF17C 0\n#define MW_FDCAN3_SF17TYPE 2\n#define MW_FDCAN3_SF17ID1 0\n#define MW_FDCAN3_SF17ID2 0\n#define MW_FDCAN3_SF18C 0\n#define MW_FDCAN3_SF18TYPE 2\n#define MW_FDCAN3_SF18ID1 0\n#define MW_FDCAN3_SF18ID2 0\n#define MW_FDCAN3_SF19C 0\n#define MW_FDCAN3_SF19TYPE 2\n#define MW_FDCAN3_SF19ID1 0\n#define MW_FDCAN3_SF19ID2 0\n#define MW_FDCAN3_SF20C 0\n#define MW_FDCAN3_SF20TYPE 2\n#define MW_FDCAN3_SF20ID1 0\n#define MW_FDCAN3_SF20ID2 0\n#define MW_FDCAN3_SF21C 0\n#define MW_FDCAN3_SF21TYPE 2\n#define MW_FDCAN3_SF21ID1 0\n#define MW_FDCAN3_SF21ID2 0\n#define MW_FDCAN3_SF22C 0\n#define MW_FDCAN3_SF22TYPE 2\n#define MW_FDCAN3_SF22ID1 0\n#define MW_FDCAN3_SF22ID2 0\n#define MW_FDCAN3_SF23C 0\n#define MW_FDCAN3_SF23TYPE 2\n#define MW_FDCAN3_SF23ID1 0\n#define MW_FDCAN3_SF23ID2 0\n#define MW_FDCAN3_SF24C 0\n#define MW_FDCAN3_SF24TYPE 2\n#define MW_FDCAN3_SF24ID1 0\n#define MW_FDCAN3_SF24ID2 0\n#define MW_FDCAN3_SF25C 0\n#define MW_FDCAN3_SF25TYPE 2\n#define MW_FDCAN3_SF25ID1 0\n#define MW_FDCAN3_SF25ID2 0\n#define MW_FDCAN3_SF26C 0\n#define MW_FDCAN3_SF26TYPE 2\n#define MW_FDCAN3_SF26ID1 0\n#define MW_FDCAN3_SF26ID2 0\n#define MW_FDCAN3_SF27C 0\n#define MW_FDCAN3_SF27TYPE 2\n#define MW_FDCAN3_SF27ID1 0\n#define MW_FDCAN3_SF27ID2 0\n#define MW_FDCAN3_SF28C 0\n#define MW_FDCAN3_SF28TYPE 2\n#define MW_FDCAN3_SF28ID1 0\n#define MW_FDCAN3_SF28ID2 0\n#define MW_FDCAN3_SF29C 0\n#define MW_FDCAN3_SF29TYPE 2\n#define MW_FDCAN3_SF29ID1 0\n#define MW_FDCAN3_SF29ID2 0\n#define MW_FDCAN3_SF30C 0\n#define MW_FDCAN3_SF30TYPE 2\n#define MW_FDCAN3_SF30ID1 0\n#define MW_FDCAN3_SF30ID2 0\n#define MW_FDCAN3_SF31C 0\n#define MW_FDCAN3_SF31TYPE 2\n#define MW_FDCAN3_SF31ID1 0\n#define MW_FDCAN3_SF31ID2 0\n#define MW_FDCAN3_SF32C 0\n#define MW_FDCAN3_SF32TYPE 2\n#define MW_FDCAN3_SF32ID1 0\n#define MW_FDCAN3_SF32ID2 0\n#define MW_FDCAN3_SF33C 0\n#define MW_FDCAN3_SF33TYPE 2\n#define MW_FDCAN3_SF33ID1 0\n#define MW_FDCAN3_SF33ID2 0\n#define MW_FDCAN3_SF34C 0\n#define MW_FDCAN3_SF34TYPE 2\n#define MW_FDCAN3_SF34ID1 0\n#define MW_FDCAN3_SF34ID2 0\n#define MW_FDCAN3_SF35C 0\n#define MW_FDCAN3_SF35TYPE 2\n#define MW_FDCAN3_SF35ID1 0\n#define MW_FDCAN3_SF35ID2 0\n#define MW_FDCAN3_SF36C 0\n#define MW_FDCAN3_SF36TYPE 2\n#define MW_FDCAN3_SF36ID1 0\n#define MW_FDCAN3_SF36ID2 0\n#define MW_FDCAN3_SF37C 0\n#define MW_FDCAN3_SF37TYPE 2\n#define MW_FDCAN3_SF37ID1 0\n#define MW_FDCAN3_SF37ID2 0\n#define MW_FDCAN3_SF38C 0\n#define MW_FDCAN3_SF38TYPE 2\n#define MW_FDCAN3_SF38ID1 0\n#define MW_FDCAN3_SF38ID2 0\n#define MW_FDCAN3_SF39C 0\n#define MW_FDCAN3_SF39TYPE 2\n#define MW_FDCAN3_SF39ID1 0\n#define MW_FDCAN3_SF39ID2 0\n#define MW_FDCAN3_SF40C 0\n#define MW_FDCAN3_SF40TYPE 2\n#define MW_FDCAN3_SF40ID1 0\n#define MW_FDCAN3_SF40ID2 0\n#define MW_FDCAN3_SF41C 0\n#define MW_FDCAN3_SF41TYPE 2\n#define MW_FDCAN3_SF41ID1 0\n#define MW_FDCAN3_SF41ID2 0\n#define MW_FDCAN3_SF42C 0\n#define MW_FDCAN3_SF42TYPE 2\n#define MW_FDCAN3_SF42ID1 0\n#define MW_FDCAN3_SF42ID2 0\n#define MW_FDCAN3_SF43C 0\n#define MW_FDCAN3_SF43TYPE 2\n#define MW_FDCAN3_SF43ID1 0\n#define MW_FDCAN3_SF43ID2 0\n#define MW_FDCAN3_SF44C 0\n#define MW_FDCAN3_SF44TYPE 2\n#define MW_FDCAN3_SF44ID1 0\n#define MW_FDCAN3_SF44ID2 0\n#define MW_FDCAN3_SF45C 0\n#define MW_FDCAN3_SF45TYPE 2\n#define MW_FDCAN3_SF45ID1 0\n#define MW_FDCAN3_SF45ID2 0\n#define MW_FDCAN3_SF46C 0\n#define MW_FDCAN3_SF46TYPE 2\n#define MW_FDCAN3_SF46ID1 0\n#define MW_FDCAN3_SF46ID2 0\n#define MW_FDCAN3_SF47C 0\n#define MW_FDCAN3_SF47TYPE 2\n#define MW_FDCAN3_SF47ID1 0\n#define MW_FDCAN3_SF47ID2 0\n#define MW_FDCAN3_SF48C 0\n#define MW_FDCAN3_SF48TYPE 2\n#define MW_FDCAN3_SF48ID1 0\n#define MW_FDCAN3_SF48ID2 0\n#define MW_FDCAN3_SF49C 0\n#define MW_FDCAN3_SF49TYPE 2\n#define MW_FDCAN3_SF49ID1 0\n#define MW_FDCAN3_SF49ID2 0\n#define MW_FDCAN3_SF50C 0\n#define MW_FDCAN3_SF50TYPE 2\n#define MW_FDCAN3_SF50ID1 0\n#define MW_FDCAN3_SF50ID2 0\n#define MW_FDCAN3_SF51C 0\n#define MW_FDCAN3_SF51TYPE 2\n#define MW_FDCAN3_SF51ID1 0\n#define MW_FDCAN3_SF51ID2 0\n#define MW_FDCAN3_SF52C 0\n#define MW_FDCAN3_SF52TYPE 2\n#define MW_FDCAN3_SF52ID1 0\n#define MW_FDCAN3_SF52ID2 0\n#define MW_FDCAN3_SF53C 0\n#define MW_FDCAN3_SF53TYPE 2\n#define MW_FDCAN3_SF53ID1 0\n#define MW_FDCAN3_SF53ID2 0\n#define MW_FDCAN3_SF54C 0\n#define MW_FDCAN3_SF54TYPE 2\n#define MW_FDCAN3_SF54ID1 0\n#define MW_FDCAN3_SF54ID2 0\n#define MW_FDCAN3_SF55C 0\n#define MW_FDCAN3_SF55TYPE 2\n#define MW_FDCAN3_SF55ID1 0\n#define MW_FDCAN3_SF55ID2 0\n#define MW_FDCAN3_SF56C 0\n#define MW_FDCAN3_SF56TYPE 2\n#define MW_FDCAN3_SF56ID1 0\n#define MW_FDCAN3_SF56ID2 0\n#define MW_FDCAN3_SF57C 0\n#define MW_FDCAN3_SF57TYPE 2\n#define MW_FDCAN3_SF57ID1 0\n#define MW_FDCAN3_SF57ID2 0\n#define MW_FDCAN3_SF58C 0\n#define MW_FDCAN3_SF58TYPE 2\n#define MW_FDCAN3_SF58ID1 0\n#define MW_FDCAN3_SF58ID2 0\n#define MW_FDCAN3_SF59C 0\n#define MW_FDCAN3_SF59TYPE 2\n#define MW_FDCAN3_SF59ID1 0\n#define MW_FDCAN3_SF59ID2 0\n#define MW_FDCAN3_SF60C 0\n#define MW_FDCAN3_SF60TYPE 2\n#define MW_FDCAN3_SF60ID1 0\n#define MW_FDCAN3_SF60ID2 0\n#define MW_FDCAN3_SF61C 0\n#define MW_FDCAN3_SF61TYPE 2\n#define MW_FDCAN3_SF61ID1 0\n#define MW_FDCAN3_SF61ID2 0\n#define MW_FDCAN3_SF62C 0\n#define MW_FDCAN3_SF62TYPE 2\n#define MW_FDCAN3_SF62ID1 0\n#define MW_FDCAN3_SF62ID2 0\n#define MW_FDCAN3_SF63C 0\n#define MW_FDCAN3_SF63TYPE 2\n#define MW_FDCAN3_SF63ID1 0\n#define MW_FDCAN3_SF63ID2 0\n#define MW_FDCAN3_SF64C 0\n#define MW_FDCAN3_SF64TYPE 2\n#define MW_FDCAN3_SF64ID1 0\n#define MW_FDCAN3_SF64ID2 0\n#define MW_FDCAN3_SF65C 0\n#define MW_FDCAN3_SF65TYPE 2\n#define MW_FDCAN3_SF65ID1 0\n#define MW_FDCAN3_SF65ID2 0\n#define MW_FDCAN3_SF66C 0\n#define MW_FDCAN3_SF66TYPE 2\n#define MW_FDCAN3_SF66ID1 0\n#define MW_FDCAN3_SF66ID2 0\n#define MW_FDCAN3_SF67C 0\n#define MW_FDCAN3_SF67TYPE 2\n#define MW_FDCAN3_SF67ID1 0\n#define MW_FDCAN3_SF67ID2 0\n#define MW_FDCAN3_SF68C 0\n#define MW_FDCAN3_SF68TYPE 2\n#define MW_FDCAN3_SF68ID1 0\n#define MW_FDCAN3_SF68ID2 0\n#define MW_FDCAN3_SF69C 0\n#define MW_FDCAN3_SF69TYPE 2\n#define MW_FDCAN3_SF69ID1 0\n#define MW_FDCAN3_SF69ID2 0\n#define MW_FDCAN3_SF70C 0\n#define MW_FDCAN3_SF70TYPE 2\n#define MW_FDCAN3_SF70ID1 0\n#define MW_FDCAN3_SF70ID2 0\n#define MW_FDCAN3_SF71C 0\n#define MW_FDCAN3_SF71TYPE 2\n#define MW_FDCAN3_SF71ID1 0\n#define MW_FDCAN3_SF71ID2 0\n#define MW_FDCAN3_SF72C 0\n#define MW_FDCAN3_SF72TYPE 2\n#define MW_FDCAN3_SF72ID1 0\n#define MW_FDCAN3_SF72ID2 0\n#define MW_FDCAN3_SF73C 0\n#define MW_FDCAN3_SF73TYPE 2\n#define MW_FDCAN3_SF73ID1 0\n#define MW_FDCAN3_SF73ID2 0\n#define MW_FDCAN3_SF74C 0\n#define MW_FDCAN3_SF74TYPE 2\n#define MW_FDCAN3_SF74ID1 0\n#define MW_FDCAN3_SF74ID2 0\n#define MW_FDCAN3_SF75C 0\n#define MW_FDCAN3_SF75TYPE 2\n#define MW_FDCAN3_SF75ID1 0\n#define MW_FDCAN3_SF75ID2 0\n#define MW_FDCAN3_SF76C 0\n#define MW_FDCAN3_SF76TYPE 2\n#define MW_FDCAN3_SF76ID1 0\n#define MW_FDCAN3_SF76ID2 0\n#define MW_FDCAN3_SF77C 0\n#define MW_FDCAN3_SF77TYPE 2\n#define MW_FDCAN3_SF77ID1 0\n#define MW_FDCAN3_SF77ID2 0\n#define MW_FDCAN3_SF78C 0\n#define MW_FDCAN3_SF78TYPE 2\n#define MW_FDCAN3_SF78ID1 0\n#define MW_FDCAN3_SF78ID2 0\n#define MW_FDCAN3_SF79C 0\n#define MW_FDCAN3_SF79TYPE 2\n#define MW_FDCAN3_SF79ID1 0\n#define MW_FDCAN3_SF79ID2 0\n#define MW_FDCAN3_SF80C 0\n#define MW_FDCAN3_SF80TYPE 2\n#define MW_FDCAN3_SF80ID1 0\n#define MW_FDCAN3_SF80ID2 0\n#define MW_FDCAN3_SF81C 0\n#define MW_FDCAN3_SF81TYPE 2\n#define MW_FDCAN3_SF81ID1 0\n#define MW_FDCAN3_SF81ID2 0\n#define MW_FDCAN3_SF82C 0\n#define MW_FDCAN3_SF82TYPE 2\n#define MW_FDCAN3_SF82ID1 0\n#define MW_FDCAN3_SF82ID2 0\n#define MW_FDCAN3_SF83C 0\n#define MW_FDCAN3_SF83TYPE 2\n#define MW_FDCAN3_SF83ID1 0\n#define MW_FDCAN3_SF83ID2 0\n#define MW_FDCAN3_SF84C 0\n#define MW_FDCAN3_SF84TYPE 2\n#define MW_FDCAN3_SF84ID1 0\n#define MW_FDCAN3_SF84ID2 0\n#define MW_FDCAN3_SF85C 0\n#define MW_FDCAN3_SF85TYPE 2\n#define MW_FDCAN3_SF85ID1 0\n#define MW_FDCAN3_SF85ID2 0\n#define MW_FDCAN3_SF86C 0\n#define MW_FDCAN3_SF86TYPE 2\n#define MW_FDCAN3_SF86ID1 0\n#define MW_FDCAN3_SF86ID2 0\n#define MW_FDCAN3_SF87C 0\n#define MW_FDCAN3_SF87TYPE 2\n#define MW_FDCAN3_SF87ID1 0\n#define MW_FDCAN3_SF87ID2 0\n#define MW_FDCAN3_SF88C 0\n#define MW_FDCAN3_SF88TYPE 2\n#define MW_FDCAN3_SF88ID1 0\n#define MW_FDCAN3_SF88ID2 0\n#define MW_FDCAN3_SF89C 0\n#define MW_FDCAN3_SF89TYPE 2\n#define MW_FDCAN3_SF89ID1 0\n#define MW_FDCAN3_SF89ID2 0\n#define MW_FDCAN3_SF90C 0\n#define MW_FDCAN3_SF90TYPE 2\n#define MW_FDCAN3_SF90ID1 0\n#define MW_FDCAN3_SF90ID2 0\n#define MW_FDCAN3_SF91C 0\n#define MW_FDCAN3_SF91TYPE 2\n#define MW_FDCAN3_SF91ID1 0\n#define MW_FDCAN3_SF91ID2 0\n#define MW_FDCAN3_SF92C 0\n#define MW_FDCAN3_SF92TYPE 2\n#define MW_FDCAN3_SF92ID1 0\n#define MW_FDCAN3_SF92ID2 0\n#define MW_FDCAN3_SF93C 0\n#define MW_FDCAN3_SF93TYPE 2\n#define MW_FDCAN3_SF93ID1 0\n#define MW_FDCAN3_SF93ID2 0\n#define MW_FDCAN3_SF94C 0\n#define MW_FDCAN3_SF94TYPE 2\n#define MW_FDCAN3_SF94ID1 0\n#define MW_FDCAN3_SF94ID2 0\n#define MW_FDCAN3_SF95C 0\n#define MW_FDCAN3_SF95TYPE 2\n#define MW_FDCAN3_SF95ID1 0\n#define MW_FDCAN3_SF95ID2 0\n#define MW_FDCAN3_SF96C 0\n#define MW_FDCAN3_SF96TYPE 2\n#define MW_FDCAN3_SF96ID1 0\n#define MW_FDCAN3_SF96ID2 0\n#define MW_FDCAN3_SF97C 0\n#define MW_FDCAN3_SF97TYPE 2\n#define MW_FDCAN3_SF97ID1 0\n#define MW_FDCAN3_SF97ID2 0\n#define MW_FDCAN3_SF98C 0\n#define MW_FDCAN3_SF98TYPE 2\n#define MW_FDCAN3_SF98ID1 0\n#define MW_FDCAN3_SF98ID2 0\n#define MW_FDCAN3_SF99C 0\n#define MW_FDCAN3_SF99TYPE 2\n#define MW_FDCAN3_SF99ID1 0\n#define MW_FDCAN3_SF99ID2 0\n#define MW_FDCAN3_SF100C 0\n#define MW_FDCAN3_SF100TYPE 2\n#define MW_FDCAN3_SF100ID1 0\n#define MW_FDCAN3_SF100ID2 0\n#define MW_FDCAN3_SF101C 0\n#define MW_FDCAN3_SF101TYPE 2\n#define MW_FDCAN3_SF101ID1 0\n#define MW_FDCAN3_SF101ID2 0\n#define MW_FDCAN3_SF102C 0\n#define MW_FDCAN3_SF102TYPE 2\n#define MW_FDCAN3_SF102ID1 0\n#define MW_FDCAN3_SF102ID2 0\n#define MW_FDCAN3_SF103C 0\n#define MW_FDCAN3_SF103TYPE 2\n#define MW_FDCAN3_SF103ID1 0\n#define MW_FDCAN3_SF103ID2 0\n#define MW_FDCAN3_SF104C 0\n#define MW_FDCAN3_SF104TYPE 2\n#define MW_FDCAN3_SF104ID1 0\n#define MW_FDCAN3_SF104ID2 0\n#define MW_FDCAN3_SF105C 0\n#define MW_FDCAN3_SF105TYPE 2\n#define MW_FDCAN3_SF105ID1 0\n#define MW_FDCAN3_SF105ID2 0\n#define MW_FDCAN3_SF106C 0\n#define MW_FDCAN3_SF106TYPE 2\n#define MW_FDCAN3_SF106ID1 0\n#define MW_FDCAN3_SF106ID2 0\n#define MW_FDCAN3_SF107C 0\n#define MW_FDCAN3_SF107TYPE 2\n#define MW_FDCAN3_SF107ID1 0\n#define MW_FDCAN3_SF107ID2 0\n#define MW_FDCAN3_SF108C 0\n#define MW_FDCAN3_SF108TYPE 2\n#define MW_FDCAN3_SF108ID1 0\n#define MW_FDCAN3_SF108ID2 0\n#define MW_FDCAN3_SF109C 0\n#define MW_FDCAN3_SF109TYPE 2\n#define MW_FDCAN3_SF109ID1 0\n#define MW_FDCAN3_SF109ID2 0\n#define MW_FDCAN3_SF110C 0\n#define MW_FDCAN3_SF110TYPE 2\n#define MW_FDCAN3_SF110ID1 0\n#define MW_FDCAN3_SF110ID2 0\n#define MW_FDCAN3_SF111C 0\n#define MW_FDCAN3_SF111TYPE 2\n#define MW_FDCAN3_SF111ID1 0\n#define MW_FDCAN3_SF111ID2 0\n#define MW_FDCAN3_SF112C 0\n#define MW_FDCAN3_SF112TYPE 2\n#define MW_FDCAN3_SF112ID1 0\n#define MW_FDCAN3_SF112ID2 0\n#define MW_FDCAN3_SF113C 0\n#define MW_FDCAN3_SF113TYPE 2\n#define MW_FDCAN3_SF113ID1 0\n#define MW_FDCAN3_SF113ID2 0\n#define MW_FDCAN3_SF114C 0\n#define MW_FDCAN3_SF114TYPE 2\n#define MW_FDCAN3_SF114ID1 0\n#define MW_FDCAN3_SF114ID2 0\n#define MW_FDCAN3_SF115C 0\n#define MW_FDCAN3_SF115TYPE 2\n#define MW_FDCAN3_SF115ID1 0\n#define MW_FDCAN3_SF115ID2 0\n#define MW_FDCAN3_SF116C 0\n#define MW_FDCAN3_SF116TYPE 2\n#define MW_FDCAN3_SF116ID1 0\n#define MW_FDCAN3_SF116ID2 0\n#define MW_FDCAN3_SF117C 0\n#define MW_FDCAN3_SF117TYPE 2\n#define MW_FDCAN3_SF117ID1 0\n#define MW_FDCAN3_SF117ID2 0\n#define MW_FDCAN3_SF118C 0\n#define MW_FDCAN3_SF118TYPE 2\n#define MW_FDCAN3_SF118ID1 0\n#define MW_FDCAN3_SF118ID2 0\n#define MW_FDCAN3_SF119C 0\n#define MW_FDCAN3_SF119TYPE 2\n#define MW_FDCAN3_SF119ID1 0\n#define MW_FDCAN3_SF119ID2 0\n#define MW_FDCAN3_SF120C 0\n#define MW_FDCAN3_SF120TYPE 2\n#define MW_FDCAN3_SF120ID1 0\n#define MW_FDCAN3_SF120ID2 0\n#define MW_FDCAN3_SF121C 0\n#define MW_FDCAN3_SF121TYPE 2\n#define MW_FDCAN3_SF121ID1 0\n#define MW_FDCAN3_SF121ID2 0\n#define MW_FDCAN3_SF122C 0\n#define MW_FDCAN3_SF122TYPE 2\n#define MW_FDCAN3_SF122ID1 0\n#define MW_FDCAN3_SF122ID2 0\n#define MW_FDCAN3_SF123C 0\n#define MW_FDCAN3_SF123TYPE 2\n#define MW_FDCAN3_SF123ID1 0\n#define MW_FDCAN3_SF123ID2 0\n#define MW_FDCAN3_SF124C 0\n#define MW_FDCAN3_SF124TYPE 2\n#define MW_FDCAN3_SF124ID1 0\n#define MW_FDCAN3_SF124ID2 0\n#define MW_FDCAN3_SF125C 0\n#define MW_FDCAN3_SF125TYPE 2\n#define MW_FDCAN3_SF125ID1 0\n#define MW_FDCAN3_SF125ID2 0\n#define MW_FDCAN3_SF126C 0\n#define MW_FDCAN3_SF126TYPE 2\n#define MW_FDCAN3_SF126ID1 0\n#define MW_FDCAN3_SF126ID2 0\n#define MW_FDCAN3_SF127C 0\n#define MW_FDCAN3_SF127TYPE 2\n#define MW_FDCAN3_SF127ID1 0\n#define MW_FDCAN3_SF127ID2 0\n#define MW_FDCAN3_EF 0\n#define MW_FDCAN3_EFNUMBER 0\n#define MW_FDCAN3_EF0C 0\n#define MW_FDCAN3_EF0TYPE 2\n#define MW_FDCAN3_EF0ID1 0\n#define MW_FDCAN3_EF0ID2 0\n#define MW_FDCAN3_EF1C 0\n#define MW_FDCAN3_EF1TYPE 2\n#define MW_FDCAN3_EF1ID1 0\n#define MW_FDCAN3_EF1ID2 0\n#define MW_FDCAN3_EF2C 0\n#define MW_FDCAN3_EF2TYPE 2\n#define MW_FDCAN3_EF2ID1 0\n#define MW_FDCAN3_EF2ID2 0\n#define MW_FDCAN3_EF3C 0\n#define MW_FDCAN3_EF3TYPE 2\n#define MW_FDCAN3_EF3ID1 0\n#define MW_FDCAN3_EF3ID2 0\n#define MW_FDCAN3_EF4C 0\n#define MW_FDCAN3_EF4TYPE 2\n#define MW_FDCAN3_EF4ID1 0\n#define MW_FDCAN3_EF4ID2 0\n#define MW_FDCAN3_EF5C 0\n#define MW_FDCAN3_EF5TYPE 2\n#define MW_FDCAN3_EF5ID1 0\n#define MW_FDCAN3_EF5ID2 0\n#define MW_FDCAN3_EF6C 0\n#define MW_FDCAN3_EF6TYPE 2\n#define MW_FDCAN3_EF6ID1 0\n#define MW_FDCAN3_EF6ID2 0\n#define MW_FDCAN3_EF7C 0\n#define MW_FDCAN3_EF7TYPE 2\n#define MW_FDCAN3_EF7ID1 0\n#define MW_FDCAN3_EF7ID2 0\n#define MW_FDCAN3_EF8C 0\n#define MW_FDCAN3_EF8TYPE 2\n#define MW_FDCAN3_EF8ID1 0\n#define MW_FDCAN3_EF8ID2 0\n#define MW_FDCAN3_EF9C 0\n#define MW_FDCAN3_EF9TYPE 2\n#define MW_FDCAN3_EF9ID1 0\n#define MW_FDCAN3_EF9ID2 0\n#define MW_FDCAN3_EF10C 0\n#define MW_FDCAN3_EF10TYPE 2\n#define MW_FDCAN3_EF10ID1 0\n#define MW_FDCAN3_EF10ID2 0\n#define MW_FDCAN3_EF11C 0\n#define MW_FDCAN3_EF11TYPE 2\n#define MW_FDCAN3_EF11ID1 0\n#define MW_FDCAN3_EF11ID2 0\n#define MW_FDCAN3_EF12C 0\n#define MW_FDCAN3_EF12TYPE 2\n#define MW_FDCAN3_EF12ID1 0\n#define MW_FDCAN3_EF12ID2 0\n#define MW_FDCAN3_EF13C 0\n#define MW_FDCAN3_EF13TYPE 2\n#define MW_FDCAN3_EF13ID1 0\n#define MW_FDCAN3_EF13ID2 0\n#define MW_FDCAN3_EF14C 0\n#define MW_FDCAN3_EF14TYPE 2\n#define MW_FDCAN3_EF14ID1 0\n#define MW_FDCAN3_EF14ID2 0\n#define MW_FDCAN3_EF15C 0\n#define MW_FDCAN3_EF15TYPE 2\n#define MW_FDCAN3_EF15ID1 0\n#define MW_FDCAN3_EF15ID2 0\n#define MW_FDCAN3_EF16C 0\n#define MW_FDCAN3_EF16TYPE 2\n#define MW_FDCAN3_EF16ID1 0\n#define MW_FDCAN3_EF16ID2 0\n#define MW_FDCAN3_EF17C 0\n#define MW_FDCAN3_EF17TYPE 2\n#define MW_FDCAN3_EF17ID1 0\n#define MW_FDCAN3_EF17ID2 0\n#define MW_FDCAN3_EF18C 0\n#define MW_FDCAN3_EF18TYPE 2\n#define MW_FDCAN3_EF18ID1 0\n#define MW_FDCAN3_EF18ID2 0\n#define MW_FDCAN3_EF19C 0\n#define MW_FDCAN3_EF19TYPE 2\n#define MW_FDCAN3_EF19ID1 0\n#define MW_FDCAN3_EF19ID2 0\n#define MW_FDCAN3_EF20C 0\n#define MW_FDCAN3_EF20TYPE 2\n#define MW_FDCAN3_EF20ID1 0\n#define MW_FDCAN3_EF20ID2 0\n#define MW_FDCAN3_EF21C 0\n#define MW_FDCAN3_EF21TYPE 2\n#define MW_FDCAN3_EF21ID1 0\n#define MW_FDCAN3_EF21ID2 0\n#define MW_FDCAN3_EF22C 0\n#define MW_FDCAN3_EF22TYPE 2\n#define MW_FDCAN3_EF22ID1 0\n#define MW_FDCAN3_EF22ID2 0\n#define MW_FDCAN3_EF23C 0\n#define MW_FDCAN3_EF23TYPE 2\n#define MW_FDCAN3_EF23ID1 0\n#define MW_FDCAN3_EF23ID2 0\n#define MW_FDCAN3_EF24C 0\n#define MW_FDCAN3_EF24TYPE 2\n#define MW_FDCAN3_EF24ID1 0\n#define MW_FDCAN3_EF24ID2 0\n#define MW_FDCAN3_EF25C 0\n#define MW_FDCAN3_EF25TYPE 2\n#define MW_FDCAN3_EF25ID1 0\n#define MW_FDCAN3_EF25ID2 0\n#define MW_FDCAN3_EF26C 0\n#define MW_FDCAN3_EF26TYPE 2\n#define MW_FDCAN3_EF26ID1 0\n#define MW_FDCAN3_EF26ID2 0\n#define MW_FDCAN3_EF27C 0\n#define MW_FDCAN3_EF27TYPE 2\n#define MW_FDCAN3_EF27ID1 0\n#define MW_FDCAN3_EF27ID2 0\n#define MW_FDCAN3_EF28C 0\n#define MW_FDCAN3_EF28TYPE 2\n#define MW_FDCAN3_EF28ID1 0\n#define MW_FDCAN3_EF28ID2 0\n#define MW_FDCAN3_EF29C 0\n#define MW_FDCAN3_EF29TYPE 2\n#define MW_FDCAN3_EF29ID1 0\n#define MW_FDCAN3_EF29ID2 0\n#define MW_FDCAN3_EF30C 0\n#define MW_FDCAN3_EF30TYPE 2\n#define MW_FDCAN3_EF30ID1 0\n#define MW_FDCAN3_EF30ID2 0\n#define MW_FDCAN3_EF31C 0\n#define MW_FDCAN3_EF31TYPE 2\n#define MW_FDCAN3_EF31ID1 0\n#define MW_FDCAN3_EF31ID2 0\n#define MW_FDCAN3_EF32C 0\n#define MW_FDCAN3_EF32TYPE 2\n#define MW_FDCAN3_EF32ID1 0\n#define MW_FDCAN3_EF32ID2 0\n#define MW_FDCAN3_EF33C 0\n#define MW_FDCAN3_EF33TYPE 2\n#define MW_FDCAN3_EF33ID1 0\n#define MW_FDCAN3_EF33ID2 0\n#define MW_FDCAN3_EF34C 0\n#define MW_FDCAN3_EF34TYPE 2\n#define MW_FDCAN3_EF34ID1 0\n#define MW_FDCAN3_EF34ID2 0\n#define MW_FDCAN3_EF35C 0\n#define MW_FDCAN3_EF35TYPE 2\n#define MW_FDCAN3_EF35ID1 0\n#define MW_FDCAN3_EF35ID2 0\n#define MW_FDCAN3_EF36C 0\n#define MW_FDCAN3_EF36TYPE 2\n#define MW_FDCAN3_EF36ID1 0\n#define MW_FDCAN3_EF36ID2 0\n#define MW_FDCAN3_EF37C 0\n#define MW_FDCAN3_EF37TYPE 2\n#define MW_FDCAN3_EF37ID1 0\n#define MW_FDCAN3_EF37ID2 0\n#define MW_FDCAN3_EF38C 0\n#define MW_FDCAN3_EF38TYPE 2\n#define MW_FDCAN3_EF38ID1 0\n#define MW_FDCAN3_EF38ID2 0\n#define MW_FDCAN3_EF39C 0\n#define MW_FDCAN3_EF39TYPE 2\n#define MW_FDCAN3_EF39ID1 0\n#define MW_FDCAN3_EF39ID2 0\n#define MW_FDCAN3_EF40C 0\n#define MW_FDCAN3_EF40TYPE 2\n#define MW_FDCAN3_EF40ID1 0\n#define MW_FDCAN3_EF40ID2 0\n#define MW_FDCAN3_EF41C 0\n#define MW_FDCAN3_EF41TYPE 2\n#define MW_FDCAN3_EF41ID1 0\n#define MW_FDCAN3_EF41ID2 0\n#define MW_FDCAN3_EF42C 0\n#define MW_FDCAN3_EF42TYPE 2\n#define MW_FDCAN3_EF42ID1 0\n#define MW_FDCAN3_EF42ID2 0\n#define MW_FDCAN3_EF43C 0\n#define MW_FDCAN3_EF43TYPE 2\n#define MW_FDCAN3_EF43ID1 0\n#define MW_FDCAN3_EF43ID2 0\n#define MW_FDCAN3_EF44C 0\n#define MW_FDCAN3_EF44TYPE 2\n#define MW_FDCAN3_EF44ID1 0\n#define MW_FDCAN3_EF44ID2 0\n#define MW_FDCAN3_EF45C 0\n#define MW_FDCAN3_EF45TYPE 2\n#define MW_FDCAN3_EF45ID1 0\n#define MW_FDCAN3_EF45ID2 0\n#define MW_FDCAN3_EF46C 0\n#define MW_FDCAN3_EF46TYPE 2\n#define MW_FDCAN3_EF46ID1 0\n#define MW_FDCAN3_EF46ID2 0\n#define MW_FDCAN3_EF47C 0\n#define MW_FDCAN3_EF47TYPE 2\n#define MW_FDCAN3_EF47ID1 0\n#define MW_FDCAN3_EF47ID2 0\n#define MW_FDCAN3_EF48C 0\n#define MW_FDCAN3_EF48TYPE 2\n#define MW_FDCAN3_EF48ID1 0\n#define MW_FDCAN3_EF48ID2 0\n#define MW_FDCAN3_EF49C 0\n#define MW_FDCAN3_EF49TYPE 2\n#define MW_FDCAN3_EF49ID1 0\n#define MW_FDCAN3_EF49ID2 0\n#define MW_FDCAN3_EF50C 0\n#define MW_FDCAN3_EF50TYPE 2\n#define MW_FDCAN3_EF50ID1 0\n#define MW_FDCAN3_EF50ID2 0\n#define MW_FDCAN3_EF51C 0\n#define MW_FDCAN3_EF51TYPE 2\n#define MW_FDCAN3_EF51ID1 0\n#define MW_FDCAN3_EF51ID2 0\n#define MW_FDCAN3_EF52C 0\n#define MW_FDCAN3_EF52TYPE 2\n#define MW_FDCAN3_EF52ID1 0\n#define MW_FDCAN3_EF52ID2 0\n#define MW_FDCAN3_EF53C 0\n#define MW_FDCAN3_EF53TYPE 2\n#define MW_FDCAN3_EF53ID1 0\n#define MW_FDCAN3_EF53ID2 0\n#define MW_FDCAN3_EF54C 0\n#define MW_FDCAN3_EF54TYPE 2\n#define MW_FDCAN3_EF54ID1 0\n#define MW_FDCAN3_EF54ID2 0\n#define MW_FDCAN3_EF55C 0\n#define MW_FDCAN3_EF55TYPE 2\n#define MW_FDCAN3_EF55ID1 0\n#define MW_FDCAN3_EF55ID2 0\n#define MW_FDCAN3_EF56C 0\n#define MW_FDCAN3_EF56TYPE 2\n#define MW_FDCAN3_EF56ID1 0\n#define MW_FDCAN3_EF56ID2 0\n#define MW_FDCAN3_EF57C 0\n#define MW_FDCAN3_EF57TYPE 2\n#define MW_FDCAN3_EF57ID1 0\n#define MW_FDCAN3_EF57ID2 0\n#define MW_FDCAN3_EF58C 0\n#define MW_FDCAN3_EF58TYPE 2\n#define MW_FDCAN3_EF58ID1 0\n#define MW_FDCAN3_EF58ID2 0\n#define MW_FDCAN3_EF59C 0\n#define MW_FDCAN3_EF59TYPE 2\n#define MW_FDCAN3_EF59ID1 0\n#define MW_FDCAN3_EF59ID2 0\n#define MW_FDCAN3_EF60C 0\n#define MW_FDCAN3_EF60TYPE 2\n#define MW_FDCAN3_EF60ID1 0\n#define MW_FDCAN3_EF60ID2 0\n#define MW_FDCAN3_EF61C 0\n#define MW_FDCAN3_EF61TYPE 2\n#define MW_FDCAN3_EF61ID1 0\n#define MW_FDCAN3_EF61ID2 0\n#define MW_FDCAN3_EF62C 0\n#define MW_FDCAN3_EF62TYPE 2\n#define MW_FDCAN3_EF62ID1 0\n#define MW_FDCAN3_EF62ID2 0\n#define MW_FDCAN3_EF63C 0\n#define MW_FDCAN3_EF63TYPE 2\n#define MW_FDCAN3_EF63ID1 0\n#define MW_FDCAN3_EF63ID2 0\n#define MW_MQTT_BROKERADDRESS <Enter Broker I.P. Address>\n#define MW_MQTT_PORT 1883\n#define MW_MQTT_USERNAME NULL\n#define MW_MQTT_PASSWORD NULL\n#define MW_MQTT_CID NULL\n#define MW_PIL_INTERFACE 0\n#define MW_CORDIC_INPUTBUFFERLENGTH 40\n#define MW_CORDIC_OUTPUTBUFFERLENGTH 80\n#define MW_SDCLOG_ENABLELOGGING 0\n#define MW_SDCLOG_INTERFACE 0\n#define MW_SDCLOG_ENABLELOGGINGSTATUS 0\n#define MW_SDCLOG_LOGGINGSTATUSGPIOGROUP 0\n#define MW_SDCLOG_LOGGINGSTATUSGPIOPIN 1\n#define MW_SENSOR_FILELOCATION stm32cube.sensors\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"SysTickScheduler.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025b\\toolbox\\target\\shared\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* SysTick scheduler\n * \n * Copyright 2013-2024 The MathWorks, Inc.\n */\n \n#include \"arm_cortex_m_multitasking.h\"\n\nunsigned long schdl_counter;\nunsigned long schdl_counter_max;\n\nextern volatile uint32_t taskToSchedule;\n\n#if !defined(MW_DONT_USE_SYSTICK)\n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n__attribute__((used)) static void SysTick_Isr(void)\n{\n    __DSB();\n    __ISB();\n\t\n\tif (schdl_counter >= schdl_counter_max)\n\t{\n\t\tschdl_counter = 0;\n\t}\n\t\n    if (0 == schdl_counter++)\t/* Compare with zero before increment */\n\t{\n\t\t/* The rt_OneStep() function expects interrupts to be disabled. \n           Hence disable interrupt before rt_OneStep(). */\n        __disable_irq();\n        rt_OneStep();\n        /* The rt_OneStep() function disables interrupt. \n           Hence enable interrupt immediately after rt_OneStep(). */\n        __enable_irq();\n\t}\n}\n#endif\n#endif\n\n#if (MW_ARMv6M_AND_PLUS == 0)\n    void SysTick_Handler(){\n    SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;\n}\n#else\nMW_RENTRANT_ISR_FUNCTION_BEGIN(SysTick_Handler, -1)\n    MW_CALL_ISR_FUNCTION(SysTick_Isr);\nMW_RENTRANT_ISR_FUNCTION_END()\n#endif\n\nvoid ARMCM_SysTick_Config(float modelBaseRate)\n{\n#if !defined(MW_DONT_USE_SYSTICK)    \n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n\t/* SysTick Scheduler is selected */\n\tunsigned long tick_counter;\n\t\n\ttick_counter = (unsigned long)(SystemCoreClock * modelBaseRate);\n\t\n\tif (tick_counter > SysTick_LOAD_RELOAD_Msk)\n\t{\n\t\tschdl_counter_max = (unsigned long)((float)tick_counter / (float)SysTick_LOAD_RELOAD_Msk) + 1;\n\t\tSysTick_Config(tick_counter/schdl_counter_max);\t\t\n\t}\n\telse\n\t{\n\t\tschdl_counter_max = 0;\n\t\tSysTick_Config(tick_counter);\n\t}\n\t\n\tschdl_counter = 0;\n\t\n\t/* Set the SysTick priority */\n\t#ifdef MW_SCHEDULER_PRIORITY\n\t\tNVIC_SetPriority((IRQn_Type)(-1), MW_SCHEDULER_PRIORITY);\n\t#endif\n    #if (MW_ARMv6M_AND_PLUS == 0)\n        taskToSchedule = (uint32_t) SysTick_Isr;\n    #endif\n#endif\n#endif\n    NVIC_SetPriority((IRQn_Type)(-5), MW_MAX_PRIORITY_VALUE);\n    NVIC_SetPriority((IRQn_Type)(-2), MW_MAX_PRIORITY_VALUE);\n}\n\nvoid ARMCM_SysTick_Stop(void)\n{\n#if !defined(MW_DONT_USE_SYSTICK)    \n#if defined(MW_SCHEDULER_INTERRUPT_SOURCE) && (MW_SCHEDULER_INTERRUPT_SOURCE == 0)\n\t/* SysTick Scheduler is Stopped */\n\tSysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;\n#endif\n#endif\n}\n"},{"name":"m3m4m4f_multitasking.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2025b\\toolbox\\target\\shared\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Wrapper for Multi tasking.\n * \n * Copyright 2013-2020 The MathWorks, Inc.\n */\n\n\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#include \"MW_target_hardware_resources.h\"\n#endif\n\n#ifndef __NVIC_PRIO_BITS\n#error \"__NVIC_PRIO_BITS is undefined.  The __NVIC_PRIO_BITS is defined in hardware definition header file.\"\n#endif\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\nvolatile uint32_t taskToSchedule;\n\n__attribute__ ((naked,aligned(4))) void PendSV_Handler() {\n    __asm volatile (\n    \"   MRS R0, APSR                            \\n\"\n    \"   PUSH {R0, LR}                           \\n\"\n    \"   MRS R0, BASEPRI                         \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST LR, #0x10                           \\n\"\n    \"   IT EQ                                   \\n\"\n    \"   VMOVEQ S0, S0                           \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   LDR R0, =taskToSchedule                 \\n\"\n    \"   LDR R0, [R0]                            \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    \"   SUB SP, SP, #0x20                       \\n\"\n    \"   ADR R0,Call_isr_routine_in_thread_mode \\n\"\n    \"   STR R0,[SP, #24]                        \\n\"\n    \"   MOV R0,#0x01000000                      \\n\"\n    \"   STR R0,[SP, #28]                        \\n\"\n    \"   MVN R0,#0x06                            \\n\"\n    \"   MOV LR, R0                              \\n\"\n    \"   BX LR                                   \\n\"\n    \"Call_isr_routine_in_thread_mode:           \\n\"\n    \"   POP {R0, R1}                            \\n\"\n    \"   BLX R0                                  \\n\"\n    \"   ISB                                     \\n\"\n    \"   SVC #0                                  \\n\"\n    \"Unknown_Execution:                         \\n\"\n    \"   B Unknown_Execution                     \\n\"\n    );\n}\n\n/* SVC Interrupt service routine to restore the context: SVC_Handler*/\n__attribute__ ((naked,aligned(4))) void SVC_Handler(void) {\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST  LR, #0x10      \\n\"\n    \"   IT EQ               \\n\"\n    \"   VMOVEQ.F32 S0, S0   \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   TST LR, #0x4            \\n\"\n    \"   ITE EQ                  \\n\"\n    \"   MRSEQ R0, MSP           \\n\"\n    \"   MRSNE R0, PSP           \\n\"\n    \"   LDR R1, [R0, #24]       \\n\"\n    \"   LDRB R0, [R1, #-2]      \\n\"\n    \"   CBZ R0, svc_service_0   \\n\"\n    \"   CMP R0, #1              \\n\"\n    \"   BEQ svc_service_1       \\n\"\n    \"   B Unknown_SVC_Request   \\n\"\n    \"svc_service_0:             \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n     __asm volatile (\n    \"   TST LR, #0x10       \\n\"\n    \"   ITE EQ              \\n\"\n    \"   ADDEQ SP, SP, #104  \\n\"\n    \"   ADDNE SP, SP, #32   \\n\"\n     );\n#else\n     __asm volatile (\"     ADD SP, SP, #32\");\n#endif\n     __asm volatile (\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR BASEPRI, R0           \\n\"\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR APSR_nzcvq, R0        \\n\"\n    \"     BX R1                     \\n\"\n    \"Unknown_SVC_Request:           \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    \"svc_service_1:                 \\n\"\n    \"     MOVW R1, #0x0000ED14      \\n\"\n    \"     MOVT R1, #0xE000          \\n\"\n    \"     LDR R2,[R1]               \\n\"\n    \"     ORR R2, #1                \\n\"\n    \"     STR R2,[R1]               \\n\"\n    \"     BX LR                     \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    );\n}\n\n/* LocalWords:  NVIC PRIO TST VMOVEQ ADR isr MOV MVNS asm cpsie chaing arival VMOV MVN\n * LocalWords:  BLX ISB SVC ITE MRSEQ MSP MRSNE PSP LDR LDRB CBZ svc CMP BEQ\n * LocalWords:  ADDEQ ADDNE MSR BASEPRI xff APSR nzcvq MOVW MOVT\n */\n"},{"name":"main.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file           : main.c\r\n  * @brief          : Main program body\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2026 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN PTD */\r\n\r\n/* USER CODE END PTD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n\r\nSPI_HandleTypeDef hspi1;\r\n\r\nTIM_HandleTypeDef htim13;\r\n\r\nUART_HandleTypeDef huart3;\r\n\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\nvoid SystemClock_Config(void);\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* Private user code ---------------------------------------------------------*/\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n\r\n/**\r\n  * @brief  The application entry point.\r\n  * @retval int\r\n  */\r\n\r\n/**\r\n  * @brief System Clock Configuration\r\n  * @retval None\r\n  */\r\nvoid SystemClock_Config(void)\r\n{\r\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\r\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\r\n\r\n  /** Supply configuration update enable\r\n  */\r\n  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);\r\n  /** Configure the main internal regulator output voltage\r\n  */\r\n  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);\r\n\r\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}\r\n  /** Initializes the RCC Oscillators according to the specified parameters\r\n  * in the RCC_OscInitTypeDef structure.\r\n  */\r\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;\r\n  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;\r\n  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;\r\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\r\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;\r\n  RCC_OscInitStruct.PLL.PLLM = 4;\r\n  RCC_OscInitStruct.PLL.PLLN = 9;\r\n  RCC_OscInitStruct.PLL.PLLP = 2;\r\n  RCC_OscInitStruct.PLL.PLLQ = 2;\r\n  RCC_OscInitStruct.PLL.PLLR = 2;\r\n  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;\r\n  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOMEDIUM;\r\n  RCC_OscInitStruct.PLL.PLLFRACN = 3072;\r\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  /** Initializes the CPU, AHB and APB buses clocks\r\n  */\r\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\r\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2\r\n                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;\r\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;\r\n  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;\r\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;\r\n  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;\r\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;\r\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;\r\n  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;\r\n\r\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief SPI1 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_SPI1_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN SPI1_Init 0 */\r\n\r\n  /* USER CODE END SPI1_Init 0 */\r\n\r\n  /* USER CODE BEGIN SPI1_Init 1 */\r\n\r\n  /* USER CODE END SPI1_Init 1 */\r\n  /* SPI1 parameter configuration*/\r\n  hspi1.Instance = SPI1;\r\n  hspi1.Init.Mode = SPI_MODE_MASTER;\r\n  hspi1.Init.Direction = SPI_DIRECTION_2LINES;\r\n  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;\r\n  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;\r\n  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;\r\n  hspi1.Init.NSS = SPI_NSS_SOFT;\r\n  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;\r\n  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;\r\n  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;\r\n  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;\r\n  hspi1.Init.CRCPolynomial = 0x0;\r\n  hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;\r\n  hspi1.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;\r\n  hspi1.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;\r\n  hspi1.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;\r\n  hspi1.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;\r\n  hspi1.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;\r\n  hspi1.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;\r\n  hspi1.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;\r\n  hspi1.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;\r\n  hspi1.Init.IOSwap = SPI_IO_SWAP_DISABLE;\r\n  if (HAL_SPI_Init(&hspi1) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  /* USER CODE BEGIN SPI1_Init 2 */\r\n\r\n  /* USER CODE END SPI1_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * @brief TIM13 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_TIM13_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN TIM13_Init 0 */\r\n\r\n  /* USER CODE END TIM13_Init 0 */\r\n\r\n  /* USER CODE BEGIN TIM13_Init 1 */\r\n\r\n  /* USER CODE END TIM13_Init 1 */\r\n  htim13.Instance = TIM13;\r\n  htim13.Init.Prescaler = 8400-1;\r\n  htim13.Init.CounterMode = TIM_COUNTERMODE_UP;\r\n  htim13.Init.Period = 40-1;\r\n  htim13.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\r\n  htim13.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\r\n  if (HAL_TIM_Base_Init(&htim13) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  /* USER CODE BEGIN TIM13_Init 2 */\r\n\r\n  /* USER CODE END TIM13_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * @brief USART3 Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_USART3_UART_Init(void)\r\n{\r\n\r\n  /* USER CODE BEGIN USART3_Init 0 */\r\n\r\n  /* USER CODE END USART3_Init 0 */\r\n\r\n  /* USER CODE BEGIN USART3_Init 1 */\r\n\r\n  /* USER CODE END USART3_Init 1 */\r\n  huart3.Instance = USART3;\r\n  huart3.Init.BaudRate = 115200;\r\n  huart3.Init.WordLength = UART_WORDLENGTH_8B;\r\n  huart3.Init.StopBits = UART_STOPBITS_1;\r\n  huart3.Init.Parity = UART_PARITY_NONE;\r\n  huart3.Init.Mode = UART_MODE_TX_RX;\r\n  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;\r\n  huart3.Init.OverSampling = UART_OVERSAMPLING_16;\r\n  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\r\n  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;\r\n  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;\r\n  if (HAL_UART_Init(&huart3) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)\r\n  {\r\n    Error_Handler();\r\n  }\r\n  /* USER CODE BEGIN USART3_Init 2 */\r\n\r\n  /* USER CODE END USART3_Init 2 */\r\n\r\n}\r\n\r\n/**\r\n  * @brief GPIO Initialization Function\r\n  * @param None\r\n  * @retval None\r\n  */\r\nvoid MX_GPIO_Init(void)\r\n{\r\n  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n\r\n  /* GPIO Ports Clock Enable */\r\n  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOC);\r\n  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOA);\r\n  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOB);\r\n  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOD);\r\n  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOE);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(Green_LED_GPIO_Port, Green_LED_Pin);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(SPI1_CSB_GPIO_Port, SPI1_CSB_Pin);\r\n\r\n  /**/\r\n  LL_GPIO_ResetOutputPin(Yellow_LED_GPIO_Port, Yellow_LED_Pin);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = User_Button_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(User_Button_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = Green_LED_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(Green_LED_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = SPI1_CSB_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(SPI1_CSB_GPIO_Port, &GPIO_InitStruct);\r\n\r\n  /**/\r\n  GPIO_InitStruct.Pin = Yellow_LED_Pin;\r\n  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;\r\n  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;\r\n  LL_GPIO_Init(Yellow_LED_GPIO_Port, &GPIO_InitStruct);\r\n\r\n}\r\n\r\n/* USER CODE BEGIN 4 */\r\n\r\n/* USER CODE END 4 */\r\n\r\n/**\r\n  * @brief  Period elapsed callback in non blocking mode\r\n  * @note   This function is called  when TIM1 interrupt took place, inside\r\n  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment\r\n  * a global variable \"uwTick\" used as application time base.\r\n  * @param  htim : TIM handle\r\n  * @retval None\r\n  */\r\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* USER CODE BEGIN Callback 0 */\r\n\r\n  /* USER CODE END Callback 0 */\r\n  if (htim->Instance == TIM1) {\r\n    HAL_IncTick();\r\n  }\r\n  /* USER CODE BEGIN Callback 1 */\r\n\r\n  /* USER CODE END Callback 1 */\r\n}\r\n\r\n/**\r\n  * @brief  This function is executed in case of error occurrence.\r\n  * @retval None\r\n  */\r\nvoid Error_Handler(void)\r\n{\r\n  /* USER CODE BEGIN Error_Handler_Debug */\r\n  /* User can add his own implementation to report the HAL error return state */\r\n  __disable_irq();\r\n  while (1)\r\n  {\r\n  }\r\n  /* USER CODE END Error_Handler_Debug */\r\n}\r\n\r\n#ifdef  USE_FULL_ASSERT\r\n/**\r\n  * @brief  Reports the name of the source file and the source line number\r\n  *         where the assert_param error has occurred.\r\n  * @param  file: pointer to the source file name\r\n  * @param  line: assert_param error line source number\r\n  * @retval None\r\n  */\r\nvoid assert_failed(uint8_t *file, uint32_t line)\r\n{\r\n  /* USER CODE BEGIN 6 */\r\n  /* User can add his own implementation to report the file name and line number,\r\n     ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */\r\n  /* USER CODE END 6 */\r\n}\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n\n/*SimulinkGeneratedCode*/\n"},{"name":"overrideHALDelay.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2025b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Removing min 1ms wait from HAL_Delay */\n#include \"rtwtypes.h\"\n#include \"main.h\"\n\nvoid HAL_Delay(uint32_t Delay)\n{\n  uint32_t tickstart = HAL_GetTick();\n  uint32_t wait = Delay;\n\n  /* Add a freq to guarantee minimum wait */\n /* if (wait < HAL_MAX_DELAY)\n  {\n    wait += (uint32_t)(uwTickFreq);\n  }*/\n\n  while((HAL_GetTick() - tickstart) < wait)\n  {\n  }\n}"},{"name":"platform_timer.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2025b\\toolbox\\shared\\supportpackages\\stm32\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021-2024 The MathWorks, Inc. */\n\n#include \"mw_stm32_types.h\"\n#include \"main.h\"\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x)  #x\n\n#define MW_StringifyDefineHeader(x) MW_StringifyDefineHeaderExpand(x)\n#define MW_StringifyDefineHeaderExpand(x)  x.h\n\n__weak void PeriphCommonClock_Config(void){};\n\n#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6000000)\nuint32_T getCurrentTimestampInMicros(void)\n#else\n__attribute__((optimize(\"O3\"))) uint32_T getCurrentTimestampInMicros(void)\n#endif\n{\n    uint32_T currentTime;\n    __IO uint32_T timeInMs;\n    __IO uint32_T timeInMicroTick;\n    \n    timeInMicroTick = (uint32_t)(MW_TIMEBASESOURCE->CNT);\n    timeInMs = GET_CURRENT_TIME();\n\n    /* Check timer is overrun before calculating time in micros */\n    if (timeInMicroTick > (uint32_t)((MW_TIMEBASESOURCE)->CNT))\n    {\n        currentTime = GET_CURRENT_TIME()*1000 + (uint32_t)((MW_TIMEBASESOURCE)->CNT);\n    }\n    else\n    {\n        currentTime = timeInMs*1000 + timeInMicroTick;\n    }\n\n    return currentTime;\n}\n\n#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6000000)\nuint32_T returnTimeElapsed(uint32_T timestampStartTime, boolean_T isTimeInMS)\n#else\n__attribute__((optimize(\"O3\"))) uint32_T returnTimeElapsed(uint32_T timestampStartTime, boolean_T isTimeInMS)\n#endif\n{\n    uint32_T currentTime;\n    uint32_T ret = 0;\n    \n    if(0 == isTimeInMS)\n    {\n        currentTime = getCurrentTimestampInMicros();\n    }\n    else\n    {\n        currentTime = GET_CURRENT_TIME();\n    }\n    \n    if (currentTime >= timestampStartTime)\n    {\n        ret = (uint32_T) (currentTime - timestampStartTime);\n    }\n    else\n    {\n        ret = (uint32_T) (UINT32_MAX - timestampStartTime + currentTime);\n    }\n    return ret ;\n}\n\n#if defined(EXT_MODE) && (EXT_MODE == 1) && !defined(XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME)\n#include MW_StringifyDefine(MW_StringifyDefineHeader(MODEL))\n\nstatic volatile uint32_T timestampInitialized = 0;\nstatic volatile uint32_T timestampStartTime = 0;\n\nstatic void timestampInit(void)\n{\n    if (0 == timestampInitialized)\n    {\n        timestampStartTime =  GET_CURRENT_TIME_IN_US();\n        timestampInitialized = 1;\n    }\n}\n\n#if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6000000)\nuint32_t getCurrentTimestamp(void)\n#else\n__attribute__((optimize(\"O3\"))) uint32_t getCurrentTimestamp(void)\n#endif\n{\n    uint32_T ret = 0;\n    if ((1 == runModel) || (1 == timestampInitialized))\n    {\n        if (0 == timestampInitialized)\n        {\n            timestampInit();\n        }\n        ret = returnTimeElapsed(timestampStartTime, 0);\n    }\n    else\n    {\n        timestampStartTime =  GET_CURRENT_TIME_IN_US();\n    }\n    return ret;\n}\n#endif\n\n/* LocalWords:  TIMEBASESOURCE\n */\n"},{"name":"startup_stm32h753zitx.s","type":"other","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\STM32CubeIDE\\Application\\User\\Startup","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file      startup_stm32h753xx.s\r\n  * @author    MCD Application Team\r\n  * @brief     STM32H753xx Devices vector table for GCC based toolchain.\r\n  *            This module performs:\r\n  *                - Set the initial SP\r\n  *                - Set the initial PC == Reset_Handler,\r\n  *                - Set the vector table entries with the exceptions ISR address\r\n  *                - Branches to main in the C library (which eventually\r\n  *                  calls main()).\r\n  *            After Reset the Cortex-M processor is in Thread mode,\r\n  *            priority is Privileged, and the Stack is set to Main.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n  .syntax unified\r\n  .cpu cortex-m7\r\n  .fpu softvfp\r\n  .thumb\r\n\r\n.global  g_pfnVectors\r\n.global  Default_Handler\r\n\r\n/* start address for the initialization values of the .data section.\r\ndefined in linker script */\r\n.word  _sidata\r\n/* start address for the .data section. defined in linker script */\r\n.word  _sdata\r\n/* end address for the .data section. defined in linker script */\r\n.word  _edata\r\n/* start address for the .bss section. defined in linker script */\r\n.word  _sbss\r\n/* end address for the .bss section. defined in linker script */\r\n.word  _ebss\r\n/* stack used for SystemInit_ExtMemCtl; always internal RAM used */\r\n\r\n/**\r\n * @brief  This is the code that gets called when the processor first\r\n *          starts execution following a reset event. Only the absolutely\r\n *          necessary set is performed, after which the application\r\n *          supplied main() routine is called.\r\n * @param  None\r\n * @retval : None\r\n*/\r\n\r\n    .section  .text.Reset_Handler\r\n  .weak  Reset_Handler\r\n  .type  Reset_Handler, %function\r\nReset_Handler:\r\n  ldr   sp, =_estack      /* set stack pointer */\r\n\r\n/* Call the clock system initialization function.*/\r\n  bl  SystemInit\r\n\r\n/* Copy the data segment initializers from flash to SRAM */\r\n  ldr r0, =_sdata\r\n  ldr r1, =_edata\r\n  ldr r2, =_sidata\r\n  movs r3, #0\r\n  b LoopCopyDataInit\r\n\r\nCopyDataInit:\r\n  ldr r4, [r2, r3]\r\n  str r4, [r0, r3]\r\n  adds r3, r3, #4\r\n\r\nLoopCopyDataInit:\r\n  adds r4, r0, r3\r\n  cmp r4, r1\r\n  bcc CopyDataInit\r\n/* Zero fill the bss segment. */\r\n  ldr r2, =_sbss\r\n  ldr r4, =_ebss\r\n  movs r3, #0\r\n  b LoopFillZerobss\r\n\r\nFillZerobss:\r\n  str  r3, [r2]\r\n  adds r2, r2, #4\r\n\r\nLoopFillZerobss:\r\n  cmp r2, r4\r\n  bcc FillZerobss\r\n\r\n/* Call static constructors */\r\n    bl __libc_init_array\r\n/* Call the application's entry point.*/\r\n  bl  main\r\n  bx  lr\r\n.size  Reset_Handler, .-Reset_Handler\r\n\r\n/**\r\n * @brief  This is the code that gets called when the processor receives an\r\n *         unexpected interrupt.  This simply enters an infinite loop, preserving\r\n *         the system state for examination by a debugger.\r\n * @param  None\r\n * @retval None\r\n*/\r\n    .section  .text.Default_Handler,\"ax\",%progbits\r\nDefault_Handler:\r\nInfinite_Loop:\r\n  b  Infinite_Loop\r\n  .size  Default_Handler, .-Default_Handler\r\n/******************************************************************************\r\n*\r\n* The minimal vector table for a Cortex M. Note that the proper constructs\r\n* must be placed on this to ensure that it ends up at physical address\r\n* 0x0000.0000.\r\n*\r\n*******************************************************************************/\r\n   .section  .isr_vector,\"a\",%progbits\r\n  .type  g_pfnVectors, %object\r\n  .size  g_pfnVectors, .-g_pfnVectors\r\n\r\n\r\ng_pfnVectors:\r\n  .word  _estack\r\n  .word  Reset_Handler\r\n\r\n  .word  NMI_Handler\r\n  .word  HardFault_Handler\r\n  .word  MemManage_Handler\r\n  .word  BusFault_Handler\r\n  .word  UsageFault_Handler\r\n  .word  0\r\n  .word  0\r\n  .word  0\r\n  .word  0\r\n  .word  SVC_Handler\r\n  .word  DebugMon_Handler\r\n  .word  0\r\n  .word  PendSV_Handler\r\n  .word  SysTick_Handler\r\n\r\n  /* External Interrupts */\r\n  .word     WWDG_IRQHandler                   /* Window WatchDog              */\r\n  .word     PVD_AVD_IRQHandler                /* PVD/AVD through EXTI Line detection */\r\n  .word     TAMP_STAMP_IRQHandler             /* Tamper and TimeStamps through the EXTI line */\r\n  .word     RTC_WKUP_IRQHandler               /* RTC Wakeup through the EXTI line */\r\n  .word     FLASH_IRQHandler                  /* FLASH                        */\r\n  .word     RCC_IRQHandler                    /* RCC                          */\r\n  .word     EXTI0_IRQHandler                  /* EXTI Line0                   */\r\n  .word     EXTI1_IRQHandler                  /* EXTI Line1                   */\r\n  .word     EXTI2_IRQHandler                  /* EXTI Line2                   */\r\n  .word     EXTI3_IRQHandler                  /* EXTI Line3                   */\r\n  .word     EXTI4_IRQHandler                  /* EXTI Line4                   */\r\n  .word     DMA1_Stream0_IRQHandler           /* DMA1 Stream 0                */\r\n  .word     DMA1_Stream1_IRQHandler           /* DMA1 Stream 1                */\r\n  .word     DMA1_Stream2_IRQHandler           /* DMA1 Stream 2                */\r\n  .word     DMA1_Stream3_IRQHandler           /* DMA1 Stream 3                */\r\n  .word     DMA1_Stream4_IRQHandler           /* DMA1 Stream 4                */\r\n  .word     DMA1_Stream5_IRQHandler           /* DMA1 Stream 5                */\r\n  .word     DMA1_Stream6_IRQHandler           /* DMA1 Stream 6                */\r\n  .word     ADC_IRQHandler                    /* ADC1, ADC2 and ADC3s         */\r\n  .word     FDCAN1_IT0_IRQHandler             /* FDCAN1 interrupt line 0      */\r\n  .word     FDCAN2_IT0_IRQHandler             /* FDCAN2 interrupt line 0      */\r\n  .word     FDCAN1_IT1_IRQHandler             /* FDCAN1 interrupt line 1      */\r\n  .word     FDCAN2_IT1_IRQHandler             /* FDCAN2 interrupt line 1      */\r\n  .word     EXTI9_5_IRQHandler                /* External Line[9:5]s          */\r\n  .word     TIM1_BRK_IRQHandler               /* TIM1 Break interrupt         */\r\n  .word     TIM1_UP_IRQHandler                /* TIM1 Update interrupt        */\r\n  .word     TIM1_TRG_COM_IRQHandler           /* TIM1 Trigger and Commutation interrupt */\r\n  .word     TIM1_CC_IRQHandler                /* TIM1 Capture Compare         */\r\n  .word     TIM2_IRQHandler                   /* TIM2                         */\r\n  .word     TIM3_IRQHandler                   /* TIM3                         */\r\n  .word     TIM4_IRQHandler                   /* TIM4                         */\r\n  .word     I2C1_EV_IRQHandler                /* I2C1 Event                   */\r\n  .word     I2C1_ER_IRQHandler                /* I2C1 Error                   */\r\n  .word     I2C2_EV_IRQHandler                /* I2C2 Event                   */\r\n  .word     I2C2_ER_IRQHandler                /* I2C2 Error                   */\r\n  .word     SPI1_IRQHandler                   /* SPI1                         */\r\n  .word     SPI2_IRQHandler                   /* SPI2                         */\r\n  .word     USART1_IRQHandler                 /* USART1                       */\r\n  .word     USART2_IRQHandler                 /* USART2                       */\r\n  .word     USART3_IRQHandler                 /* USART3                       */\r\n  .word     EXTI15_10_IRQHandler              /* External Line[15:10]s        */\r\n  .word     RTC_Alarm_IRQHandler              /* RTC Alarm (A and B) through EXTI Line */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     TIM8_BRK_TIM12_IRQHandler         /* TIM8 Break and TIM12         */\r\n  .word     TIM8_UP_TIM13_IRQHandler          /* TIM8 Update and TIM13        */\r\n  .word     TIM8_TRG_COM_TIM14_IRQHandler     /* TIM8 Trigger and Commutation and TIM14 */\r\n  .word     TIM8_CC_IRQHandler                /* TIM8 Capture Compare         */\r\n  .word     DMA1_Stream7_IRQHandler           /* DMA1 Stream7                 */\r\n  .word     FMC_IRQHandler                    /* FMC                          */\r\n  .word     SDMMC1_IRQHandler                 /* SDMMC1                       */\r\n  .word     TIM5_IRQHandler                   /* TIM5                         */\r\n  .word     SPI3_IRQHandler                   /* SPI3                         */\r\n  .word     UART4_IRQHandler                  /* UART4                        */\r\n  .word     UART5_IRQHandler                  /* UART5                        */\r\n  .word     TIM6_DAC_IRQHandler               /* TIM6 and DAC1&2 underrun errors */\r\n  .word     TIM7_IRQHandler                   /* TIM7                         */\r\n  .word     DMA2_Stream0_IRQHandler           /* DMA2 Stream 0                */\r\n  .word     DMA2_Stream1_IRQHandler           /* DMA2 Stream 1                */\r\n  .word     DMA2_Stream2_IRQHandler           /* DMA2 Stream 2                */\r\n  .word     DMA2_Stream3_IRQHandler           /* DMA2 Stream 3                */\r\n  .word     DMA2_Stream4_IRQHandler           /* DMA2 Stream 4                */\r\n  .word     ETH_IRQHandler                    /* Ethernet                     */\r\n  .word     ETH_WKUP_IRQHandler               /* Ethernet Wakeup through EXTI line */\r\n  .word     FDCAN_CAL_IRQHandler              /* FDCAN calibration unit interrupt*/\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     0                                 /* Reserved                     */\r\n  .word     DMA2_Stream5_IRQHandler           /* DMA2 Stream 5                */\r\n  .word     DMA2_Stream6_IRQHandler           /* DMA2 Stream 6                */\r\n  .word     DMA2_Stream7_IRQHandler           /* DMA2 Stream 7                */\r\n  .word     USART6_IRQHandler                 /* USART6                       */\r\n  .word     I2C3_EV_IRQHandler                /* I2C3 event                   */\r\n  .word     I2C3_ER_IRQHandler                /* I2C3 error                   */\r\n  .word     OTG_HS_EP1_OUT_IRQHandler         /* USB OTG HS End Point 1 Out   */\r\n  .word     OTG_HS_EP1_IN_IRQHandler          /* USB OTG HS End Point 1 In    */\r\n  .word     OTG_HS_WKUP_IRQHandler            /* USB OTG HS Wakeup through EXTI */\r\n  .word     OTG_HS_IRQHandler                 /* USB OTG HS                   */\r\n  .word     DCMI_IRQHandler                   /* DCMI                         */\r\n  .word     CRYP_IRQHandler                   /* Crypto                       */\r\n  .word     HASH_RNG_IRQHandler               /* Hash and Rng                 */\r\n  .word     FPU_IRQHandler                    /* FPU                          */\r\n  .word     UART7_IRQHandler                  /* UART7                        */\r\n  .word     UART8_IRQHandler                  /* UART8                        */\r\n  .word     SPI4_IRQHandler                   /* SPI4                         */\r\n  .word     SPI5_IRQHandler                   /* SPI5                         */\r\n  .word     SPI6_IRQHandler                   /* SPI6                         */\r\n  .word     SAI1_IRQHandler                   /* SAI1                         */\r\n  .word     LTDC_IRQHandler                   /* LTDC                         */\r\n  .word     LTDC_ER_IRQHandler                /* LTDC error                   */\r\n  .word     DMA2D_IRQHandler                  /* DMA2D                        */\r\n  .word     SAI2_IRQHandler                   /* SAI2                         */\r\n  .word     QUADSPI_IRQHandler                /* QUADSPI                      */\r\n  .word     LPTIM1_IRQHandler                 /* LPTIM1                       */\r\n  .word     CEC_IRQHandler                    /* HDMI_CEC                     */\r\n  .word     I2C4_EV_IRQHandler                /* I2C4 Event                   */\r\n  .word     I2C4_ER_IRQHandler                /* I2C4 Error                   */\r\n  .word     SPDIF_RX_IRQHandler               /* SPDIF_RX                     */\r\n  .word     OTG_FS_EP1_OUT_IRQHandler         /* USB OTG FS End Point 1 Out   */\r\n  .word     OTG_FS_EP1_IN_IRQHandler          /* USB OTG FS End Point 1 In    */\r\n  .word     OTG_FS_WKUP_IRQHandler            /* USB OTG FS Wakeup through EXTI */\r\n  .word     OTG_FS_IRQHandler                 /* USB OTG FS                   */\r\n  .word     DMAMUX1_OVR_IRQHandler            /* DMAMUX1 Overrun interrupt    */\r\n  .word     HRTIM1_Master_IRQHandler          /* HRTIM Master Timer global Interrupt */\r\n  .word     HRTIM1_TIMA_IRQHandler            /* HRTIM Timer A global Interrupt */\r\n  .word     HRTIM1_TIMB_IRQHandler            /* HRTIM Timer B global Interrupt */\r\n  .word     HRTIM1_TIMC_IRQHandler            /* HRTIM Timer C global Interrupt */\r\n  .word     HRTIM1_TIMD_IRQHandler            /* HRTIM Timer D global Interrupt */\r\n  .word     HRTIM1_TIME_IRQHandler            /* HRTIM Timer E global Interrupt */\r\n  .word     HRTIM1_FLT_IRQHandler             /* HRTIM Fault global Interrupt   */\r\n  .word     DFSDM1_FLT0_IRQHandler            /* DFSDM Filter0 Interrupt        */\r\n  .word     DFSDM1_FLT1_IRQHandler            /* DFSDM Filter1 Interrupt        */\r\n  .word     DFSDM1_FLT2_IRQHandler            /* DFSDM Filter2 Interrupt        */\r\n  .word     DFSDM1_FLT3_IRQHandler            /* DFSDM Filter3 Interrupt        */\r\n  .word     SAI3_IRQHandler                   /* SAI3 global Interrupt          */\r\n  .word     SWPMI1_IRQHandler                 /* Serial Wire Interface 1 global interrupt */\r\n  .word     TIM15_IRQHandler                  /* TIM15 global Interrupt      */\r\n  .word     TIM16_IRQHandler                  /* TIM16 global Interrupt      */\r\n  .word     TIM17_IRQHandler                  /* TIM17 global Interrupt      */\r\n  .word     MDIOS_WKUP_IRQHandler             /* MDIOS Wakeup  Interrupt     */\r\n  .word     MDIOS_IRQHandler                  /* MDIOS global Interrupt      */\r\n  .word     JPEG_IRQHandler                   /* JPEG global Interrupt       */\r\n  .word     MDMA_IRQHandler                   /* MDMA global Interrupt       */\r\n  .word     0                                 /* Reserved                    */\r\n  .word     SDMMC2_IRQHandler                 /* SDMMC2 global Interrupt     */\r\n  .word     HSEM1_IRQHandler                  /* HSEM1 global Interrupt      */\r\n  .word     0                                 /* Reserved                    */\r\n  .word     ADC3_IRQHandler                   /* ADC3 global Interrupt       */\r\n  .word     DMAMUX2_OVR_IRQHandler            /* DMAMUX Overrun interrupt    */\r\n  .word     BDMA_Channel0_IRQHandler          /* BDMA Channel 0 global Interrupt */\r\n  .word     BDMA_Channel1_IRQHandler          /* BDMA Channel 1 global Interrupt */\r\n  .word     BDMA_Channel2_IRQHandler          /* BDMA Channel 2 global Interrupt */\r\n  .word     BDMA_Channel3_IRQHandler          /* BDMA Channel 3 global Interrupt */\r\n  .word     BDMA_Channel4_IRQHandler          /* BDMA Channel 4 global Interrupt */\r\n  .word     BDMA_Channel5_IRQHandler          /* BDMA Channel 5 global Interrupt */\r\n  .word     BDMA_Channel6_IRQHandler          /* BDMA Channel 6 global Interrupt */\r\n  .word     BDMA_Channel7_IRQHandler          /* BDMA Channel 7 global Interrupt */\r\n  .word     COMP1_IRQHandler                  /* COMP1 global Interrupt     */\r\n  .word     LPTIM2_IRQHandler                 /* LP TIM2 global interrupt   */\r\n  .word     LPTIM3_IRQHandler                 /* LP TIM3 global interrupt   */\r\n  .word     LPTIM4_IRQHandler                 /* LP TIM4 global interrupt   */\r\n  .word     LPTIM5_IRQHandler                 /* LP TIM5 global interrupt   */\r\n  .word     LPUART1_IRQHandler                /* LP UART1 interrupt         */\r\n  .word     0                                 /* Reserved                   */\r\n  .word     CRS_IRQHandler                    /* Clock Recovery Global Interrupt */\r\n  .word     ECC_IRQHandler                    /* ECC diagnostic Global Interrupt */\r\n  .word     SAI4_IRQHandler                   /* SAI4 global interrupt      */\r\n  .word     0                                 /* Reserved                   */\r\n  .word     0                                 /* Reserved                   */\r\n  .word     WAKEUP_PIN_IRQHandler             /* Interrupt for all 6 wake-up pins */\r\n\r\n/*******************************************************************************\r\n*\r\n* Provide weak aliases for each Exception handler to the Default_Handler.\r\n* As they are weak aliases, any function with the same name will override\r\n* this definition.\r\n*\r\n*******************************************************************************/\r\n   .weak      NMI_Handler\r\n   .thumb_set NMI_Handler,Default_Handler\r\n\r\n   .weak      HardFault_Handler\r\n   .thumb_set HardFault_Handler,Default_Handler\r\n\r\n   .weak      MemManage_Handler\r\n   .thumb_set MemManage_Handler,Default_Handler\r\n\r\n   .weak      BusFault_Handler\r\n   .thumb_set BusFault_Handler,Default_Handler\r\n\r\n   .weak      UsageFault_Handler\r\n   .thumb_set UsageFault_Handler,Default_Handler\r\n\r\n   .weak      SVC_Handler\r\n   .thumb_set SVC_Handler,Default_Handler\r\n\r\n   .weak      DebugMon_Handler\r\n   .thumb_set DebugMon_Handler,Default_Handler\r\n\r\n   .weak      PendSV_Handler\r\n   .thumb_set PendSV_Handler,Default_Handler\r\n\r\n   .weak      SysTick_Handler\r\n   .thumb_set SysTick_Handler,Default_Handler\r\n\r\n   .weak      WWDG_IRQHandler\r\n   .thumb_set WWDG_IRQHandler,Default_Handler\r\n\r\n   .weak      PVD_AVD_IRQHandler\r\n   .thumb_set PVD_AVD_IRQHandler,Default_Handler\r\n\r\n   .weak      TAMP_STAMP_IRQHandler\r\n   .thumb_set TAMP_STAMP_IRQHandler,Default_Handler\r\n\r\n   .weak      RTC_WKUP_IRQHandler\r\n   .thumb_set RTC_WKUP_IRQHandler,Default_Handler\r\n\r\n   .weak      FLASH_IRQHandler\r\n   .thumb_set FLASH_IRQHandler,Default_Handler\r\n\r\n   .weak      RCC_IRQHandler\r\n   .thumb_set RCC_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI0_IRQHandler\r\n   .thumb_set EXTI0_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI1_IRQHandler\r\n   .thumb_set EXTI1_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI2_IRQHandler\r\n   .thumb_set EXTI2_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI3_IRQHandler\r\n   .thumb_set EXTI3_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI4_IRQHandler\r\n   .thumb_set EXTI4_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream0_IRQHandler\r\n   .thumb_set DMA1_Stream0_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream1_IRQHandler\r\n   .thumb_set DMA1_Stream1_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream2_IRQHandler\r\n   .thumb_set DMA1_Stream2_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream3_IRQHandler\r\n   .thumb_set DMA1_Stream3_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream4_IRQHandler\r\n   .thumb_set DMA1_Stream4_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream5_IRQHandler\r\n   .thumb_set DMA1_Stream5_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream6_IRQHandler\r\n   .thumb_set DMA1_Stream6_IRQHandler,Default_Handler\r\n\r\n   .weak      ADC_IRQHandler\r\n   .thumb_set ADC_IRQHandler,Default_Handler\r\n\r\n   .weak      FDCAN1_IT0_IRQHandler\r\n   .thumb_set FDCAN1_IT0_IRQHandler,Default_Handler\r\n\r\n   .weak      FDCAN2_IT0_IRQHandler\r\n   .thumb_set FDCAN2_IT0_IRQHandler,Default_Handler\r\n\r\n   .weak      FDCAN1_IT1_IRQHandler\r\n   .thumb_set FDCAN1_IT1_IRQHandler,Default_Handler\r\n\r\n   .weak      FDCAN2_IT1_IRQHandler\r\n   .thumb_set FDCAN2_IT1_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI9_5_IRQHandler\r\n   .thumb_set EXTI9_5_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM1_BRK_IRQHandler\r\n   .thumb_set TIM1_BRK_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM1_UP_IRQHandler\r\n   .thumb_set TIM1_UP_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM1_TRG_COM_IRQHandler\r\n   .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM1_CC_IRQHandler\r\n   .thumb_set TIM1_CC_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM2_IRQHandler\r\n   .thumb_set TIM2_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM3_IRQHandler\r\n   .thumb_set TIM3_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM4_IRQHandler\r\n   .thumb_set TIM4_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C1_EV_IRQHandler\r\n   .thumb_set I2C1_EV_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C1_ER_IRQHandler\r\n   .thumb_set I2C1_ER_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C2_EV_IRQHandler\r\n   .thumb_set I2C2_EV_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C2_ER_IRQHandler\r\n   .thumb_set I2C2_ER_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI1_IRQHandler\r\n   .thumb_set SPI1_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI2_IRQHandler\r\n   .thumb_set SPI2_IRQHandler,Default_Handler\r\n\r\n   .weak      USART1_IRQHandler\r\n   .thumb_set USART1_IRQHandler,Default_Handler\r\n\r\n   .weak      USART2_IRQHandler\r\n   .thumb_set USART2_IRQHandler,Default_Handler\r\n\r\n   .weak      USART3_IRQHandler\r\n   .thumb_set USART3_IRQHandler,Default_Handler\r\n\r\n   .weak      EXTI15_10_IRQHandler\r\n   .thumb_set EXTI15_10_IRQHandler,Default_Handler\r\n\r\n   .weak      RTC_Alarm_IRQHandler\r\n   .thumb_set RTC_Alarm_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM8_BRK_TIM12_IRQHandler\r\n   .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM8_UP_TIM13_IRQHandler\r\n   .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM8_TRG_COM_TIM14_IRQHandler\r\n   .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM8_CC_IRQHandler\r\n   .thumb_set TIM8_CC_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA1_Stream7_IRQHandler\r\n   .thumb_set DMA1_Stream7_IRQHandler,Default_Handler\r\n\r\n   .weak      FMC_IRQHandler\r\n   .thumb_set FMC_IRQHandler,Default_Handler\r\n\r\n   .weak      SDMMC1_IRQHandler\r\n   .thumb_set SDMMC1_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM5_IRQHandler\r\n   .thumb_set TIM5_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI3_IRQHandler\r\n   .thumb_set SPI3_IRQHandler,Default_Handler\r\n\r\n   .weak      UART4_IRQHandler\r\n   .thumb_set UART4_IRQHandler,Default_Handler\r\n\r\n   .weak      UART5_IRQHandler\r\n   .thumb_set UART5_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM6_DAC_IRQHandler\r\n   .thumb_set TIM6_DAC_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM7_IRQHandler\r\n   .thumb_set TIM7_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream0_IRQHandler\r\n   .thumb_set DMA2_Stream0_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream1_IRQHandler\r\n   .thumb_set DMA2_Stream1_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream2_IRQHandler\r\n   .thumb_set DMA2_Stream2_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream3_IRQHandler\r\n   .thumb_set DMA2_Stream3_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream4_IRQHandler\r\n   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler\r\n\r\n   .weak      ETH_IRQHandler\r\n   .thumb_set ETH_IRQHandler,Default_Handler\r\n\r\n   .weak      ETH_WKUP_IRQHandler\r\n   .thumb_set ETH_WKUP_IRQHandler,Default_Handler\r\n\r\n   .weak      FDCAN_CAL_IRQHandler\r\n   .thumb_set FDCAN_CAL_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream5_IRQHandler\r\n   .thumb_set DMA2_Stream5_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream6_IRQHandler\r\n   .thumb_set DMA2_Stream6_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2_Stream7_IRQHandler\r\n   .thumb_set DMA2_Stream7_IRQHandler,Default_Handler\r\n\r\n   .weak      USART6_IRQHandler\r\n   .thumb_set USART6_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C3_EV_IRQHandler\r\n   .thumb_set I2C3_EV_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C3_ER_IRQHandler\r\n   .thumb_set I2C3_ER_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_HS_EP1_OUT_IRQHandler\r\n   .thumb_set OTG_HS_EP1_OUT_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_HS_EP1_IN_IRQHandler\r\n   .thumb_set OTG_HS_EP1_IN_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_HS_WKUP_IRQHandler\r\n   .thumb_set OTG_HS_WKUP_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_HS_IRQHandler\r\n   .thumb_set OTG_HS_IRQHandler,Default_Handler\r\n\r\n   .weak      DCMI_IRQHandler\r\n   .thumb_set DCMI_IRQHandler,Default_Handler\r\n\r\n   .weak      CRYP_IRQHandler\r\n   .thumb_set CRYP_IRQHandler,Default_Handler\r\n\r\n   .weak      HASH_RNG_IRQHandler\r\n   .thumb_set HASH_RNG_IRQHandler,Default_Handler\r\n\r\n   .weak      FPU_IRQHandler\r\n   .thumb_set FPU_IRQHandler,Default_Handler\r\n\r\n   .weak      UART7_IRQHandler\r\n   .thumb_set UART7_IRQHandler,Default_Handler\r\n\r\n   .weak      UART8_IRQHandler\r\n   .thumb_set UART8_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI4_IRQHandler\r\n   .thumb_set SPI4_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI5_IRQHandler\r\n   .thumb_set SPI5_IRQHandler,Default_Handler\r\n\r\n   .weak      SPI6_IRQHandler\r\n   .thumb_set SPI6_IRQHandler,Default_Handler\r\n\r\n   .weak      SAI1_IRQHandler\r\n   .thumb_set SAI1_IRQHandler,Default_Handler\r\n\r\n   .weak      LTDC_IRQHandler\r\n   .thumb_set LTDC_IRQHandler,Default_Handler\r\n\r\n   .weak      LTDC_ER_IRQHandler\r\n   .thumb_set LTDC_ER_IRQHandler,Default_Handler\r\n\r\n   .weak      DMA2D_IRQHandler\r\n   .thumb_set DMA2D_IRQHandler,Default_Handler\r\n\r\n   .weak      SAI2_IRQHandler\r\n   .thumb_set SAI2_IRQHandler,Default_Handler\r\n\r\n   .weak      QUADSPI_IRQHandler\r\n   .thumb_set QUADSPI_IRQHandler,Default_Handler\r\n\r\n   .weak      LPTIM1_IRQHandler\r\n   .thumb_set LPTIM1_IRQHandler,Default_Handler\r\n\r\n   .weak      CEC_IRQHandler\r\n   .thumb_set CEC_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C4_EV_IRQHandler\r\n   .thumb_set I2C4_EV_IRQHandler,Default_Handler\r\n\r\n   .weak      I2C4_ER_IRQHandler\r\n   .thumb_set I2C4_ER_IRQHandler,Default_Handler\r\n\r\n   .weak      SPDIF_RX_IRQHandler\r\n   .thumb_set SPDIF_RX_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_FS_EP1_OUT_IRQHandler\r\n   .thumb_set OTG_FS_EP1_OUT_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_FS_EP1_IN_IRQHandler\r\n   .thumb_set OTG_FS_EP1_IN_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_FS_WKUP_IRQHandler\r\n   .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler\r\n\r\n   .weak      OTG_FS_IRQHandler\r\n   .thumb_set OTG_FS_IRQHandler,Default_Handler\r\n\r\n   .weak      DMAMUX1_OVR_IRQHandler\r\n   .thumb_set DMAMUX1_OVR_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_Master_IRQHandler\r\n   .thumb_set HRTIM1_Master_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_TIMA_IRQHandler\r\n   .thumb_set HRTIM1_TIMA_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_TIMB_IRQHandler\r\n   .thumb_set HRTIM1_TIMB_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_TIMC_IRQHandler\r\n   .thumb_set HRTIM1_TIMC_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_TIMD_IRQHandler\r\n   .thumb_set HRTIM1_TIMD_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_TIME_IRQHandler\r\n   .thumb_set HRTIM1_TIME_IRQHandler,Default_Handler\r\n\r\n   .weak      HRTIM1_FLT_IRQHandler\r\n   .thumb_set HRTIM1_FLT_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT0_IRQHandler\r\n   .thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT1_IRQHandler\r\n   .thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT2_IRQHandler\r\n   .thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler\r\n\r\n   .weak      DFSDM1_FLT3_IRQHandler\r\n   .thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler\r\n\r\n   .weak      SAI3_IRQHandler\r\n   .thumb_set SAI3_IRQHandler,Default_Handler\r\n\r\n   .weak      SWPMI1_IRQHandler\r\n   .thumb_set SWPMI1_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM15_IRQHandler\r\n   .thumb_set TIM15_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM16_IRQHandler\r\n   .thumb_set TIM16_IRQHandler,Default_Handler\r\n\r\n   .weak      TIM17_IRQHandler\r\n   .thumb_set TIM17_IRQHandler,Default_Handler\r\n\r\n   .weak      MDIOS_WKUP_IRQHandler\r\n   .thumb_set MDIOS_WKUP_IRQHandler,Default_Handler\r\n\r\n   .weak      MDIOS_IRQHandler\r\n   .thumb_set MDIOS_IRQHandler,Default_Handler\r\n\r\n   .weak      JPEG_IRQHandler\r\n   .thumb_set JPEG_IRQHandler,Default_Handler\r\n\r\n   .weak      MDMA_IRQHandler\r\n   .thumb_set MDMA_IRQHandler,Default_Handler\r\n\r\n   .weak      SDMMC2_IRQHandler\r\n   .thumb_set SDMMC2_IRQHandler,Default_Handler\r\n\r\n   .weak      HSEM1_IRQHandler\r\n   .thumb_set HSEM1_IRQHandler,Default_Handler\r\n\r\n   .weak      ADC3_IRQHandler\r\n   .thumb_set ADC3_IRQHandler,Default_Handler\r\n\r\n   .weak      DMAMUX2_OVR_IRQHandler\r\n   .thumb_set DMAMUX2_OVR_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel0_IRQHandler\r\n   .thumb_set BDMA_Channel0_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel1_IRQHandler\r\n   .thumb_set BDMA_Channel1_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel2_IRQHandler\r\n   .thumb_set BDMA_Channel2_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel3_IRQHandler\r\n   .thumb_set BDMA_Channel3_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel4_IRQHandler\r\n   .thumb_set BDMA_Channel4_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel5_IRQHandler\r\n   .thumb_set BDMA_Channel5_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel6_IRQHandler\r\n   .thumb_set BDMA_Channel6_IRQHandler,Default_Handler\r\n\r\n   .weak      BDMA_Channel7_IRQHandler\r\n   .thumb_set BDMA_Channel7_IRQHandler,Default_Handler\r\n\r\n   .weak      COMP1_IRQHandler\r\n   .thumb_set COMP1_IRQHandler,Default_Handler\r\n\r\n   .weak      LPTIM2_IRQHandler\r\n   .thumb_set LPTIM2_IRQHandler,Default_Handler\r\n\r\n   .weak      LPTIM3_IRQHandler\r\n   .thumb_set LPTIM3_IRQHandler,Default_Handler\r\n\r\n   .weak      LPTIM4_IRQHandler\r\n   .thumb_set LPTIM4_IRQHandler,Default_Handler\r\n\r\n   .weak      LPTIM5_IRQHandler\r\n   .thumb_set LPTIM5_IRQHandler,Default_Handler\r\n\r\n   .weak      LPUART1_IRQHandler\r\n   .thumb_set LPUART1_IRQHandler,Default_Handler\r\n\r\n   .weak      CRS_IRQHandler\r\n   .thumb_set CRS_IRQHandler,Default_Handler\r\n\r\n   .weak      ECC_IRQHandler\r\n   .thumb_set ECC_IRQHandler,Default_Handler\r\n\r\n   .weak      SAI4_IRQHandler\r\n   .thumb_set SAI4_IRQHandler,Default_Handler\r\n\r\n   .weak      WAKEUP_PIN_IRQHandler\r\n   .thumb_set WAKEUP_PIN_IRQHandler,Default_Handler\r\n\r\n\r\n"},{"name":"stm32h7xx_hal.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal.c\r\n  * @author  MCD Application Team\r\n  * @brief   HAL module driver.\r\n  *          This is the common part of the HAL initialization\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n    The common HAL driver contains a set of generic and common APIs that can be\r\n    used by the PPP peripheral drivers and the user to start using the HAL.\r\n    [..]\r\n    The HAL contains two APIs' categories:\r\n         (+) Common HAL APIs\r\n         (+) Services HAL APIs\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HAL  HAL\r\n  * @brief HAL module driver.\r\n  * @{\r\n  */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/**\r\n * @brief STM32H7xx HAL Driver version number V1.10.1\r\n   */\r\n#define __STM32H7xx_HAL_VERSION_MAIN   (0x01UL) /*!< [31:24] main version */\r\n#define __STM32H7xx_HAL_VERSION_SUB1   (0x0AUL) /*!< [23:16] sub1 version */\r\n#define __STM32H7xx_HAL_VERSION_SUB2   (0x01UL) /*!< [15:8]  sub2 version */\r\n#define __STM32H7xx_HAL_VERSION_RC     (0x00UL) /*!< [7:0]  release candidate */\r\n#define __STM32H7xx_HAL_VERSION         ((__STM32H7xx_HAL_VERSION_MAIN << 24)\\\r\n                                        |(__STM32H7xx_HAL_VERSION_SUB1 << 16)\\\r\n                                        |(__STM32H7xx_HAL_VERSION_SUB2 << 8 )\\\r\n                                        |(__STM32H7xx_HAL_VERSION_RC))\r\n\r\n#define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)\r\n#define VREFBUF_TIMEOUT_VALUE     (uint32_t)10   /* 10 ms  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Exported variables --------------------------------------------------------*/\r\n\r\n/** @defgroup HAL_Exported_Variables HAL Exported Variables\r\n  * @{\r\n  */\r\n__IO uint32_t uwTick;\r\nuint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */\r\nHAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup HAL_Private_Functions  HAL Private Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HAL_Group1 Initialization and de-initialization Functions\r\n *  @brief    Initialization and de-initialization functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Initializes the Flash interface the NVIC allocation and initial clock\r\n          configuration. It initializes the systick also when timeout is needed\r\n          and the backup domain when enabled.\r\n      (+) De-Initializes common part of the HAL.\r\n      (+) Configure The time base source to have 1ms time base with a dedicated\r\n          Tick interrupt priority.\r\n        (++) SysTick timer is used by default as source of time base, but user\r\n             can eventually implement his proper time base source (a general purpose\r\n             timer for example or other time source), keeping in mind that Time base\r\n             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and\r\n             handled in milliseconds basis.\r\n        (++) Time base configuration function (HAL_InitTick ()) is called automatically\r\n             at the beginning of the program after reset by HAL_Init() or at any time\r\n             when clock is configured, by HAL_RCC_ClockConfig().\r\n        (++) Source of time base is configured  to generate interrupts at regular\r\n             time intervals. Care must be taken if HAL_Delay() is called from a\r\n             peripheral ISR process, the Tick interrupt line must have higher priority\r\n            (numerically lower) than the peripheral interrupt. Otherwise the caller\r\n            ISR process will be blocked.\r\n       (++) functions affecting time base configurations are declared as __weak\r\n             to make  override possible  in case of other  implementations in user file.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function is used to initialize the HAL Library; it must be the first\r\n  *         instruction to be executed in the main program (before to call any other\r\n  *         HAL function), it performs the following:\r\n  *           Configures the SysTick to generate an interrupt each 1 millisecond,\r\n  *           which is clocked by the HSI (at this stage, the clock is not yet\r\n  *           configured and thus the system is running from the internal HSI at 16 MHz).\r\n  *           Set NVIC Group Priority to 4.\r\n  *           Calls the HAL_MspInit() callback function defined in user file\r\n  *           \"stm32h7xx_hal_msp.c\" to do the global low level hardware initialization\r\n  *\r\n  * @note   SysTick is used as time base for the HAL_Delay() function, the application\r\n  *         need to ensure that the SysTick time base is always set to 1 millisecond\r\n  *         to have correct HAL operation.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_Init(void)\r\n{\r\n\r\nuint32_t common_system_clock;\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n   /* Configure Cortex-M4 Instruction cache through ART accelerator */\r\n   __HAL_RCC_ART_CLK_ENABLE();                   /* Enable the Cortex-M4 ART Clock */\r\n   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */\r\n   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */\r\n#endif /* DUAL_CORE &&  CORE_CM4 */\r\n\r\n  /* Set Interrupt Group Priority */\r\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\r\n\r\n  /* Update the SystemCoreClock global variable */\r\n#if defined(RCC_D1CFGR_D1CPRE)\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);\r\n#else\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);\r\n#endif\r\n\r\n  /* Update the SystemD2Clock global variable */\r\n#if defined(RCC_D1CFGR_HPRE)\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\r\n#else\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\r\n#endif\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  SystemCoreClock = SystemD2Clock;\r\n#else\r\n  SystemCoreClock = common_system_clock;\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n\r\n  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */\r\n  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Init the low level hardware */\r\n  HAL_MspInit();\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function de-Initializes common part of the HAL and stops the systick.\r\n  *         This function is optional.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DeInit(void)\r\n{\r\n  /* Reset of all peripherals */\r\n  __HAL_RCC_AHB3_FORCE_RESET();\r\n  __HAL_RCC_AHB3_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB1_FORCE_RESET();\r\n  __HAL_RCC_AHB1_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB2_FORCE_RESET();\r\n  __HAL_RCC_AHB2_RELEASE_RESET();\r\n\r\n  __HAL_RCC_AHB4_FORCE_RESET();\r\n __HAL_RCC_AHB4_RELEASE_RESET();\r\n\r\n  __HAL_RCC_APB3_FORCE_RESET();\r\n  __HAL_RCC_APB3_RELEASE_RESET();\r\n\r\n  __HAL_RCC_APB1L_FORCE_RESET();\r\n  __HAL_RCC_APB1L_RELEASE_RESET();\r\n\r\n  __HAL_RCC_APB1H_FORCE_RESET();\r\n  __HAL_RCC_APB1H_RELEASE_RESET();\r\n\r\n   __HAL_RCC_APB2_FORCE_RESET();\r\n   __HAL_RCC_APB2_RELEASE_RESET();\r\n\r\n  __HAL_RCC_APB4_FORCE_RESET();\r\n  __HAL_RCC_APB4_RELEASE_RESET();\r\n\r\n  /* De-Init the low level hardware */\r\n  HAL_MspDeInit();\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the MSP.\r\n  * @retval None\r\n  */\r\n__weak void HAL_MspInit(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the MSP.\r\n  * @retval None\r\n  */\r\n__weak void HAL_MspDeInit(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief This function configures the source of the time base.\r\n  *        The time source is configured  to have 1ms time base with a dedicated\r\n  *        Tick interrupt priority.\r\n  * @note This function is called  automatically at the beginning of program after\r\n  *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().\r\n  * @note In the default implementation, SysTick timer is the source of time base.\r\n  *       It is used to generate interrupts at regular time intervals.\r\n  *       Care must be taken if HAL_Delay() is called from a peripheral ISR process,\r\n  *       The the SysTick interrupt must have higher priority (numerically lower)\r\n  *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.\r\n  *       The function is declared as __weak  to be overwritten  in case of other\r\n  *       implementation  in user file.\r\n  * @param TickPriority: Tick interrupt priority.\r\n  * @retval HAL status\r\n  */\r\n__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\r\n{\r\n  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/\r\n  if((uint32_t)uwTickFreq == 0UL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n    /* Configure the SysTick to have interrupt in 1ms time basis*/\r\n    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n  /* Configure the SysTick IRQ priority */\r\n  if (TickPriority < (1UL << __NVIC_PRIO_BITS))\r\n  {\r\n    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);\r\n    uwTickPrio = TickPriority;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup HAL_Group2 HAL Control functions\r\n *  @brief    HAL Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### HAL Control functions #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Provide a tick value in millisecond\r\n      (+) Provide a blocking delay in millisecond\r\n      (+) Suspend the time base source interrupt\r\n      (+) Resume the time base source interrupt\r\n      (+) Get the HAL API driver version\r\n      (+) Get the device identifier\r\n      (+) Get the device revision identifier\r\n      (+) Enable/Disable Debug module during SLEEP mode\r\n      (+) Enable/Disable Debug module during STOP mode\r\n      (+) Enable/Disable Debug module during STANDBY mode\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief This function is called to increment  a global variable \"uwTick\"\r\n  *        used as application time base.\r\n  * @note In the default implementation, this variable is incremented each 1ms\r\n  *       in Systick ISR.\r\n * @note This function is declared as __weak to be overwritten in case of other\r\n  *      implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_IncTick(void)\r\n{\r\n  uwTick += (uint32_t)uwTickFreq;\r\n}\r\n\r\n/**\r\n  * @brief Provides a tick value in millisecond.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval tick value\r\n  */\r\n__weak uint32_t HAL_GetTick(void)\r\n{\r\n  return uwTick;\r\n}\r\n\r\n/**\r\n  * @brief This function returns a tick priority.\r\n  * @retval tick priority\r\n  */\r\nuint32_t HAL_GetTickPrio(void)\r\n{\r\n  return uwTickPrio;\r\n}\r\n\r\n/**\r\n  * @brief Set new tick Freq.\r\n  * @retval Status\r\n  */\r\nHAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\r\n{\r\n  HAL_StatusTypeDef status  = HAL_OK;\r\n  HAL_TickFreqTypeDef prevTickFreq;\r\n\r\n  assert_param(IS_TICKFREQ(Freq));\r\n\r\n  if (uwTickFreq != Freq)\r\n  {\r\n\r\n    /* Back up uwTickFreq frequency */\r\n    prevTickFreq = uwTickFreq;\r\n\r\n    /* Update uwTickFreq global variable used by HAL_InitTick() */\r\n    uwTickFreq = Freq;\r\n\r\n    /* Apply the new tick Freq  */\r\n    status = HAL_InitTick(uwTickPrio);\r\n    if (status != HAL_OK)\r\n    {\r\n      /* Restore previous tick frequency */\r\n      uwTickFreq = prevTickFreq;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Return tick frequency.\r\n  * @retval tick period in Hz\r\n  */\r\nHAL_TickFreqTypeDef HAL_GetTickFreq(void)\r\n{\r\n  return uwTickFreq;\r\n}\r\n\r\n/**\r\n  * @brief This function provides minimum delay (in milliseconds) based\r\n  *        on variable incremented.\r\n  * @note In the default implementation , SysTick timer is the source of time base.\r\n  *       It is used to generate interrupts at regular time intervals where uwTick\r\n  *       is incremented.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @param Delay  specifies the delay time length, in milliseconds.\r\n  * @retval None\r\n  */\r\n__weak void HAL_Delay(uint32_t Delay)\r\n{\r\n  uint32_t tickstart = HAL_GetTick();\r\n  uint32_t wait = Delay;\r\n\r\n  /* Add a freq to guarantee minimum wait */\r\n  if (wait < HAL_MAX_DELAY)\r\n  {\r\n    wait += (uint32_t)(uwTickFreq);\r\n  }\r\n\r\n  while ((HAL_GetTick() - tickstart) < wait)\r\n  {\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Suspend Tick increment.\r\n  * @note In the default implementation , SysTick timer is the source of time base. It is\r\n  *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()\r\n  *       is called, the the SysTick interrupt will be disabled and so Tick increment\r\n  *       is suspended.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SuspendTick(void)\r\n{\r\n  /* Disable SysTick Interrupt */\r\n  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;\r\n}\r\n\r\n/**\r\n  * @brief Resume Tick increment.\r\n  * @note In the default implementation , SysTick timer is the source of time base. It is\r\n  *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()\r\n  *       is called, the the SysTick interrupt will be enabled and so Tick increment\r\n  *       is resumed.\r\n  * @note This function is declared as __weak to be overwritten in case of other\r\n  *       implementations in user file.\r\n  * @retval None\r\n  */\r\n__weak void HAL_ResumeTick(void)\r\n{\r\n  /* Enable SysTick Interrupt */\r\n  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the HAL revision\r\n  * @retval version : 0xXYZR (8bits for each decimal, R for RC)\r\n  */\r\nuint32_t HAL_GetHalVersion(void)\r\n{\r\n return __STM32H7xx_HAL_VERSION;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the device revision identifier.\r\n  * @retval Device revision identifier\r\n  */\r\nuint32_t HAL_GetREVID(void)\r\n{\r\n   return((DBGMCU->IDCODE) >> 16);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the device identifier.\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetDEVID(void)\r\n{\r\n   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);\r\n}\r\n\r\n/**\r\n  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw0(void)\r\n{\r\n  return(READ_REG(*((uint32_t *)UID_BASE)));\r\n}\r\n\r\n/**\r\n  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw1(void)\r\n{\r\n  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\r\n}\r\n\r\n/**\r\n  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)\r\n  * @retval Device identifier\r\n  */\r\nuint32_t HAL_GetUIDw2(void)\r\n{\r\n  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\r\n}\r\n\r\n/**\r\n  * @brief Configure the internal voltage reference buffer voltage scale.\r\n  * @param VoltageScaling  specifies the output voltage to achieve\r\n  *          This parameter can be one of the following values:\r\n  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE0: VREF_OUT1 around 2.5 V.\r\n  *                                                This requires VDDA equal to or higher than 2.8 V.\r\n  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE1: VREF_OUT2 around 2.048 V.\r\n  *                                                This requires VDDA equal to or higher than 2.4 V.\r\n  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE2: VREF_OUT3 around 1.8 V.\r\n  *                                                This requires VDDA equal to or higher than 2.1 V.\r\n  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.5 V.\r\n  *                                                This requires VDDA equal to or higher than 1.8 V.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));\r\n\r\n  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);\r\n}\r\n\r\n/**\r\n  * @brief Configure the internal voltage reference buffer high impedance mode.\r\n  * @param Mode  specifies the high impedance mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.\r\n  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));\r\n\r\n  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);\r\n}\r\n\r\n/**\r\n  * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));\r\n\r\n  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).\r\n  * @retval HAL_OK/HAL_TIMEOUT\r\n  */\r\nHAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)\r\n{\r\n  uint32_t  tickstart;\r\n\r\n  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);\r\n\r\n  /* Get Start Tick*/\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait for VRR bit  */\r\n  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)\r\n  {\r\n    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_DisableVREFBUF(void)\r\n{\r\n  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);\r\n}\r\n\r\n#if defined(SYSCFG_PMCR_EPIS_SEL)\r\n/**\r\n  * @brief  Ethernet PHY Interface Selection either MII or RMII\r\n  * @param  SYSCFG_ETHInterface: Selects the Ethernet PHY interface\r\n  *   This parameter can be one of the following values:\r\n  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface\r\n  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));\r\n\r\n  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));\r\n}\r\n#endif /* SYSCFG_PMCR_EPIS_SEL */\r\n\r\n/**\r\n  * @brief  Analog Switch control for dual analog pads.\r\n  * @param  SYSCFG_AnalogSwitch: Selects the analog pad\r\n  *   This parameter can be one or a combination of the following values:\r\n  *   @arg SYSCFG_SWITCH_PA0 : Select PA0 analog switch\r\n  *   @arg SYSCFG_SWITCH_PA1:  Select PA1 analog switch\r\n  *   @arg SYSCFG_SWITCH_PC2 : Select PC2 analog switch\r\n  *   @arg SYSCFG_SWITCH_PC3:  Select PC3 analog switch\r\n  * @param  SYSCFG_SwitchState: Open or Close the analog switch between dual pads (PXn and PXn_C)\r\n  *   This parameter can be one or a combination of the following values:\r\n  *   @arg SYSCFG_SWITCH_PA0_OPEN\r\n  *   @arg SYSCFG_SWITCH_PA0_CLOSE\r\n  *   @arg SYSCFG_SWITCH_PA1_OPEN\r\n  *   @arg SYSCFG_SWITCH_PA1_CLOSE\r\n  *   @arg SYSCFG_SWITCH_PC2_OPEN\r\n  *   @arg SYSCFG_SWITCH_PC2_CLOSE\r\n  *   @arg SYSCFG_SWITCH_PC3_OPEN\r\n  *   @arg SYSCFG_SWITCH_PC3_CLOSE\r\n  * @retval None\r\n  */\r\n\r\nvoid HAL_SYSCFG_AnalogSwitchConfig(uint32_t SYSCFG_AnalogSwitch , uint32_t SYSCFG_SwitchState )\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));\r\n  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));\r\n\r\n  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));\r\n}\r\n\r\n#if defined(SYSCFG_PMCR_BOOSTEN)\r\n/**\r\n  * @brief  Enables the booster to reduce the total harmonic distortion of the analog\r\n  *         switch when the supply voltage is lower than 2.7 V.\r\n  * @note   Activating the booster allows to guaranty the analog switch AC performance\r\n  *         when the supply voltage is below 2.7 V: in this case, the analog switch\r\n  *         performance is the same on the full voltage range\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_EnableBOOST(void)\r\n{\r\n SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;\r\n}\r\n\r\n/**\r\n  * @brief  Disables the booster\r\n  * @note   Activating the booster allows to guaranty the analog switch AC performance\r\n  *         when the supply voltage is below 2.7 V: in this case, the analog switch\r\n  *         performance is the same on the full voltage range\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_DisableBOOST(void)\r\n{\r\n CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;\r\n}\r\n#endif /* SYSCFG_PMCR_BOOSTEN */\r\n\r\n#if defined (SYSCFG_UR2_BOOT_ADD0) ||  defined (SYSCFG_UR2_BCM7_ADD0)\r\n/**\r\n  * @brief  BootCM7 address 0 configuration\r\n  * @param  BootRegister :Specifies the Boot Address register (Address0 or Address1)\r\n  *   This parameter can be one of the following values:\r\n  *   @arg SYSCFG_BOOT_ADDR0 : Select the boot address0\r\n  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1\r\n  * @param  BootAddress :Specifies the CM7 Boot Address to be loaded in Address0 or Address1\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_CM7BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));\r\n  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));\r\n  if ( BootRegister == SYSCFG_BOOT_ADDR0 )\r\n  {\r\n    /* Configure CM7 BOOT ADD0 */\r\n#if defined(DUAL_CORE)\r\n    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));\r\n#else\r\n    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));\r\n#endif /*DUAL_CORE*/\r\n  }\r\n  else\r\n  {\r\n    /* Configure CM7 BOOT ADD1 */\r\n#if defined(DUAL_CORE)\r\n    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));\r\n#else\r\n    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));\r\n#endif /*DUAL_CORE*/\r\n  }\r\n}\r\n#endif /* SYSCFG_UR2_BOOT_ADD0 || SYSCFG_UR2_BCM7_ADD0 */\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  BootCM4 address 0 configuration\r\n  * @param  BootRegister :Specifies the Boot Address register (Address0 or Address1)\r\n  *   This parameter can be one of the following values:\r\n  *   @arg SYSCFG_BOOT_ADDR0 : Select the boot address0\r\n  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1\r\n  * @param  BootAddress :Specifies the CM4 Boot Address to be loaded in Address0 or Address1\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_CM4BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));\r\n  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));\r\n\r\n  if ( BootRegister == SYSCFG_BOOT_ADDR0 )\r\n  {\r\n    /* Configure CM4 BOOT ADD0 */\r\n    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM4_ADD0, ((BootAddress >> 16)<< SYSCFG_UR3_BCM4_ADD0_Pos));\r\n  }\r\n\r\n  else\r\n  {\r\n    /* Configure CM4 BOOT ADD1 */\r\n    MODIFY_REG(SYSCFG->UR4, SYSCFG_UR4_BCM4_ADD1, (BootAddress >> 16));\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enables the Cortex-M7 boot\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_EnableCM7BOOT(void)\r\n{\r\n SET_BIT(SYSCFG->UR1, SYSCFG_UR1_BCM7);\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Cortex-M7 boot\r\n  * @note   Disabling the boot will gate the CPU clock\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_DisableCM7BOOT(void)\r\n{\r\n CLEAR_BIT(SYSCFG->UR1, SYSCFG_UR1_BCM7) ;\r\n}\r\n\r\n/**\r\n  * @brief  Enables the Cortex-M4 boot\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_EnableCM4BOOT(void)\r\n{\r\n SET_BIT(SYSCFG->UR1, SYSCFG_UR1_BCM4);\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Cortex-M4 boot\r\n  * @note   Disabling the boot will gate the CPU clock\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_DisableCM4BOOT(void)\r\n{\r\n  CLEAR_BIT(SYSCFG->UR1, SYSCFG_UR1_BCM4);\r\n}\r\n#endif /*DUAL_CORE*/\r\n/**\r\n  * @brief  Enables the I/O Compensation Cell.\r\n  * @note   The I/O compensation cell can be used only when the device supply\r\n  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableCompensationCell(void)\r\n{\r\n  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;\r\n}\r\n\r\n/**\r\n  * @brief  Power-down the I/O Compensation Cell.\r\n  * @note   The I/O compensation cell can be used only when the device supply\r\n  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.\r\n  * @retval None\r\n  */\r\nvoid HAL_DisableCompensationCell(void)\r\n{\r\n  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);\r\n}\r\n\r\n\r\n/**\r\n  * @brief  To Enable optimize the I/O speed when the product voltage is low.\r\n  * @note   This bit is active only if PRODUCT_BELOW_25V user option bit is set. It must be\r\n  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is\r\n  *         higher than 2.5 V might be destructive.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_EnableIOSpeedOptimize(void)\r\n{\r\n#if defined(SYSCFG_CCCSR_HSLV)\r\n  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);\r\n#else\r\n  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));\r\n#endif   /* SYSCFG_CCCSR_HSLV */\r\n}\r\n\r\n/**\r\n  * @brief  To Disable optimize the I/O speed when the product voltage is low.\r\n  * @note   This bit is active only if PRODUCT_BELOW_25V user option bit is set. It must be\r\n  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is\r\n  *         higher than 2.5 V might be destructive.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_DisableIOSpeedOptimize(void)\r\n{\r\n#if defined(SYSCFG_CCCSR_HSLV)\r\n  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);\r\n#else\r\n  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));\r\n#endif   /* SYSCFG_CCCSR_HSLV */\r\n}\r\n\r\n/**\r\n  * @brief  Code selection for the I/O Compensation cell\r\n  * @param  SYSCFG_CompCode: Selects the code to be applied for the I/O compensation cell\r\n  *   This parameter can be one of the following values:\r\n  *   @arg SYSCFG_CELL_CODE : Select Code from the cell (available in the SYSCFG_CCVR)\r\n  *   @arg SYSCFG_REGISTER_CODE: Select Code from the SYSCFG compensation cell code register (SYSCFG_CCCR)\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));\r\n  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));\r\n}\r\n\r\n/**\r\n  * @brief  Code selection for the I/O Compensation cell\r\n  * @param  SYSCFG_PMOSCode: PMOS compensation code\r\n  *         This code is applied to the I/O compensation cell when the CS bit of the\r\n  *          SYSCFG_CMPCR is set\r\n  * @param  SYSCFG_NMOSCode: NMOS compensation code\r\n  *         This code is applied to the I/O compensation cell when the CS bit of the\r\n  *          SYSCFG_CMPCR is set\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));\r\n  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));\r\n  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );\r\n}\r\n\r\n#if defined(SYSCFG_CCCR_NCC_MMC)\r\n/**\r\n  * @brief  Code selection for the I/O Compensation cell\r\n  * @param  SYSCFG_PMOSCode: VDDMMC PMOS compensation code\r\n  *         This code is applied to the I/O compensation cell when the CS bit of the\r\n  *          SYSCFG_CMPCR is set\r\n  * @param  SYSCFG_NMOSCode: VDDMMC NMOS compensation code\r\n  *         This code is applied to the I/O compensation cell when the CS bit of the\r\n  *          SYSCFG_CMPCR is set\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSCFG_VDDMMC_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));\r\n  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));\r\n  MODIFY_REG(SYSCFG->CCCR, (SYSCFG_CCCR_NCC_MMC | SYSCFG_CCCR_PCC_MMC), (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );\r\n}\r\n#endif /* SYSCFG_CCCR_NCC_MMC */\r\n\r\n#if defined(SYSCFG_ADC2ALT_ADC2_ROUT0)\r\n/** @brief  SYSCFG ADC2 internal input alternate connection macros\r\n  * @param Adc2AltRout0 This parameter can be a value of :\r\n  *     @arg @ref SYSCFG_ADC2_ROUT0_DAC1_1   DAC1_out1 connected to ADC2 VINP[16]\r\n  *     @arg @ref SYSCFG_ADC2_ROUT0_VBAT4    VBAT/4 connected to ADC2 VINP[16]\r\n  */\r\nvoid HAL_SYSCFG_ADC2ALT_Rout0Config(uint32_t Adc2AltRout0)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_ADC2ALT_ROUT0(Adc2AltRout0));\r\n\r\n  MODIFY_REG(SYSCFG->ADC2ALT, SYSCFG_ADC2ALT_ADC2_ROUT0, Adc2AltRout0);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n#endif /*SYSCFG_ADC2ALT_ADC2_ROUT0*/\r\n\r\n#if defined(SYSCFG_ADC2ALT_ADC2_ROUT1)\r\n/** @brief  SYSCFG ADC2 internal input alternate connection macros\r\n  * @param Adc2AltRout1  This parameter can be a value of :\r\n  *     @arg @ref SYSCFG_ADC2_ROUT1_DAC1_2   DAC1_out2 connected to ADC2 VINP[17]\r\n  *     @arg @ref SYSCFG_ADC2_ROUT1_VREFINT  VREFINT connected to ADC2 VINP[17]\r\n  */\r\nvoid HAL_SYSCFG_ADC2ALT_Rout1Config(uint32_t Adc2AltRout1)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSCFG_ADC2ALT_ROUT1(Adc2AltRout1));\r\n\r\n  MODIFY_REG(SYSCFG->ADC2ALT, SYSCFG_ADC2ALT_ADC2_ROUT1, Adc2AltRout1);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n#endif /*SYSCFG_ADC2ALT_ADC2_ROUT1*/\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGSleepMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGSleepMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGStopMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGStopMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_EnableDBGStandbyMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DBGMCU_DisableDBGStandbyMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Enable the Debug Module during Domain1 SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableDomain2DBGSleepMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD2);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain2 SLEEP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DisableDomain2DBGSleepMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD2);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during Domain2 STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableDomain2DBGStopMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD2);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain2 STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DisableDomain2DBGStopMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD2);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Debug Module during Domain2 STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableDomain2DBGStandbyMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD2);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain2 STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DisableDomain2DBGStandbyMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD2);\r\n}\r\n#endif /*DUAL_CORE*/\r\n\r\n#if defined(DBGMCU_CR_DBG_STOPD3)\r\n/**\r\n  * @brief  Enable the Debug Module during Domain3/SRDomain STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableDomain3DBGStopMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain3/SRDomain STOP mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DisableDomain3DBGStopMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);\r\n}\r\n#endif /*DBGMCU_CR_DBG_STOPD3*/\r\n\r\n#if defined(DBGMCU_CR_DBG_STANDBYD3)\r\n/**\r\n  * @brief  Enable the Debug Module during Domain3/SRDomain STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_EnableDomain3DBGStandbyMode(void)\r\n{\r\n  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Debug Module during Domain3/SRDomain STANDBY mode\r\n  * @retval None\r\n  */\r\nvoid HAL_DisableDomain3DBGStandbyMode(void)\r\n{\r\n  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);\r\n}\r\n#endif /*DBGMCU_CR_DBG_STANDBYD3*/\r\n\r\n/**\r\n  * @brief  Set the FMC Memory Mapping Swapping config.\r\n  * @param  BankMapConfig: Defines the FMC Bank mapping configuration. This parameter can be\r\n            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2\r\n  * @retval HAL state\r\n  */\r\nvoid HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));\r\n  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);\r\n}\r\n\r\n/**\r\n  * @brief  Get FMC Bank mapping mode.\r\n  * @retval The FMC Bank mapping mode. This parameter can be\r\n            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2\r\n*/\r\nuint32_t HAL_GetFMCMemorySwappingConfig(void)\r\n{\r\n  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);\r\n}\r\n\r\n/**\r\n  * @brief  Configure the EXTI input event line edge\r\n  * @note    No edge configuration for direct lines but for configurable lines:(EXTI_LINE0..EXTI_LINE21),\r\n  *          EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved\r\n  * @param   EXTI_Edge: Specifies  EXTI line Edge used.\r\n  *          This parameter can be one of the following values :\r\n  *   @arg EXTI_RISING_EDGE : Configurable line, with Rising edge trigger detection\r\n  *   @arg EXTI_FALLING_EDGE: Configurable line, with Falling edge trigger detection\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_EdgeConfig(uint32_t EXTI_Line , uint32_t EXTI_Edge )\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));\r\n  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));\r\n\r\n  /* Clear Rising Falling edge configuration */\r\n  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n\r\n  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)\r\n  {\r\n   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n  }\r\n  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)\r\n  {\r\n   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Generates a Software interrupt on selected EXTI line.\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *          (EXTI_LINE0..EXTI_LINE21),EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));\r\n\r\n  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Clears the EXTI's line pending flags for Domain D1\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)\r\n{\r\n  /* Check the parameters */\r\n assert_param(IS_EXTI_D1_LINE(EXTI_Line));\r\n WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Clears the EXTI's line pending flags for Domain D2\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_D2_ClearFlag(uint32_t EXTI_Line)\r\n{\r\n  /* Check the parameters */\r\n assert_param(IS_EXTI_D2_LINE(EXTI_Line));\r\n WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D2->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n}\r\n\r\n#endif /*DUAL_CORE*/\r\n/**\r\n  * @brief  Configure the EXTI input event line for Domain D1\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved\r\n  * @param   EXTI_Mode: Specifies which EXTI line is used as interrupt or an event.\r\n  *          This parameter can be one or a combination of the following values :\r\n  *   @arg EXTI_MODE_IT :  Interrupt Mode selected\r\n  *   @arg EXTI_MODE_EVT : Event Mode selected\r\n  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.\r\n\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_D1_LINE(EXTI_Line));\r\n  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));\r\n\r\n  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)\r\n  {\r\n     if( EXTI_LineCmd == 0UL)\r\n     {\r\n       /* Clear EXTI line configuration */\r\n        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );\r\n     }\r\n     else\r\n     {\r\n        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n     }\r\n  }\r\n\r\n  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)\r\n  {\r\n    if( EXTI_LineCmd == 0UL)\r\n    {\r\n      /* Clear EXTI line configuration */\r\n      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n    }\r\n    else\r\n    {\r\n      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n    }\r\n  }\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Configure the EXTI input event line for Domain D2\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved\r\n  * @param   EXTI_Mode: Specifies which EXTI line is used as interrupt or an event.\r\n  *          This parameter can be one or a combination of the following values :\r\n  *   @arg EXTI_MODE_IT :  Interrupt Mode selected\r\n  *   @arg EXTI_MODE_EVT : Event Mode selected\r\n  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.\r\n\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_D2_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_D2_LINE(EXTI_Line));\r\n  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));\r\n\r\n  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)\r\n  {\r\n    if( EXTI_LineCmd == 0UL)\r\n    {\r\n    /* Clear EXTI line configuration */\r\n     CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D2->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );\r\n    }\r\n    else\r\n    {\r\n     SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D2->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n    }\r\n  }\r\n\r\n  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)\r\n  {\r\n    if( EXTI_LineCmd == 0UL)\r\n    {\r\n      /* Clear EXTI line configuration */\r\n      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D2->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n    }\r\n    else\r\n    {\r\n      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D2->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n    }\r\n  }\r\n}\r\n#endif /*DUAL_CORE*/\r\n\r\n/**\r\n  * @brief  Configure the EXTI input event line for Domain D3\r\n  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,\r\n  *         (EXTI_LINE0...EXTI_LINE15),(EXTI_LINE19...EXTI_LINE21),EXTI_LINE25, EXTI_LINE34,\r\n  *          EXTI_LINE35,EXTI_LINE41,(EXTI_LINE48...EXTI_LINE53)\r\n  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.\r\n  * @param   EXTI_ClearSrc: Specifies the clear source of D3 pending event.\r\n  *          This parameter can be one of the following values :\r\n  *   @arg BDMA_CH6_CLEAR : BDMA ch6 event selected as D3 domain pendclear source\r\n  *   @arg BDMA_CH7_CLEAR : BDMA ch7 event selected as D3 domain pendclear source\r\n  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source\r\n  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source\r\n  * @retval None\r\n  */\r\nvoid HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )\r\n{\r\n  __IO uint32_t *pRegv;\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_D3_LINE(EXTI_Line));\r\n  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));\r\n\r\n  if( EXTI_LineCmd == 0UL)\r\n  {\r\n    /* Clear EXTI line configuration */\r\n    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );\r\n  }\r\n  else\r\n  {\r\n    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));\r\n  }\r\n\r\n  if(((EXTI_Line>>4)%2UL) == 0UL)\r\n  {\r\n    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));\r\n  }\r\n  else\r\n  {\r\n    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));\r\n  }\r\n  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n"},{"name":"stm32h7xx_hal_cortex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_cortex.c\r\n  * @author  MCD Application Team\r\n  * @brief   CORTEX HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the CORTEX:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n\r\n    [..]\r\n    *** How to configure Interrupts using CORTEX HAL driver ***\r\n    ===========================================================\r\n    [..]\r\n    This section provides functions allowing to configure the NVIC interrupts (IRQ).\r\n    The Cortex-M exceptions are managed by CMSIS functions.\r\n\r\n    (#) Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping()\r\n        function according to the following table.\r\n    (#) Configure the priority of the selected IRQ Channels using HAL_NVIC_SetPriority().\r\n    (#) Enable the selected IRQ Channels using HAL_NVIC_EnableIRQ().\r\n    (#) please refer to programming manual for details in how to configure priority.\r\n\r\n     -@- When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible.\r\n         The pending IRQ priority will be managed only by the sub priority.\r\n\r\n     -@- IRQ priority order (sorted by highest to lowest priority):\r\n        (+@) Lowest preemption priority\r\n        (+@) Lowest sub priority\r\n        (+@) Lowest hardware priority (IRQ number)\r\n\r\n    [..]\r\n    *** How to configure Systick using CORTEX HAL driver ***\r\n    ========================================================\r\n    [..]\r\n    Setup SysTick Timer for time base.\r\n\r\n   (+) The HAL_SYSTICK_Config() function calls the SysTick_Config() function which\r\n       is a CMSIS function that:\r\n        (++) Configures the SysTick Reload register with value passed as function parameter.\r\n        (++) Configures the SysTick IRQ priority to the lowest value (0x0F).\r\n        (++) Resets the SysTick Counter register.\r\n        (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).\r\n        (++) Enables the SysTick Interrupt.\r\n        (++) Starts the SysTick Counter.\r\n\r\n   (+) You can change the SysTick Clock source to be HCLK_Div8 by calling the macro\r\n       HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK_DIV8) just after the\r\n       HAL_SYSTICK_Config() function call. The HAL_SYSTICK_CLKSourceConfig() macro is defined\r\n       inside the stm32h7xx_hal_cortex.h file.\r\n\r\n   (+) You can change the SysTick IRQ priority by calling the\r\n       HAL_NVIC_SetPriority(SysTick_IRQn,...) function just after the HAL_SYSTICK_Config() function\r\n       call. The HAL_NVIC_SetPriority() call the NVIC_SetPriority() function which is a CMSIS function.\r\n\r\n   (+) To adjust the SysTick time base, use the following formula:\r\n\r\n       Reload Value = SysTick Counter Clock (Hz) x  Desired Time base (s)\r\n       (++) Reload Value is the parameter to be passed for HAL_SYSTICK_Config() function\r\n       (++) Reload Value should not exceed 0xFFFFFF\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup CORTEX CORTEX\r\n  * @brief CORTEX HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_CORTEX_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup CORTEX_Exported_Functions CORTEX Exported Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/** @defgroup CORTEX_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n  ==============================================================================\r\n    [..]\r\n      This section provides the CORTEX HAL driver functions allowing to configure Interrupts\r\n      Systick functionalities\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Sets the priority grouping field (preemption priority and subpriority)\r\n  *         using the required unlock sequence.\r\n  * @param  PriorityGroup The priority grouping bits length.\r\n  *         This parameter can be one of the following values:\r\n  *         @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority\r\n  *                                    4 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority\r\n  *                                    3 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority\r\n  *                                    2 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority\r\n  *                                    1 bits for subpriority\r\n  *         @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority\r\n  *                                    0 bits for subpriority\r\n  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.\r\n  *         The pending IRQ priority will be managed only by the subpriority.\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\r\n\r\n  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */\r\n  NVIC_SetPriorityGrouping(PriorityGroup);\r\n}\r\n\r\n/**\r\n  * @brief  Sets the priority of an interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @param  PreemptPriority The preemption priority for the IRQn channel.\r\n  *         This parameter can be a value between 0 and 15\r\n  *         A lower priority value indicates a higher priority\r\n  * @param  SubPriority the subpriority level for the IRQ channel.\r\n  *         This parameter can be a value between 0 and 15\r\n  *         A lower priority value indicates a higher priority.\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\r\n{\r\n  uint32_t prioritygroup;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\r\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\r\n\r\n  prioritygroup = NVIC_GetPriorityGrouping();\r\n\r\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\r\n}\r\n\r\n/**\r\n  * @brief  Enables a device specific interrupt in the NVIC interrupt controller.\r\n  * @note   To configure interrupts priority correctly, the NVIC_PriorityGroupConfig()\r\n  *         function should be called before.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n\r\n  /* Enable interrupt */\r\n  NVIC_EnableIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Disables a device specific interrupt in the NVIC interrupt controller.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n\r\n  /* Disable interrupt */\r\n  NVIC_DisableIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Initiates a system reset request to reset the MCU.\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SystemReset(void)\r\n{\r\n  /* System Reset */\r\n  NVIC_SystemReset();\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the System Timer and its interrupt, and starts the System Tick Timer.\r\n  *         Counter is in free running mode to generate periodic interrupts.\r\n  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.\r\n  * @retval status   - 0  Function succeeded.\r\n  *                  - 1  Function failed.\r\n  */\r\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\r\n{\r\n   return SysTick_Config(TicksNumb);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions\r\n *  @brief   Cortex control functions\r\n *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n    [..]\r\n      This subsection provides a set of functions allowing to control the CORTEX\r\n      (NVIC, SYSTICK, MPU) functionalities.\r\n\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n#if (__MPU_PRESENT == 1)\r\n/**\r\n  * @brief  Disables the MPU\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_Disable(void)\r\n{\r\n  /* Make sure outstanding transfers are done */\r\n  __DMB();\r\n\r\n  /* Disable fault exceptions */\r\n  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\r\n\r\n  /* Disable the MPU and clear the control register*/\r\n  MPU->CTRL = 0;\r\n}\r\n\r\n/**\r\n  * @brief  Enables the MPU\r\n  * @param  MPU_Control Specifies the control mode of the MPU during hard fault,\r\n  *         NMI, FAULTMASK and privileged access to the default memory\r\n  *         This parameter can be one of the following values:\r\n  *            @arg MPU_HFNMI_PRIVDEF_NONE\r\n  *            @arg MPU_HARDFAULT_NMI\r\n  *            @arg MPU_PRIVILEGED_DEFAULT\r\n  *            @arg MPU_HFNMI_PRIVDEF\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_Enable(uint32_t MPU_Control)\r\n{\r\n  /* Enable the MPU */\r\n  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\r\n\r\n  /* Enable fault exceptions */\r\n  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\r\n\r\n  /* Ensure MPU setting take effects */\r\n  __DSB();\r\n  __ISB();\r\n}\r\n/**\r\n  * @brief  Initializes and configures the Region and the memory to be protected.\r\n  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains\r\n  *                  the initialization and configuration information.\r\n  * @retval None\r\n  */\r\nvoid HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\r\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\r\n\r\n  /* Set the Region number */\r\n  MPU->RNR = MPU_Init->Number;\r\n\r\n  if ((MPU_Init->Enable) != 0UL)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\r\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\r\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\r\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\r\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\r\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\r\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\r\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\r\n\r\n    MPU->RBAR = MPU_Init->BaseAddress;\r\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\r\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\r\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\r\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\r\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\r\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\r\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\r\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\r\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\r\n  }\r\n  else\r\n  {\r\n    MPU->RBAR = 0x00;\r\n    MPU->RASR = 0x00;\r\n  }\r\n}\r\n#endif /* __MPU_PRESENT */\r\n\r\n/**\r\n  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.\r\n  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)\r\n  */\r\nuint32_t HAL_NVIC_GetPriorityGrouping(void)\r\n{\r\n  /* Get the PRIGROUP[10:8] field value */\r\n  return NVIC_GetPriorityGrouping();\r\n}\r\n\r\n/**\r\n  * @brief  Gets the priority of an interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @param   PriorityGroup the priority grouping bits length.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority\r\n  *                                      4 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority\r\n  *                                      3 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority\r\n  *                                      2 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority\r\n  *                                      1 bits for subpriority\r\n  *           @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority\r\n  *                                      0 bits for subpriority\r\n  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).\r\n  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\r\n /* Get priority for Cortex-M system or device specific interrupts */\r\n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\r\n}\r\n\r\n/**\r\n  * @brief  Sets Pending bit of an external interrupt.\r\n  * @param  IRQn External interrupt number\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n\r\n  /* Set interrupt pending */\r\n  NVIC_SetPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Gets Pending Interrupt (reads the pending register in the NVIC\r\n  *         and returns the pending bit for the specified interrupt).\r\n  * @param  IRQn External interrupt number.\r\n  *          This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @retval status  - 0  Interrupt status is not pending.\r\n  *                 - 1  Interrupt status is pending.\r\n  */\r\nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n\r\n  /* Return 1 if pending else 0 */\r\n  return NVIC_GetPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Clears the pending bit of an external interrupt.\r\n  * @param  IRQn External interrupt number.\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @retval None\r\n  */\r\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n\r\n  /* Clear pending interrupt */\r\n  NVIC_ClearPendingIRQ(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief Gets active interrupt ( reads the active register in NVIC and returns the active bit).\r\n  * @param IRQn External interrupt number\r\n  *         This parameter can be an enumerator of IRQn_Type enumeration\r\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))\r\n  * @retval status  - 0  Interrupt status is not pending.\r\n  *                 - 1  Interrupt status is pending.\r\n  */\r\nuint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\r\n\r\n  /* Return 1 if active else 0 */\r\n  return NVIC_GetActive(IRQn);\r\n}\r\n\r\n/**\r\n  * @brief  Configures the SysTick clock source.\r\n  * @param  CLKSource specifies the SysTick clock source.\r\n  *         This parameter can be one of the following values:\r\n  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.\r\n  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\r\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\r\n  {\r\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\r\n  }\r\n  else\r\n  {\r\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles SYSTICK interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_SYSTICK_IRQHandler(void)\r\n{\r\n  HAL_SYSTICK_Callback();\r\n}\r\n\r\n/**\r\n  * @brief  SYSTICK callback.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SYSTICK_Callback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_SYSTICK_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n\r\n/**\r\n  * @brief  Returns the current CPU ID.\r\n  * @retval CPU identifier\r\n  */\r\nuint32_t HAL_GetCurrentCPUID(void)\r\n{\r\n  if (((SCB->CPUID & 0x000000F0U) >> 4 )== 0x7U)\r\n  {\r\n    return  CM7_CPUID;\r\n  }\r\n  else\r\n  {\r\n    return CM4_CPUID;\r\n  }\r\n}\r\n\r\n#else\r\n\r\n/**\r\n* @brief  Returns the current CPU ID.\r\n* @retval CPU identifier\r\n*/\r\nuint32_t HAL_GetCurrentCPUID(void)\r\n{\r\n  return  CM7_CPUID;\r\n}\r\n\r\n#endif /*DUAL_CORE*/\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_CORTEX_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_dma.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_dma.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Direct Memory Access (DMA) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral State and errors functions\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) Enable and configure the peripheral to be connected to the DMA Stream\r\n       (except for internal SRAM/FLASH memories: no initialization is\r\n       necessary) please refer to Reference manual for connection between peripherals\r\n       and DMA requests .\r\n\r\n   (#) For a given Stream, program the required configuration through the following parameters:\r\n       Transfer Direction, Source and Destination data formats,\r\n       Circular, Normal or peripheral flow control mode, Stream Priority level,\r\n       Source and Destination Increment mode, FIFO mode and its Threshold (if needed),\r\n       Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.\r\n\r\n     *** Polling mode IO operation ***\r\n     =================================\r\n    [..]\r\n          (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source\r\n              address and destination address and the Length of data to be transferred\r\n          (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this\r\n              case a fixed Timeout can be configured by User depending from his application.\r\n\r\n     *** Interrupt mode IO operation ***\r\n     ===================================\r\n    [..]\r\n          (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()\r\n          (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()\r\n          (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of\r\n              Source address and destination address and the Length of data to be transferred. In this\r\n              case the DMA interrupt is configured\r\n          (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine\r\n          (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can\r\n              add his own function by customization of function pointer XferCpltCallback and\r\n              XferErrorCallback (i.e a member of DMA handle structure).\r\n    [..]\r\n     (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error\r\n         detection.\r\n\r\n     (#) Use HAL_DMA_Abort() function to abort the current transfer\r\n\r\n     -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.\r\n\r\n     -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is\r\n           possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set\r\n           Half-Word data size for the peripheral to access its data register and set Word data size\r\n           for the Memory to gain in access time. Each two half words will be packed and written in\r\n           a single access to a Word in the Memory).\r\n\r\n     -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source\r\n           and Destination. In this case the Peripheral Data Size will be applied to both Source\r\n           and Destination.\r\n\r\n     *** DMA HAL driver macros list ***\r\n     =============================================\r\n     [..]\r\n       Below the list of most used macros in DMA HAL driver.\r\n\r\n      (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.\r\n      (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.\r\n      (+) __HAL_DMA_GET_FS: Return the current DMA Stream FIFO filled level.\r\n      (+) __HAL_DMA_ENABLE_IT: Enable the specified DMA Stream interrupts.\r\n      (+) __HAL_DMA_DISABLE_IT: Disable the specified DMA Stream interrupts.\r\n      (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not.\r\n\r\n     [..]\r\n      (@) You can refer to the DMA HAL driver header file for more useful macros.\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup DMA DMA\r\n  * @brief DMA HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_DMA_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\ntypedef struct\r\n{\r\n  __IO uint32_t ISR;   /*!< DMA interrupt status register */\r\n  __IO uint32_t Reserved0;\r\n  __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */\r\n} DMA_Base_Registers;\r\n\r\ntypedef struct\r\n{\r\n  __IO uint32_t ISR;   /*!< BDMA interrupt status register */\r\n  __IO uint32_t IFCR;  /*!< BDMA interrupt flag clear register */\r\n} BDMA_Base_Registers;\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Private_Constants\r\n * @{\r\n */\r\n#define HAL_TIMEOUT_DMA_ABORT         (5U)  /* 5 ms */\r\n\r\n#define BDMA_PERIPH_TO_MEMORY         (0x00000000U)                /*!< Peripheral to memory direction */\r\n#define BDMA_MEMORY_TO_PERIPH         ((uint32_t)BDMA_CCR_DIR)     /*!< Memory to peripheral direction */\r\n#define BDMA_MEMORY_TO_MEMORY         ((uint32_t)BDMA_CCR_MEM2MEM) /*!< Memory to memory direction     */\r\n\r\n/* DMA to BDMA conversion */\r\n#define DMA_TO_BDMA_DIRECTION(__DMA_DIRECTION__) (((__DMA_DIRECTION__) == DMA_MEMORY_TO_PERIPH)? BDMA_MEMORY_TO_PERIPH: \\\r\n                                                  ((__DMA_DIRECTION__) == DMA_MEMORY_TO_MEMORY)? BDMA_MEMORY_TO_MEMORY: \\\r\n                                                  BDMA_PERIPH_TO_MEMORY)\r\n\r\n#define DMA_TO_BDMA_PERIPHERAL_INC(__DMA_PERIPHERAL_INC__) ((__DMA_PERIPHERAL_INC__) >> 3U)\r\n#define DMA_TO_BDMA_MEMORY_INC(__DMA_MEMORY_INC__) ((__DMA_MEMORY_INC__) >> 3U)\r\n\r\n#define DMA_TO_BDMA_PDATA_SIZE(__DMA_PDATA_SIZE__) ((__DMA_PDATA_SIZE__) >> 3U)\r\n#define DMA_TO_BDMA_MDATA_SIZE(__DMA_MDATA_SIZE__) ((__DMA_MDATA_SIZE__) >> 3U)\r\n\r\n#define DMA_TO_BDMA_MODE(__DMA_MODE__) ((__DMA_MODE__) >> 3U)\r\n\r\n#define DMA_TO_BDMA_PRIORITY(__DMA_PRIORITY__) ((__DMA_PRIORITY__) >> 4U)\r\n\r\n#if defined(UART9)\r\n#define IS_DMA_UART_USART_REQUEST(__REQUEST__) ((((__REQUEST__) >= DMA_REQUEST_USART1_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_USART3_TX)) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART4_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART5_TX )) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_USART6_RX) &&  ((__REQUEST__) <= DMA_REQUEST_USART6_TX)) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART7_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART8_TX )) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART9_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_USART10_TX )))\r\n#else\r\n#define IS_DMA_UART_USART_REQUEST(__REQUEST__) ((((__REQUEST__) >= DMA_REQUEST_USART1_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_USART3_TX)) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART4_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART5_TX )) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_USART6_RX) &&  ((__REQUEST__) <= DMA_REQUEST_USART6_TX)) || \\\r\n                                                 (((__REQUEST__) >= DMA_REQUEST_UART7_RX)  &&  ((__REQUEST__) <= DMA_REQUEST_UART8_TX )))\r\n\r\n#endif\r\n/**\r\n  * @}\r\n  */\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Private_Functions\r\n  * @{\r\n  */\r\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\r\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);\r\nstatic void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma);\r\nstatic void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n/** @addtogroup DMA_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group1\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n             ##### Initialization and de-initialization functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This section provides functions allowing to initialize the DMA Stream source\r\n    and destination incrementation and data sizes, transfer direction,\r\n    circular/normal mode selection, memory-to-memory mode selection and Stream priority value.\r\n    [..]\r\n    The HAL_DMA_Init() function follows the DMA configuration procedures as described in\r\n    reference manual.\r\n    The HAL_DMA_DeInit function allows to deinitialize the DMA stream.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initialize the DMA according to the specified\r\n  *         parameters in the DMA_InitTypeDef and create the associated handle.\r\n  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t registerValue;\r\n  uint32_t tickstart = HAL_GetTick();\r\n  DMA_Base_Registers *regs_dma;\r\n  BDMA_Base_Registers *regs_bdma;\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));\r\n  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));\r\n  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));\r\n  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));\r\n  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));\r\n  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));\r\n  assert_param(IS_DMA_MODE(hdma->Init.Mode));\r\n  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));\r\n\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    assert_param(IS_DMA_REQUEST(hdma->Init.Request));\r\n    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));\r\n    /* Check the memory burst, peripheral burst and FIFO threshold parameters only\r\n       when FIFO mode is enabled */\r\n    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)\r\n    {\r\n      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));\r\n      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));\r\n      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));\r\n    }\r\n\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n    /* Allocate lock resource */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    /* Disable the peripheral */\r\n    __HAL_DMA_DISABLE(hdma);\r\n\r\n    /* Check if the DMA Stream is effectively disabled */\r\n    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)\r\n    {\r\n      /* Check for the Timeout */\r\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n\r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_ERROR;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Get the CR register value */\r\n    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;\r\n\r\n    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */\r\n    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \\\r\n                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \\\r\n                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \\\r\n                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));\r\n\r\n    /* Prepare the DMA Stream configuration */\r\n    registerValue |=  hdma->Init.Direction           |\r\n            hdma->Init.PeriphInc           | hdma->Init.MemInc           |\r\n            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |\r\n            hdma->Init.Mode                | hdma->Init.Priority;\r\n\r\n    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */\r\n    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\r\n    {\r\n      /* Get memory burst and peripheral burst */\r\n      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;\r\n    }\r\n\r\n    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be\r\n                                    lock when transferring data to/from USART/UART */\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)\r\n    {\r\n#endif /* STM32H7_DEV_ID == 0x450UL */\r\n      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)\r\n      {\r\n        registerValue |= DMA_SxCR_TRBUFF;\r\n      }\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n    }\r\n#endif /* STM32H7_DEV_ID == 0x450UL */\r\n\r\n    /* Write to DMA Stream CR register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;\r\n\r\n    /* Get the FCR register value */\r\n    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;\r\n\r\n    /* Clear Direct mode and FIFO threshold bits */\r\n    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);\r\n\r\n    /* Prepare the DMA Stream FIFO configuration */\r\n    registerValue |= hdma->Init.FIFOMode;\r\n\r\n    /* the FIFO threshold is not used when the FIFO mode is disabled */\r\n    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)\r\n    {\r\n      /* Get the FIFO threshold */\r\n      registerValue |= hdma->Init.FIFOThreshold;\r\n\r\n      /* Check compatibility between FIFO threshold level and size of the memory burst */\r\n      /* for INCR4, INCR8, INCR16 */\r\n      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)\r\n      {\r\n        if (DMA_CheckFifoParam(hdma) != HAL_OK)\r\n        {\r\n          /* Update error code */\r\n          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\r\n\r\n          /* Change the DMA state */\r\n          hdma->State = HAL_DMA_STATE_READY;\r\n\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Write to DMA Stream FCR */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;\r\n\r\n    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate\r\n       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */\r\n    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n\r\n    /* Clear all interrupt flags */\r\n    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n  }\r\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */\r\n  {\r\n    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)\r\n    {\r\n      /* Check the request parameter */\r\n      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));\r\n    }\r\n\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n    /* Allocate lock resource */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    /* Get the CR register value */\r\n    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;\r\n\r\n    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */\r\n    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \\\r\n                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \\\r\n                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \\\r\n                                  BDMA_CCR_CT));\r\n\r\n    /* Prepare the DMA Channel configuration */\r\n    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |\r\n                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |\r\n                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |\r\n                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |\r\n                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |\r\n                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |\r\n                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);\r\n\r\n    /* Write to DMA Channel CR register */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;\r\n\r\n    /* calculation of the channel index */\r\n    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;\r\n\r\n    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate\r\n    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */\r\n    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n\r\n    /* Clear all interrupt flags */\r\n    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\r\n  }\r\n  else\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\r\n    hdma->State     = HAL_DMA_STATE_ERROR;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n  {\r\n    /* Initialize parameters for DMAMUX channel :\r\n    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask\r\n    */\r\n    DMA_CalcDMAMUXChannelBaseAndMask(hdma);\r\n\r\n    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n    {\r\n      /* if memory to memory force the request to 0*/\r\n      hdma->Init.Request = DMA_REQUEST_MEM2MEM;\r\n    }\r\n\r\n    /* Set peripheral request  to DMAMUX channel */\r\n    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);\r\n\r\n    /* Clear the DMAMUX synchro overrun flag */\r\n    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n    /* Initialize parameters for DMAMUX request generator :\r\n    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7\r\n    */\r\n    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))\r\n    {\r\n      /* Initialize parameters for DMAMUX request generator :\r\n      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */\r\n      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);\r\n\r\n      /* Reset the DMAMUX request generator register */\r\n      hdma->DMAmuxRequestGen->RGCR = 0U;\r\n\r\n      /* Clear the DMAMUX request generator overrun flag */\r\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n    }\r\n    else\r\n    {\r\n      hdma->DMAmuxRequestGen = 0U;\r\n      hdma->DMAmuxRequestGenStatus = 0U;\r\n      hdma->DMAmuxRequestGenStatusMask = 0U;\r\n    }\r\n  }\r\n\r\n  /* Initialize the error code */\r\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n  /* Initialize the DMA state */\r\n  hdma->State = HAL_DMA_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the DMA peripheral\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)\r\n{\r\n  DMA_Base_Registers *regs_dma;\r\n  BDMA_Base_Registers *regs_bdma;\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Disable the selected DMA Streamx */\r\n  __HAL_DMA_DISABLE(hdma);\r\n\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    /* Reset DMA Streamx control register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;\r\n\r\n    /* Reset DMA Streamx number of data to transfer register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;\r\n\r\n    /* Reset DMA Streamx peripheral address register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;\r\n\r\n    /* Reset DMA Streamx memory 0 address register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;\r\n\r\n    /* Reset DMA Streamx memory 1 address register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;\r\n\r\n    /* Reset DMA Streamx FIFO control register */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;\r\n\r\n    /* Get DMA steam Base Address */\r\n    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n\r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n  }\r\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */\r\n  {\r\n    /* Reset DMA Channel control register */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;\r\n\r\n    /* Reset DMA Channel Number of Data to Transfer register */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;\r\n\r\n    /* Reset DMA Channel peripheral address register */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;\r\n\r\n    /* Reset DMA Channel memory 0 address register */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;\r\n\r\n    /* Reset DMA Channel memory 1 address register */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;\r\n\r\n    /* Get DMA steam Base Address */\r\n    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);\r\n\r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n\r\n#if defined (BDMA1) /* No DMAMUX available for BDMA1 available on  STM32H7Ax/Bx devices only */\r\n  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n#endif /* BDMA1 */\r\n  {\r\n    /* Initialize parameters for DMAMUX channel :\r\n    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */\r\n    DMA_CalcDMAMUXChannelBaseAndMask(hdma);\r\n\r\n    if(hdma->DMAmuxChannel != 0U)\r\n    {\r\n      /* Resett he DMAMUX channel that corresponds to the DMA stream */\r\n      hdma->DMAmuxChannel->CCR = 0U;\r\n\r\n      /* Clear the DMAMUX synchro overrun flag */\r\n      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n    }\r\n\r\n    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))\r\n    {\r\n      /* Initialize parameters for DMAMUX request generator :\r\n      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */\r\n      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);\r\n\r\n      /* Reset the DMAMUX request generator register */\r\n      hdma->DMAmuxRequestGen->RGCR = 0U;\r\n\r\n      /* Clear the DMAMUX request generator overrun flag */\r\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n    }\r\n\r\n    hdma->DMAmuxRequestGen = 0U;\r\n    hdma->DMAmuxRequestGenStatus = 0U;\r\n    hdma->DMAmuxRequestGenStatusMask = 0U;\r\n  }\r\n\r\n\r\n  /* Clean callbacks */\r\n  hdma->XferCpltCallback       = NULL;\r\n  hdma->XferHalfCpltCallback   = NULL;\r\n  hdma->XferM1CpltCallback     = NULL;\r\n  hdma->XferM1HalfCpltCallback = NULL;\r\n  hdma->XferErrorCallback      = NULL;\r\n  hdma->XferAbortCallback      = NULL;\r\n\r\n  /* Initialize the error code */\r\n  hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n  /* Initialize the DMA state */\r\n  hdma->State = HAL_DMA_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group2\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      #####  IO operation functions  #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and Start DMA transfer\r\n      (+) Configure the source, destination address and data length and\r\n          Start DMA transfer with interrupt\r\n      (+) Register and Unregister DMA callbacks\r\n      (+) Abort DMA transfer\r\n      (+) Poll for transfer complete\r\n      (+) Handle DMA interrupt request\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the DMA Transfer.\r\n  * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  DataLength: The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n    /* Disable the peripheral */\r\n    __HAL_DMA_DISABLE(hdma);\r\n\r\n    /* Configure the source, destination address and the data length */\r\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n\r\n    /* Enable the Peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Set the error code to busy */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\r\n\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Start the DMA Transfer with interrupt enabled.\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  DataLength: The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n    /* Disable the peripheral */\r\n    __HAL_DMA_DISABLE(hdma);\r\n\r\n    /* Configure the source, destination address and the data length */\r\n    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      /* Enable Common interrupts*/\r\n      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));\r\n\r\n      if(hdma->XferHalfCpltCallback != NULL)\r\n      {\r\n        /* Enable Half Transfer IT if corresponding Callback is set */\r\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;\r\n      }\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      /* Enable Common interrupts */\r\n      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));\r\n\r\n      if(hdma->XferHalfCpltCallback != NULL)\r\n      {\r\n        /*Enable Half Transfer IT if corresponding Callback is set */\r\n        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;\r\n      }\r\n    }\r\n\r\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n    {\r\n      /* Check if DMAMUX Synchronization is enabled */\r\n      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)\r\n      {\r\n        /* Enable DMAMUX sync overrun IT*/\r\n        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;\r\n      }\r\n\r\n      if(hdma->DMAmuxRequestGen != 0U)\r\n      {\r\n        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/\r\n        /* enable the request gen overrun IT */\r\n        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;\r\n      }\r\n    }\r\n\r\n    /* Enable the Peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Set the error code to busy */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\r\n\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the DMA Transfer.\r\n  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified DMA Stream.\r\n  *\r\n  * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is\r\n  *        effectively disabled is added. If a Stream is disabled\r\n  *        while a data transfer is ongoing, the current data will be transferred\r\n  *        and the Stream will be effectively disabled only after the transfer of\r\n  *        this single data is finished.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers *regs_dma;\r\n  BDMA_Base_Registers *regs_bdma;\r\n  const __IO uint32_t *enableRegister;\r\n\r\n  uint32_t tickstart = HAL_GetTick();\r\n\r\n /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the DMA peripheral state */\r\n  if(hdma->State != HAL_DMA_STATE_BUSY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Disable all the transfer interrupts */\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n       /* Disable DMA All Interrupts  */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);\r\n\r\n      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      /* Disable DMA All Interrupts */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);\r\n\r\n      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));\r\n    }\r\n\r\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n    {\r\n      /* disable the DMAMUX sync overrun IT */\r\n      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;\r\n    }\r\n\r\n    /* Disable the stream */\r\n    __HAL_DMA_DISABLE(hdma);\r\n\r\n    /* Check if the DMA Stream is effectively disabled */\r\n    while(((*enableRegister) & DMA_SxCR_EN) != 0U)\r\n    {\r\n      /* Check for the Timeout */\r\n      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n\r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_ERROR;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\r\n      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\r\n    }\r\n\r\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n    {\r\n      /* Clear the DMAMUX synchro overrun flag */\r\n      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n      if(hdma->DMAmuxRequestGen != 0U)\r\n      {\r\n        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */\r\n        /* disable the request gen overrun IT */\r\n        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;\r\n\r\n        /* Clear the DMAMUX request generator overrun flag */\r\n        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n      }\r\n    }\r\n\r\n    /* Change the DMA state */\r\n    hdma->State = HAL_DMA_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the DMA Transfer in Interrupt mode.\r\n  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\r\n{\r\n  BDMA_Base_Registers *regs_bdma;\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(hdma->State != HAL_DMA_STATE_BUSY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      /* Set Abort State  */\r\n      hdma->State = HAL_DMA_STATE_ABORT;\r\n\r\n      /* Disable the stream */\r\n      __HAL_DMA_DISABLE(hdma);\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      /* Disable DMA All Interrupts  */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);\r\n\r\n      /* Disable the channel */\r\n      __HAL_DMA_DISABLE(hdma);\r\n\r\n      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n      {\r\n        /* disable the DMAMUX sync overrun IT */\r\n        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;\r\n\r\n        /* Clear all flags */\r\n        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\r\n        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));\r\n\r\n        /* Clear the DMAMUX synchro overrun flag */\r\n        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n        if(hdma->DMAmuxRequestGen != 0U)\r\n        {\r\n          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/\r\n          /* disable the request gen overrun IT */\r\n          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;\r\n\r\n          /* Clear the DMAMUX request generator overrun flag */\r\n          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n        }\r\n      }\r\n\r\n      /* Change the DMA state */\r\n      hdma->State = HAL_DMA_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hdma);\r\n\r\n      /* Call User Abort callback */\r\n      if(hdma->XferAbortCallback != NULL)\r\n      {\r\n        hdma->XferAbortCallback(hdma);\r\n      }\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Polling for transfer complete.\r\n  * @param  hdma:          pointer to a DMA_HandleTypeDef structure that contains\r\n  *                        the configuration information for the specified DMA Stream.\r\n  * @param  CompleteLevel: Specifies the DMA level complete.\r\n  * @note   The polling mode is kept in this version for legacy. it is recommended to use the IT model instead.\r\n  *         This model could be used for debug purpose.\r\n  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode).\r\n  * @param  Timeout:       Timeout duration.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t cpltlevel_mask;\r\n  uint32_t tickstart = HAL_GetTick();\r\n\r\n  /* IT status register */\r\n  __IO uint32_t *isr_reg;\r\n  /* IT clear flag register */\r\n  __IO uint32_t *ifcr_reg;\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(HAL_DMA_STATE_BUSY != hdma->State)\r\n  {\r\n    /* No transfer ongoing */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    /* Polling mode not supported in circular mode and double buffering mode */\r\n    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)\r\n    {\r\n      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Get the level transfer complete flag */\r\n    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n    {\r\n      /* Transfer Complete flag */\r\n      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n    else\r\n    {\r\n      /* Half Transfer Complete flag */\r\n      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n\r\n    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);\r\n    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);\r\n  }\r\n  else /* BDMA channel */\r\n  {\r\n    /* Polling mode not supported in circular mode */\r\n    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)\r\n    {\r\n      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Get the level transfer complete flag */\r\n    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n    {\r\n      /* Transfer Complete flag */\r\n      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n    else\r\n    {\r\n      /* Half Transfer Complete flag */\r\n      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n\r\n    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);\r\n    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);\r\n  }\r\n\r\n  while(((*isr_reg) & cpltlevel_mask) == 0U)\r\n  {\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_FE;\r\n\r\n        /* Clear the FIFO error flag */\r\n        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n      }\r\n\r\n      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_DME;\r\n\r\n        /* Clear the Direct Mode error flag */\r\n        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n      }\r\n\r\n      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_TE;\r\n\r\n        /* Clear the transfer error flag */\r\n        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n\r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n      {\r\n        /* When a DMA transfer error occurs */\r\n        /* A hardware clear of its EN bits is performed */\r\n        /* Clear all flags */\r\n        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));\r\n\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TE;\r\n\r\n        /* Change the DMA state */\r\n        hdma->State = HAL_DMA_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Check for the Timeout (Not applicable in circular mode)*/\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))\r\n      {\r\n        /* Update error code */\r\n        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;\r\n\r\n        /* if timeout then abort the current transfer */\r\n        /* No need to check return value: as in this case we will return HAL_ERROR with HAL_DMA_ERROR_TIMEOUT error code  */\r\n        (void) HAL_DMA_Abort(hdma);\r\n          /*\r\n            Note that the Abort function will\r\n              - Clear the transfer error flags\r\n              - Unlock\r\n              - Set the State\r\n          */\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n    {\r\n      /* Check for DMAMUX Request generator (if used) overrun status */\r\n      if(hdma->DMAmuxRequestGen != 0U)\r\n      {\r\n        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */\r\n        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)\r\n        {\r\n          /* Clear the DMAMUX request generator overrun flag */\r\n          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n\r\n          /* Update error code */\r\n          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;\r\n        }\r\n      }\r\n\r\n      /* Check for DMAMUX Synchronization overrun */\r\n      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)\r\n      {\r\n        /* Clear the DMAMUX synchro overrun flag */\r\n        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /* Get the level transfer complete flag */\r\n  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)\r\n  {\r\n    /* Clear the half transfer and transfer complete flags */\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));\r\n    }\r\n\r\n    hdma->State = HAL_DMA_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hdma);\r\n  }\r\n  else /*CompleteLevel = HAL_DMA_HALF_TRANSFER*/\r\n  {\r\n    /* Clear the half transfer and transfer complete flags */\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n    else /* BDMA channel */\r\n    {\r\n      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Handles DMA interrupt request.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval None\r\n  */\r\nvoid HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t tmpisr_dma, tmpisr_bdma;\r\n  uint32_t ccr_reg;\r\n  __IO uint32_t count = 0U;\r\n  uint32_t timeout = SystemCoreClock / 9600U;\r\n\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\r\n\r\n  tmpisr_dma  = regs_dma->ISR;\r\n  tmpisr_bdma = regs_bdma->ISR;\r\n\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */\r\n  {\r\n    /* Transfer Error Interrupt management ***************************************/\r\n    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n    {\r\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)\r\n      {\r\n        /* Disable the transfer error interrupt */\r\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);\r\n\r\n        /* Clear the transfer error flag */\r\n        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_TE;\r\n      }\r\n    }\r\n    /* FIFO Error Interrupt management ******************************************/\r\n    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n    {\r\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)\r\n      {\r\n        /* Clear the FIFO error flag */\r\n        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_FE;\r\n      }\r\n    }\r\n    /* Direct Mode Error Interrupt management ***********************************/\r\n    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n    {\r\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)\r\n      {\r\n        /* Clear the direct mode error flag */\r\n        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n\r\n        /* Update error code */\r\n        hdma->ErrorCode |= HAL_DMA_ERROR_DME;\r\n      }\r\n    }\r\n    /* Half Transfer Complete Interrupt management ******************************/\r\n    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n    {\r\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)\r\n      {\r\n        /* Clear the half transfer complete flag */\r\n        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n\r\n        /* Multi_Buffering mode enabled */\r\n        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)\r\n        {\r\n          /* Current memory buffer used is Memory 0 */\r\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)\r\n          {\r\n            if(hdma->XferHalfCpltCallback != NULL)\r\n            {\r\n              /* Half transfer callback */\r\n              hdma->XferHalfCpltCallback(hdma);\r\n            }\r\n          }\r\n          /* Current memory buffer used is Memory 1 */\r\n          else\r\n          {\r\n            if(hdma->XferM1HalfCpltCallback != NULL)\r\n            {\r\n              /* Half transfer callback */\r\n              hdma->XferM1HalfCpltCallback(hdma);\r\n            }\r\n          }\r\n        }\r\n        else\r\n        {\r\n          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */\r\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)\r\n          {\r\n            /* Disable the half transfer interrupt */\r\n            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);\r\n          }\r\n\r\n          if(hdma->XferHalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer callback */\r\n            hdma->XferHalfCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /* Transfer Complete Interrupt management ***********************************/\r\n    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)\r\n    {\r\n      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)\r\n      {\r\n        /* Clear the transfer complete flag */\r\n        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);\r\n\r\n        if(HAL_DMA_STATE_ABORT == hdma->State)\r\n        {\r\n          /* Disable all the transfer interrupts */\r\n          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);\r\n          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);\r\n\r\n          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n          {\r\n            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);\r\n          }\r\n\r\n          /* Clear all interrupt flags at correct offset within the register */\r\n          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n\r\n          /* Change the DMA state */\r\n          hdma->State = HAL_DMA_STATE_READY;\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(hdma);\r\n\r\n          if(hdma->XferAbortCallback != NULL)\r\n          {\r\n            hdma->XferAbortCallback(hdma);\r\n          }\r\n          return;\r\n        }\r\n\r\n        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)\r\n        {\r\n          /* Current memory buffer used is Memory 0 */\r\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)\r\n          {\r\n            if(hdma->XferM1CpltCallback != NULL)\r\n            {\r\n              /* Transfer complete Callback for memory1 */\r\n              hdma->XferM1CpltCallback(hdma);\r\n            }\r\n          }\r\n          /* Current memory buffer used is Memory 1 */\r\n          else\r\n          {\r\n            if(hdma->XferCpltCallback != NULL)\r\n            {\r\n              /* Transfer complete Callback for memory0 */\r\n              hdma->XferCpltCallback(hdma);\r\n            }\r\n          }\r\n        }\r\n        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */\r\n        else\r\n        {\r\n          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)\r\n          {\r\n            /* Disable the transfer complete interrupt */\r\n            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);\r\n\r\n            /* Change the DMA state */\r\n            hdma->State = HAL_DMA_STATE_READY;\r\n\r\n            /* Process Unlocked */\r\n            __HAL_UNLOCK(hdma);\r\n          }\r\n\r\n          if(hdma->XferCpltCallback != NULL)\r\n          {\r\n            /* Transfer complete callback */\r\n            hdma->XferCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* manage error case */\r\n    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)\r\n    {\r\n      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)\r\n      {\r\n        hdma->State = HAL_DMA_STATE_ABORT;\r\n\r\n        /* Disable the stream */\r\n        __HAL_DMA_DISABLE(hdma);\r\n\r\n        do\r\n        {\r\n          if (++count > timeout)\r\n          {\r\n            break;\r\n          }\r\n        }\r\n        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);\r\n\r\n        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)\r\n        {\r\n          /* Change the DMA state to error if DMA disable fails */\r\n          hdma->State = HAL_DMA_STATE_ERROR;\r\n        }\r\n        else\r\n        {\r\n          /* Change the DMA state to Ready if DMA disable success */\r\n          hdma->State = HAL_DMA_STATE_READY;\r\n        }\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hdma);\r\n      }\r\n\r\n      if(hdma->XferErrorCallback != NULL)\r\n      {\r\n        /* Transfer error callback */\r\n        hdma->XferErrorCallback(hdma);\r\n      }\r\n    }\r\n  }\r\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */\r\n  {\r\n    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);\r\n\r\n    /* Half Transfer Complete Interrupt management ******************************/\r\n    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))\r\n    {\r\n      /* Clear the half transfer complete flag */\r\n      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));\r\n\r\n      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */\r\n      if((ccr_reg & BDMA_CCR_DBM) != 0U)\r\n      {\r\n        /* Current memory buffer used is Memory 0 */\r\n        if((ccr_reg & BDMA_CCR_CT) == 0U)\r\n        {\r\n          if(hdma->XferM1HalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer Callback for Memory 1 */\r\n            hdma->XferM1HalfCpltCallback(hdma);\r\n          }\r\n        }\r\n        /* Current memory buffer used is Memory 1 */\r\n        else\r\n        {\r\n          if(hdma->XferHalfCpltCallback != NULL)\r\n          {\r\n            /* Half transfer Callback for Memory 0 */\r\n            hdma->XferHalfCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        if((ccr_reg & BDMA_CCR_CIRC) == 0U)\r\n        {\r\n          /* Disable the half transfer interrupt */\r\n          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);\r\n        }\r\n\r\n        /* DMA peripheral state is not updated in Half Transfer */\r\n        /* but in Transfer Complete case */\r\n\r\n       if(hdma->XferHalfCpltCallback != NULL)\r\n        {\r\n          /* Half transfer callback */\r\n          hdma->XferHalfCpltCallback(hdma);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Transfer Complete Interrupt management ***********************************/\r\n    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))\r\n    {\r\n      /* Clear the transfer complete flag */\r\n      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);\r\n\r\n      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */\r\n      if((ccr_reg & BDMA_CCR_DBM) != 0U)\r\n      {\r\n        /* Current memory buffer used is Memory 0 */\r\n        if((ccr_reg & BDMA_CCR_CT) == 0U)\r\n        {\r\n          if(hdma->XferM1CpltCallback != NULL)\r\n          {\r\n            /* Transfer complete Callback for Memory 1 */\r\n            hdma->XferM1CpltCallback(hdma);\r\n          }\r\n        }\r\n        /* Current memory buffer used is Memory 1 */\r\n        else\r\n        {\r\n          if(hdma->XferCpltCallback != NULL)\r\n          {\r\n            /* Transfer complete Callback for Memory 0 */\r\n            hdma->XferCpltCallback(hdma);\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        if((ccr_reg & BDMA_CCR_CIRC) == 0U)\r\n        {\r\n          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */\r\n          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);\r\n\r\n          /* Change the DMA state */\r\n          hdma->State = HAL_DMA_STATE_READY;\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(hdma);\r\n        }\r\n\r\n        if(hdma->XferCpltCallback != NULL)\r\n        {\r\n          /* Transfer complete callback */\r\n          hdma->XferCpltCallback(hdma);\r\n        }\r\n      }\r\n    }\r\n    /* Transfer Error Interrupt management **************************************/\r\n    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))\r\n    {\r\n      /* When a DMA transfer error occurs */\r\n      /* A hardware clear of its EN bits is performed */\r\n      /* Disable ALL DMA IT */\r\n      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));\r\n\r\n      /* Clear all flags */\r\n      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);\r\n\r\n      /* Update error code */\r\n      hdma->ErrorCode = HAL_DMA_ERROR_TE;\r\n\r\n      /* Change the DMA state */\r\n      hdma->State = HAL_DMA_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hdma);\r\n\r\n      if (hdma->XferErrorCallback != NULL)\r\n      {\r\n        /* Transfer error callback */\r\n        hdma->XferErrorCallback(hdma);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Nothing To Do */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing To Do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Register callbacks\r\n  * @param  hdma:                 pointer to a DMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified DMA Stream.\r\n  * @param  CallbackID:           User Callback identifier\r\n  *                               a DMA_HandleTypeDef structure as parameter.\r\n  * @param  pCallback:            pointer to private callback function which has pointer to\r\n  *                               a DMA_HandleTypeDef structure as parameter.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))\r\n{\r\n\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_DMA_XFER_CPLT_CB_ID:\r\n      hdma->XferCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\r\n      hdma->XferHalfCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\r\n      hdma->XferM1CpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\r\n      hdma->XferM1HalfCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ERROR_CB_ID:\r\n      hdma->XferErrorCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ABORT_CB_ID:\r\n      hdma->XferAbortCallback = pCallback;\r\n      break;\r\n\r\n    default:\r\n      status =  HAL_ERROR;\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister callbacks\r\n  * @param  hdma:                 pointer to a DMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified DMA Stream.\r\n  * @param  CallbackID:           User Callback identifier\r\n  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the DMA peripheral handle */\r\n  if(hdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_DMA_XFER_CPLT_CB_ID:\r\n      hdma->XferCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_HALFCPLT_CB_ID:\r\n      hdma->XferHalfCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1CPLT_CB_ID:\r\n      hdma->XferM1CpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:\r\n      hdma->XferM1HalfCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ERROR_CB_ID:\r\n      hdma->XferErrorCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_DMA_XFER_ABORT_CB_ID:\r\n      hdma->XferAbortCallback = NULL;\r\n      break;\r\n\r\n    case   HAL_DMA_XFER_ALL_CB_ID:\r\n      hdma->XferCpltCallback = NULL;\r\n      hdma->XferHalfCpltCallback = NULL;\r\n      hdma->XferM1CpltCallback = NULL;\r\n      hdma->XferM1HalfCpltCallback = NULL;\r\n      hdma->XferErrorCallback = NULL;\r\n      hdma->XferAbortCallback = NULL;\r\n      break;\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hdma);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Exported_Functions_Group3\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                    ##### State and Errors functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides functions allowing to\r\n      (+) Check the DMA state\r\n      (+) Get error code\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Returns the DMA state.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval HAL state\r\n  */\r\nHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)\r\n{\r\n  return hdma->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the DMA error code\r\n  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains\r\n  *              the configuration information for the specified DMA Stream.\r\n  * @retval DMA Error Code\r\n  */\r\nuint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)\r\n{\r\n  return hdma->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMA_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Sets the DMA Transfer parameter.\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  DataLength: The length of data to be transferred from source to destination\r\n  * @retval None\r\n  */\r\nstatic void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  /* calculate DMA base and stream number */\r\n  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;\r\n  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;\r\n\r\n  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n  {\r\n    /* Clear the DMAMUX synchro overrun flag */\r\n    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n    if(hdma->DMAmuxRequestGen != 0U)\r\n    {\r\n      /* Clear the DMAMUX request generator overrun flag */\r\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n    }\r\n  }\r\n\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    /* Clear all interrupt flags at correct offset within the register */\r\n    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n\r\n    /* Clear DBM bit */\r\n    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);\r\n\r\n    /* Configure DMA Stream data length */\r\n    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;\r\n\r\n    /* Peripheral to Memory */\r\n    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n    {\r\n      /* Configure DMA Stream destination address */\r\n      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;\r\n\r\n      /* Configure DMA Stream source address */\r\n      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;\r\n    }\r\n    /* Memory to Peripheral */\r\n    else\r\n    {\r\n      /* Configure DMA Stream source address */\r\n      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;\r\n\r\n      /* Configure DMA Stream destination address */\r\n      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;\r\n    }\r\n  }\r\n  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */\r\n  {\r\n    /* Clear all flags */\r\n    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);\r\n\r\n    /* Configure DMA Channel data length */\r\n    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;\r\n\r\n    /* Peripheral to Memory */\r\n    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n    {\r\n      /* Configure DMA Channel destination address */\r\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;\r\n\r\n      /* Configure DMA Channel source address */\r\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;\r\n    }\r\n    /* Memory to Peripheral */\r\n    else\r\n    {\r\n      /* Configure DMA Channel source address */\r\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;\r\n\r\n      /* Configure DMA Channel destination address */\r\n      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing To Do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Returns the DMA Stream base address depending on stream number\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @retval Stream base address\r\n  */\r\nstatic uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)\r\n{\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;\r\n\r\n    /* lookup table for necessary bitshift of flags within status registers */\r\n    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};\r\n    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];\r\n\r\n    if (stream_number > 3U)\r\n    {\r\n      /* return pointer to HISR and HIFCR */\r\n      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);\r\n    }\r\n    else\r\n    {\r\n      /* return pointer to LISR and LIFCR */\r\n      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));\r\n    }\r\n  }\r\n  else /* BDMA instance(s) */\r\n  {\r\n    /* return pointer to ISR and IFCR */\r\n    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));\r\n  }\r\n\r\n  return hdma->StreamBaseAddress;\r\n}\r\n\r\n/**\r\n  * @brief  Check compatibility between FIFO threshold level and size of the memory burst\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Memory Data size equal to Byte */\r\n  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)\r\n  {\r\n    switch (hdma->Init.FIFOThreshold)\r\n    {\r\n      case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n\r\n        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n        break;\r\n\r\n      case DMA_FIFO_THRESHOLD_HALFFULL:\r\n        if (hdma->Init.MemBurst == DMA_MBURST_INC16)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n        break;\r\n\r\n      case DMA_FIFO_THRESHOLD_FULL:\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /* Memory Data size equal to Half-Word */\r\n  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n  {\r\n    switch (hdma->Init.FIFOThreshold)\r\n    {\r\n      case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n        status = HAL_ERROR;\r\n        break;\r\n\r\n      case DMA_FIFO_THRESHOLD_HALFFULL:\r\n        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n        break;\r\n\r\n      case DMA_FIFO_THRESHOLD_FULL:\r\n        if (hdma->Init.MemBurst == DMA_MBURST_INC16)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /* Memory Data size equal to Word */\r\n  else\r\n  {\r\n    switch (hdma->Init.FIFOThreshold)\r\n    {\r\n      case DMA_FIFO_THRESHOLD_1QUARTERFULL:\r\n      case DMA_FIFO_THRESHOLD_HALFFULL:\r\n      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:\r\n        status = HAL_ERROR;\r\n        break;\r\n\r\n      case DMA_FIFO_THRESHOLD_FULL:\r\n        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n    break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Updates the DMA handle with the DMAMUX  channel and status mask depending on stream number\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t stream_number;\r\n  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);\r\n\r\n  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)\r\n  {\r\n    /* BDMA Channels are connected to DMAMUX2 channels */\r\n    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;\r\n    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));\r\n    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;\r\n    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);\r\n  }\r\n  else\r\n  {\r\n    /* DMA1/DMA2 Streams are connected to DMAMUX1 channels */\r\n    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;\r\n\r\n    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \\\r\n       (stream_baseaddress >= ((uint32_t)DMA2_Stream0)))\r\n    {\r\n      stream_number += 8U;\r\n    }\r\n    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));\r\n    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;\r\n    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Updates the DMA handle with the DMAMUX  request generator params\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;\r\n\r\n  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))\r\n  {\r\n    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)\r\n    {\r\n      /* BDMA Channels are connected to DMAMUX2 request generator blocks */\r\n      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));\r\n\r\n      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;\r\n    }\r\n    else\r\n    {\r\n      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */\r\n      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));\r\n\r\n      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;\r\n    }\r\n\r\n    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_DMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_dma_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_dma_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   DMA Extension HAL module driver\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the DMA Extension peripheral:\r\n  *           + Extended features functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n  The DMA Extension HAL driver can be used as follows:\r\n   (+) Start a multi buffer transfer using the HAL_DMA_MultiBufferStart() function\r\n       for polling mode or HAL_DMA_MultiBufferStart_IT() for interrupt mode.\r\n\r\n   (+) Configure the DMA_MUX Synchronization Block using HAL_DMAEx_ConfigMuxSync function.\r\n   (+) Configure the DMA_MUX Request Generator Block using HAL_DMAEx_ConfigMuxRequestGenerator function.\r\n       Functions HAL_DMAEx_EnableMuxRequestGenerator and HAL_DMAEx_DisableMuxRequestGenerator can then be used\r\n       to respectively enable/disable the request generator.\r\n\r\n   (+) To handle the DMAMUX Interrupts, the function  HAL_DMAEx_MUX_IRQHandler should be called from\r\n       the DMAMUX IRQ handler i.e DMAMUX1_OVR_IRQHandler or DMAMUX2_OVR_IRQHandler .\r\n       As only one interrupt line is available for all DMAMUX channels and request generators , HAL_DMA_MUX_IRQHandler should be\r\n       called with, as parameter, the appropriate DMA handle as many as used DMAs in the user project\r\n      (exception done if a given DMA is not using the DMAMUX SYNC block neither a request generator)\r\n\r\n     -@-  In Memory-to-Memory transfer mode, Multi (Double) Buffer mode is not allowed.\r\n     -@-  When Multi (Double) Buffer mode is enabled, the transfer is circular by default.\r\n     -@-  In Multi (Double) buffer mode, it is possible to update the base address for\r\n          the AHB memory port on the fly (DMA_SxM0AR or DMA_SxM1AR) when the stream is enabled.\r\n     -@-  Multi (Double) buffer mode is possible with DMA and BDMA instances.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup DMAEx DMAEx\r\n  * @brief DMA Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_DMA_MODULE_ENABLED\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private Constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @addtogroup DMAEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n\r\n/** @addtogroup DMAEx_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/** @addtogroup DMAEx_Exported_Functions_Group1\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                #####  Extended features functions  #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and\r\n          Start MultiBuffer DMA transfer\r\n      (+) Configure the source, destination address and data length and\r\n          Start MultiBuffer DMA transfer with interrupt\r\n      (+) Change on the fly the memory0 or memory1 address.\r\n      (+) Configure the DMA_MUX Synchronization Block using HAL_DMAEx_ConfigMuxSync function.\r\n      (+) Configure the DMA_MUX Request Generator Block using HAL_DMAEx_ConfigMuxRequestGenerator function.\r\n      (+) Functions HAL_DMAEx_EnableMuxRequestGenerator and HAL_DMAEx_DisableMuxRequestGenerator can then be used\r\n          to respectively enable/disable the request generator.\r\n      (+) Handle DMAMUX interrupts using HAL_DMAEx_MUX_IRQHandler : should be called from\r\n          the DMAMUX IRQ handler i.e DMAMUX1_OVR_IRQHandler or DMAMUX2_OVR_IRQHandler\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Starts the multi_buffer DMA Transfer.\r\n  * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer\r\n  * @param  DataLength: The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  __IO uint32_t *ifcRegister_Base; /* DMA Stream Interrupt Clear register */\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));\r\n\r\n  /* Memory-to-memory transfer not supported in double buffering mode */\r\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    status = HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hdma);\r\n\r\n    if(HAL_DMA_STATE_READY == hdma->State)\r\n    {\r\n      /* Change DMA peripheral state */\r\n      hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n      /* Initialize the error code */\r\n      hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n      {\r\n        /* Enable the Double buffer mode */\r\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;\r\n\r\n        /* Configure DMA Stream destination address */\r\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;\r\n\r\n        /* Calculate the interrupt clear flag register (IFCR) base address  */\r\n        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));\r\n\r\n        /* Clear all flags */\r\n        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n      }\r\n      else /* BDMA instance(s) */\r\n      {\r\n        /* Enable the Double buffer mode */\r\n        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);\r\n\r\n        /* Configure DMA Stream destination address */\r\n        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;\r\n\r\n        /* Calculate the interrupt clear flag register (IFCR) base address  */\r\n        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));\r\n\r\n        /* Clear all flags */\r\n        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);\r\n      }\r\n\r\n      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n      {\r\n        /* Configure the source, destination address and the data length */\r\n        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n\r\n        /* Clear the DMAMUX synchro overrun flag */\r\n        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n        if(hdma->DMAmuxRequestGen != 0U)\r\n        {\r\n          /* Clear the DMAMUX request generator overrun flag */\r\n          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n        }\r\n      }\r\n\r\n      /* Enable the peripheral */\r\n      __HAL_DMA_ENABLE(hdma);\r\n    }\r\n    else\r\n    {\r\n      /* Set the error code to busy */\r\n      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\r\n\r\n      /* Return error status */\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the multi_buffer DMA Transfer with interrupt enabled.\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer\r\n  * @param  DataLength: The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  __IO uint32_t *ifcRegister_Base; /* DMA Stream Interrupt Clear register */\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\r\n  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));\r\n\r\n  /* Memory-to-memory transfer not supported in double buffering mode */\r\n  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\r\n  {\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hdma);\r\n\r\n  if(HAL_DMA_STATE_READY == hdma->State)\r\n  {\r\n    /* Change DMA peripheral state */\r\n    hdma->State = HAL_DMA_STATE_BUSY;\r\n\r\n    /* Initialize the error code */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\r\n\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      /* Enable the Double buffer mode */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;\r\n\r\n      /* Configure DMA Stream destination address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;\r\n\r\n      /* Calculate the interrupt clear flag register (IFCR) base address  */\r\n      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));\r\n\r\n      /* Clear all flags */\r\n      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n    else /* BDMA instance(s) */\r\n    {\r\n      /* Enable the Double buffer mode */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);\r\n\r\n      /* Configure DMA Stream destination address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;\r\n\r\n      /* Calculate the interrupt clear flag register (IFCR) base address  */\r\n      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));\r\n\r\n      /* Clear all flags */\r\n      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);\r\n    }\r\n\r\n    /* Configure the source, destination address and the data length */\r\n    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\r\n\r\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n    {\r\n      /* Clear the DMAMUX synchro overrun flag */\r\n      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n      if(hdma->DMAmuxRequestGen != 0U)\r\n      {\r\n        /* Clear the DMAMUX request generator overrun flag */\r\n        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n      }\r\n    }\r\n\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      /* Enable Common interrupts*/\r\n      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;\r\n\r\n      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n      {\r\n        /*Enable Half Transfer IT if corresponding Callback is set*/\r\n        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;\r\n      }\r\n    }\r\n    else /* BDMA instance(s) */\r\n    {\r\n      /* Enable Common interrupts*/\r\n      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));\r\n\r\n      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\r\n      {\r\n        /*Enable Half Transfer IT if corresponding Callback is set*/\r\n        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;\r\n      }\r\n    }\r\n\r\n    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */\r\n    {\r\n      /* Check if DMAMUX Synchronization is enabled*/\r\n      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)\r\n      {\r\n        /* Enable DMAMUX sync overrun IT*/\r\n        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;\r\n      }\r\n\r\n      if(hdma->DMAmuxRequestGen != 0U)\r\n      {\r\n        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/\r\n        /* enable the request gen overrun IT*/\r\n        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;\r\n      }\r\n    }\r\n\r\n    /* Enable the peripheral */\r\n    __HAL_DMA_ENABLE(hdma);\r\n  }\r\n  else\r\n  {\r\n    /* Set the error code to busy */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\r\n\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Change the memory0 or memory1 address on the fly.\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  Address:    The new address\r\n  * @param  memory:     the memory to be changed, This parameter can be one of\r\n  *                     the following values:\r\n  *                      MEMORY0 /\r\n  *                      MEMORY1\r\n  * @note   The MEMORY0 address can be changed only when the current transfer use\r\n  *         MEMORY1 and the MEMORY1 address can be changed only when the current\r\n  *         transfer use MEMORY0.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)\r\n{\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    if(memory == MEMORY0)\r\n    {\r\n      /* change the memory0 address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = Address;\r\n    }\r\n    else\r\n    {\r\n      /* change the memory1 address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = Address;\r\n    }\r\n  }\r\n  else /* BDMA instance(s) */\r\n  {\r\n    if(memory == MEMORY0)\r\n    {\r\n      /* change the memory0 address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;\r\n    }\r\n    else\r\n    {\r\n      /* change the memory1 address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMAMUX synchronization parameters for a given DMA stream (instance).\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)\r\n{\r\n  uint32_t syncSignalID = 0;\r\n  uint32_t syncPolarity = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));\r\n  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));\r\n  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));\r\n  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));\r\n\r\n  if(pSyncConfig->SyncEnable == ENABLE)\r\n  {\r\n    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));\r\n\r\n    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n    {\r\n      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));\r\n    }\r\n    else\r\n    {\r\n      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));\r\n    }\r\n    syncSignalID = pSyncConfig->SyncSignalID;\r\n    syncPolarity = pSyncConfig->SyncPolarity;\r\n  }\r\n\r\n  /*Check if the DMA state is ready */\r\n  if(hdma->State == HAL_DMA_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hdma);\r\n\r\n    /* Disable the synchronization and event generation before applying a new config */\r\n    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));\r\n\r\n    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/\r\n    MODIFY_REG( hdma->DMAmuxChannel->CCR, \\\r\n               (~DMAMUX_CxCR_DMAREQ_ID) , \\\r\n               (syncSignalID << DMAMUX_CxCR_SYNC_ID_Pos)       | \\\r\n               ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \\\r\n               syncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos)    | \\\r\n               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));\r\n\r\n      /* Process Locked */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Set the error code to busy */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\r\n\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMAMUX request generator block used by the given DMA stream (instance).\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  pRequestGeneratorConfig : pointer to HAL_DMA_MuxRequestGeneratorConfigTypeDef :\r\n  *         contains the request generator parameters.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator (DMA_HandleTypeDef *hdma, HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)\r\n{\r\n  HAL_StatusTypeDef status;\r\n  HAL_DMA_StateTypeDef temp_state = hdma->State;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));\r\n\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    assert_param(IS_DMA_DMAMUX_REQUEST_GEN_SIGNAL_ID(pRequestGeneratorConfig->SignalID));\r\n  }\r\n  else\r\n  {\r\n    assert_param(IS_BDMA_DMAMUX_REQUEST_GEN_SIGNAL_ID(pRequestGeneratorConfig->SignalID));\r\n  }\r\n\r\n\r\n  assert_param(IS_DMAMUX_REQUEST_GEN_POLARITY(pRequestGeneratorConfig->Polarity));\r\n  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));\r\n\r\n  /* check if the DMA state is ready\r\n     and DMA is using a DMAMUX request generator block\r\n  */\r\n  if(hdma->DMAmuxRequestGen == 0U)\r\n  {\r\n    /* Set the error code to busy */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\r\n\r\n    /* error status */\r\n    status = HAL_ERROR;\r\n  }\r\n  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))\r\n  {\r\n    /* RequestGenerator must be disable prior to the configuration i.e GE bit is 0 */\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hdma);\r\n\r\n    /* Set the request generator new parameters */\r\n    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \\\r\n                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \\\r\n                                  pRequestGeneratorConfig->Polarity;\r\n    /* Process Locked */\r\n    __HAL_UNLOCK(hdma);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Set the error code to busy */\r\n    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;\r\n\r\n    /* error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the DMAMUX request generator block used by the given DMA stream (instance).\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator (DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));\r\n\r\n  /* check if the DMA state is ready\r\n     and DMA is using a DMAMUX request generator block */\r\n  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))\r\n  {\r\n    /* Enable the request generator*/\r\n    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;\r\n\r\n   return HAL_OK;\r\n }\r\n else\r\n {\r\n   return HAL_ERROR;\r\n }\r\n}\r\n\r\n/**\r\n  * @brief  Disable the DMAMUX request generator block used by the given DMA stream (instance).\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator (DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));\r\n\r\n  /* check if the DMA state is ready\r\n     and DMA is using a DMAMUX request generator block */\r\n  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))\r\n  {\r\n    /* Disable the request generator*/\r\n    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;\r\n\r\n   return HAL_OK;\r\n }\r\n else\r\n {\r\n   return HAL_ERROR;\r\n }\r\n}\r\n\r\n/**\r\n  * @brief  Handles DMAMUX interrupt request.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA Stream.\r\n  * @retval None\r\n  */\r\nvoid HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Check for DMAMUX Synchronization overrun */\r\n  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)\r\n  {\r\n    /* Disable the synchro overrun interrupt */\r\n    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;\r\n\r\n    /* Clear the DMAMUX synchro overrun flag */\r\n    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;\r\n\r\n    /* Update error code */\r\n    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;\r\n\r\n    if(hdma->XferErrorCallback != NULL)\r\n    {\r\n      /* Transfer error callback */\r\n      hdma->XferErrorCallback(hdma);\r\n    }\r\n  }\r\n\r\n  if(hdma->DMAmuxRequestGen != 0)\r\n  {\r\n   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */\r\n    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)\r\n    {\r\n      /* Disable the request gen overrun interrupt */\r\n      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;\r\n\r\n      /* Clear the DMAMUX request generator overrun flag */\r\n      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;\r\n\r\n      /* Update error code */\r\n      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;\r\n\r\n      if(hdma->XferErrorCallback != NULL)\r\n      {\r\n        /* Transfer error callback */\r\n        hdma->XferErrorCallback(hdma);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup DMAEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set the DMA Transfer parameter.\r\n  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified DMA Stream.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  DataLength: The length of data to be transferred from source to destination\r\n  * @retval HAL status\r\n  */\r\nstatic void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\r\n{\r\n  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */\r\n  {\r\n    /* Configure DMA Stream data length */\r\n    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;\r\n\r\n    /* Peripheral to Memory */\r\n    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n    {\r\n      /* Configure DMA Stream destination address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = DstAddress;\r\n\r\n      /* Configure DMA Stream source address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = SrcAddress;\r\n    }\r\n    /* Memory to Peripheral */\r\n    else\r\n    {\r\n      /* Configure DMA Stream source address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = SrcAddress;\r\n\r\n      /* Configure DMA Stream destination address */\r\n      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = DstAddress;\r\n    }\r\n  }\r\n  else /* BDMA instance(s) */\r\n  {\r\n    /* Configure DMA Stream data length */\r\n    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;\r\n\r\n    /* Peripheral to Memory */\r\n    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\r\n    {\r\n      /* Configure DMA Stream destination address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;\r\n\r\n      /* Configure DMA Stream source address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;\r\n    }\r\n    /* Memory to Peripheral */\r\n    else\r\n    {\r\n      /* Configure DMA Stream source address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;\r\n\r\n      /* Configure DMA Stream destination address */\r\n      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_DMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_exti.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_exti.c\r\n  * @author  MCD Application Team\r\n  * @brief   EXTI HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the General Purpose Input/Output (EXTI) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### EXTI Peripheral features #####\r\n  ==============================================================================\r\n  [..]\r\n    (+) Each Exti line can be configured within this driver.\r\n\r\n    (+) Exti line can be configured in 3 different modes\r\n        (++) Interrupt (CORE1 or CORE2 in case of dual core line )\r\n        (++) Event (CORE1 or CORE2 in case of dual core line )\r\n        (++) a combination of the previous\r\n\r\n    (+) Configurable Exti lines can be configured with 3 different triggers\r\n        (++) Rising\r\n        (++) Falling\r\n        (++) Both of them\r\n\r\n    (+) When set in interrupt mode, configurable Exti lines have two diffenrents\r\n        interrupt pending registers which allow to distinguish which transition\r\n        occurs:\r\n        (++) Rising edge pending interrupt\r\n        (++) Falling\r\n\r\n    (+) Exti lines 0 to 15 are linked to gpio pin number 0 to 15. Gpio port can\r\n        be selected through multiplexer.\r\n\r\n    (+) PendClearSource used to set the D3 Smart Run Domain autoamtic pend clear source.\r\n        It is applicable for line with wkaeup target is Any (CPU1 , CPU2 and D3 smart run domain).\r\n        Value can be one of the following:\r\n        (++)  EXTI_D3_PENDCLR_SRC_NONE : no pend clear source is selected :\r\n              In this case corresponding bit of D2PMRx register is set to 0\r\n                (+++) On a configurable Line : the D3 domain wakeup signal is\r\n                      automatically cleared after after the Delay + Rising Edge detect\r\n                (+++) On a direct Line : the D3 domain wakeup signal is\r\n                      cleared after the direct event input signal is cleared\r\n\r\n        (++)  EXTI_D3_PENDCLR_SRC_DMACH6 : no pend clear source is selected :\r\n              In this case corresponding bit of D2PMRx register is set to 1\r\n              and corresponding bits(2) of D3PCRxL/H is set to b00 :\r\n                DMA ch6 event selected as D3 domain pendclear source\r\n\r\n        (++)  EXTI_D3_PENDCLR_SRC_DMACH7 : no pend clear source is selected :\r\n              In this case corresponding bit of D2PMRx register is set to 1\r\n              and corresponding bits(2) of D3PCRxL/H is set to b01 :\r\n                DMA ch7 event selected as D3 domain pendclear source\r\n\r\n        (++)  EXTI_D3_PENDCLR_SRC_LPTIM4 : no pend clear source is selected :\r\n              In this case corresponding bit of D2PMRx register is set to 1\r\n              and corresponding bits(2) of D3PCRxL/H is set to b10 :\r\n                LPTIM4 out selected as D3 domain pendclear source\r\n\r\n        (++)  EXTI_D3_PENDCLR_SRC_LPTIM5 : no pend clear source is selected :\r\n              In this case corresponding bit of D2PMRx register is set to 1\r\n              and corresponding bits(2) of D3PCRxL/H is set to b11 :\r\n                LPTIM5 out selected as D3 domain pendclear source\r\n\r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n\r\n    (#) Configure the EXTI line using HAL_EXTI_SetConfigLine().\r\n        (++) Choose the interrupt line number by setting \"Line\" member from\r\n             EXTI_ConfigTypeDef structure.\r\n        (++) Configure the interrupt and/or event mode using \"Mode\" member from\r\n             EXTI_ConfigTypeDef structure.\r\n        (++) For configurable lines, configure rising and/or falling trigger\r\n             \"Trigger\" member from EXTI_ConfigTypeDef structure.\r\n        (++) For Exti lines linked to gpio, choose gpio port using \"GPIOSel\"\r\n             member from GPIO_InitTypeDef structure.\r\n        (++) For Exti lines with wkaeup target is Any (CPU1 , CPU2 and D3 smart run domain),\r\n             choose gpio D3 PendClearSource using PendClearSource\r\n             member from EXTI_PendClear_Source structure.\r\n\r\n    (#) Get current Exti configuration of a dedicated line using\r\n        HAL_EXTI_GetConfigLine().\r\n        (++) Provide exiting handle as parameter.\r\n        (++) Provide pointer on EXTI_ConfigTypeDef structure as second parameter.\r\n\r\n    (#) Clear Exti configuration of a dedicated line using HAL_EXTI_GetConfigLine().\r\n        (++) Provide exiting handle as parameter.\r\n\r\n    (#) Register callback to treat Exti interrupts using HAL_EXTI_RegisterCallback().\r\n        (++) Provide exiting handle as first parameter.\r\n        (++) Provide which callback will be registered using one value from\r\n             EXTI_CallbackIDTypeDef.\r\n        (++) Provide callback function pointer.\r\n\r\n    (#) Get interrupt pending bit using HAL_EXTI_GetPending().\r\n\r\n    (#) Clear interrupt pending bit using HAL_EXTI_GetPending().\r\n\r\n    (#) Generate software interrupt using HAL_EXTI_GenerateSWI().\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_EXTI_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines ------------------------------------------------------------*/\r\n/** @defgroup EXTI_Private_Constants EXTI Private Constants\r\n  * @{\r\n  */\r\n#define EXTI_MODE_OFFSET                    0x04U   /* 0x10: offset between CPU IMR/EMR registers */\r\n#define EXTI_CONFIG_OFFSET                  0x08U   /* 0x20: offset between CPU Rising/Falling configuration registers */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @addtogroup EXTI_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI_Exported_Functions_Group1\r\n *  @brief    Configuration functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Configuration functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  pExtiConfig Pointer on EXTI configuration to be set.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n  uint32_t pcrlinepos;\r\n\r\n  /* Check null pointer */\r\n  if ((hexti == NULL) || (pExtiConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_EXTI_LINE(pExtiConfig->Line));\r\n  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));\r\n\r\n  /* Assign line number to handle */\r\n  hexti->Line = pExtiConfig->Line;\r\n\r\n  /* compute line register offset and line mask */\r\n  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\r\n  maskline = (1UL << linepos);\r\n\r\n  /* Configure triggers for configurable lines */\r\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)\r\n  {\r\n    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));\r\n\r\n    /* Configure rising trigger */\r\n    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = *regaddr;\r\n\r\n    /* Mask or set line */\r\n    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)\r\n    {\r\n      regval |= maskline;\r\n    }\r\n    else\r\n    {\r\n      regval &= ~maskline;\r\n    }\r\n\r\n    /* Store rising trigger mode */\r\n    *regaddr = regval;\r\n\r\n    /* Configure falling trigger */\r\n    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = *regaddr;\r\n\r\n    /* Mask or set line */\r\n    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)\r\n    {\r\n      regval |= maskline;\r\n    }\r\n    else\r\n    {\r\n      regval &= ~maskline;\r\n    }\r\n\r\n    /* Store falling trigger mode */\r\n    *regaddr = regval;\r\n\r\n    /* Configure gpio port selection in case of gpio exti line */\r\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];\r\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));\r\n      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));\r\n      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;\r\n    }\r\n  }\r\n\r\n  /* Configure interrupt mode : read current mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)\r\n  {\r\n    regval |= maskline;\r\n  }\r\n  else\r\n  {\r\n    regval &= ~maskline;\r\n  }\r\n\r\n  /* Store interrupt mode */\r\n  *regaddr = regval;\r\n\r\n  /* The event mode cannot be configured if the line does not support it */\r\n  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_EVENT) != EXTI_MODE_EVENT));\r\n\r\n  /* Configure event mode : read current mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)\r\n  {\r\n    regval |= maskline;\r\n  }\r\n  else\r\n  {\r\n    regval &= ~maskline;\r\n  }\r\n\r\n  /* Store event mode */\r\n  *regaddr = regval;\r\n\r\n#if defined (DUAL_CORE)\r\n  /* Configure interrupt mode for Core2 : read current mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->C2IMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_CORE2_INTERRUPT) != 0x00U)\r\n  {\r\n    regval |= maskline;\r\n  }\r\n  else\r\n  {\r\n    regval &= ~maskline;\r\n  }\r\n\r\n  /* Store interrupt mode */\r\n  *regaddr = regval;\r\n\r\n  /* The event mode cannot be configured if the line does not support it */\r\n  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_CORE2_EVENT) != EXTI_MODE_CORE2_EVENT));\r\n\r\n  /* Configure event mode : read current mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->C2EMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Mask or set line */\r\n  if ((pExtiConfig->Mode & EXTI_MODE_CORE2_EVENT) != 0x00U)\r\n  {\r\n    regval |= maskline;\r\n  }\r\n  else\r\n  {\r\n    regval &= ~maskline;\r\n  }\r\n\r\n  /* Store event mode */\r\n  *regaddr = regval;\r\n#endif /* DUAL_CORE */\r\n\r\n  /* Configure the D3 PendClear source in case of Wakeup target is Any */\r\n  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)\r\n  {\r\n    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));\r\n\r\n    /*Calc the PMR register address for the given line */\r\n    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = *regaddr;\r\n\r\n    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)\r\n    {\r\n      /* Clear D3PMRx register for the given line */\r\n      regval &= ~maskline;\r\n      /* Store D3PMRx register value */\r\n      *regaddr = regval;\r\n    }\r\n    else\r\n    {\r\n      /* Set D3PMRx register to 1 for the given line */\r\n      regval |= maskline;\r\n      /* Store D3PMRx register value */\r\n      *regaddr = regval;\r\n\r\n      if(linepos < 16UL)\r\n      {\r\n        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));\r\n        pcrlinepos = 1UL << linepos;\r\n      }\r\n      else\r\n      {\r\n        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));\r\n        pcrlinepos = 1UL << (linepos - 16UL);\r\n      }\r\n\r\n      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));\r\n      *regaddr = regval;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Get configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  pExtiConfig Pointer on structure to store Exti configuration.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n  uint32_t pcrlinepos;\r\n\r\n  /* Check null pointer */\r\n  if ((hexti == NULL) || (pExtiConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n\r\n  /* Store handle line number to configuration structure */\r\n  pExtiConfig->Line = hexti->Line;\r\n\r\n  /* compute line register offset and line mask */\r\n  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);\r\n  maskline = (1UL << linepos);\r\n\r\n  /* 1] Get core mode : interrupt */\r\n  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  pExtiConfig->Mode = EXTI_MODE_NONE;\r\n\r\n  /* Check if selected line is enable */\r\n  if ((regval & maskline) != 0x00U)\r\n  {\r\n    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;\r\n  }\r\n\r\n  /* Get event mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Check if selected line is enable */\r\n  if ((regval & maskline) != 0x00U)\r\n  {\r\n    pExtiConfig->Mode |= EXTI_MODE_EVENT;\r\n  }\r\n#if defined (DUAL_CORE)\r\n  regaddr = (__IO uint32_t *)(&EXTI->C2IMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Check if selected line is enable */\r\n  if ((regval & maskline) != 0x00U)\r\n  {\r\n    pExtiConfig->Mode = EXTI_MODE_CORE2_INTERRUPT;\r\n  }\r\n\r\n  /* Get event mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->C2EMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = *regaddr;\r\n\r\n  /* Check if selected line is enable */\r\n  if ((regval & maskline) != 0x00U)\r\n  {\r\n    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;\r\n  }\r\n#endif /*DUAL_CORE*/\r\n\r\n  /* Get default Trigger and GPIOSel configuration */\r\n  pExtiConfig->Trigger = EXTI_TRIGGER_NONE;\r\n  pExtiConfig->GPIOSel = 0x00U;\r\n\r\n  /* 2] Get trigger for configurable lines : rising */\r\n  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)\r\n  {\r\n    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = *regaddr;\r\n\r\n    /* Check if configuration of selected line is enable */\r\n    if ((regval & maskline) != 0x00U)\r\n    {\r\n      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;\r\n    }\r\n\r\n    /* Get falling configuration */\r\n    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = *regaddr;\r\n\r\n    /* Check if configuration of selected line is enable */\r\n    if ((regval & maskline) != 0x00U)\r\n    {\r\n      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;\r\n    }\r\n\r\n    /* Get Gpio port selection for gpio lines */\r\n    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];\r\n      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);\r\n    }\r\n  }\r\n\r\n  /* Get default Pend Clear Source */\r\n  pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;\r\n\r\n  /* 3] Get D3 Pend Clear source */\r\n  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)\r\n  {\r\n    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    if(((*regaddr) & linepos) != 0UL)\r\n    {\r\n      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */\r\n      if(linepos < 16UL)\r\n      {\r\n        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));\r\n        pcrlinepos = 1UL << linepos;\r\n      }\r\n      else\r\n      {\r\n        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));\r\n        pcrlinepos = 1UL << (linepos - 16UL);\r\n      }\r\n\r\n      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Clear whole configuration of a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n  uint32_t pcrlinepos;\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameter */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n\r\n  /* compute line register offset and line mask */\r\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  linepos = (hexti->Line & EXTI_PIN_MASK);\r\n  maskline = (1UL << linepos);\r\n\r\n  /* 1] Clear interrupt mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = (*regaddr & ~maskline);\r\n  *regaddr = regval;\r\n\r\n  /* 2] Clear event mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = (*regaddr & ~maskline);\r\n  *regaddr = regval;\r\n\r\n#if defined (DUAL_CORE)\r\n    /* 1] Clear CM4 interrupt mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->C2IMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = (*regaddr & ~maskline);\r\n  *regaddr = regval;\r\n\r\n  /* 2] Clear CM4 event mode */\r\n  regaddr = (__IO uint32_t *)(&EXTI->C2EMR1 + (EXTI_MODE_OFFSET * offset));\r\n  regval = (*regaddr & ~maskline);\r\n  *regaddr = regval;\r\n#endif /* DUAL_CORE */\r\n\r\n  /* 3] Clear triggers in case of configurable lines */\r\n  if ((hexti->Line & EXTI_CONFIG) != 0x00U)\r\n  {\r\n    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = (*regaddr & ~maskline);\r\n    *regaddr = regval;\r\n\r\n    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    regval = (*regaddr & ~maskline);\r\n    *regaddr = regval;\r\n\r\n    /* Get Gpio port selection for gpio lines */\r\n    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)\r\n    {\r\n      assert_param(IS_EXTI_GPIO_PIN(linepos));\r\n\r\n      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];\r\n      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));\r\n      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;\r\n    }\r\n  }\r\n\r\n  /* 4] Clear D3 Config lines */\r\n  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)\r\n  {\r\n    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));\r\n    *regaddr = (*regaddr & ~maskline);\r\n\r\n    if(linepos < 16UL)\r\n    {\r\n      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));\r\n      pcrlinepos = 1UL << linepos;\r\n    }\r\n    else\r\n    {\r\n      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));\r\n      pcrlinepos = 1UL << (linepos - 16UL);\r\n    }\r\n\r\n    /*Clear D3 PendClear source */\r\n    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Register callback for a dedicated Exti line.\r\n  * @param  hexti Exti handle.\r\n  * @param  CallbackID User callback identifier.\r\n  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.\r\n  * @param  pPendingCbfn function pointer to be stored as callback.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (CallbackID)\r\n  {\r\n    case  HAL_EXTI_COMMON_CB_ID:\r\n      hexti->PendingCallback = pPendingCbfn;\r\n      break;\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Store line number as handle private field.\r\n  * @param  hexti Exti handle.\r\n  * @param  ExtiLine Exti line number.\r\n  *         This parameter can be from 0 to @ref EXTI_LINE_NB.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_EXTI_LINE(ExtiLine));\r\n\r\n  /* Check null pointer */\r\n  if (hexti == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Store line number as handle private field */\r\n    hexti->Line = ExtiLine;\r\n\r\n    return HAL_OK;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup EXTI_Exported_Functions_Group2\r\n *  @brief EXTI IO functions.\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                       ##### IO operation functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Handle EXTI interrupt request.\r\n  * @param  hexti Exti handle.\r\n  * @retval none.\r\n  */\r\nvoid HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t regval;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n\r\n  /* Compute line register offset and line mask */\r\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n#if defined(DUAL_CORE)\r\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\r\n  {\r\n    /* Get pending register address */\r\n    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\r\n  }\r\n  else /* Cortex-M4*/\r\n  {\r\n    /* Get pending register address */\r\n    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));\r\n  }\r\n#else\r\n  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\r\n#endif /* DUAL_CORE */\r\n\r\n  /* Get pending bit  */\r\n  regval = (*regaddr & maskline);\r\n\r\n  if (regval != 0x00U)\r\n  {\r\n    /* Clear pending bit */\r\n    *regaddr = maskline;\r\n\r\n    /* Call callback */\r\n    if (hexti->PendingCallback != NULL)\r\n    {\r\n      hexti->PendingCallback();\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Get interrupt pending bit of a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @param  Edge Specify which pending edge as to be checked.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\r\n  *         This parameter is kept for compatibility with other series.\r\n  * @retval 1 if interrupt is pending else 0.\r\n  */\r\nuint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t regval;\r\n  uint32_t linepos;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\r\n\r\n  /* compute line register offset and line mask */\r\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  linepos = (hexti->Line & EXTI_PIN_MASK);\r\n  maskline = (1UL << linepos);\r\n\r\n#if defined(DUAL_CORE)\r\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\r\n  {\r\n    /* Get pending register address */\r\n    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\r\n  }\r\n  else /* Cortex-M4 */\r\n  {\r\n    /* Get pending register address */\r\n    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));\r\n  }\r\n#else\r\n  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\r\n#endif /* DUAL_CORE */\r\n\r\n  /* return 1 if bit is set else 0 */\r\n  regval = ((*regaddr & maskline) >> linepos);\r\n  return regval;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Clear interrupt pending bit of a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @param  Edge Specify which pending edge as to be clear.\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref EXTI_TRIGGER_RISING_FALLING\r\n  *         This parameter is kept for compatibility with other series.\r\n  * @retval None.\r\n  */\r\nvoid HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_PENDING_EDGE(Edge));\r\n\r\n  /* compute line register offset and line mask */\r\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n#if defined(DUAL_CORE)\r\n  if (HAL_GetCurrentCPUID() == CM7_CPUID)\r\n  {\r\n    /* Get pending register address */\r\n    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\r\n  }\r\n  else /* Cortex-M4 */\r\n  {\r\n    /* Get pending register address */\r\n    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));\r\n  }\r\n#else\r\n  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));\r\n#endif /* DUAL_CORE */\r\n\r\n  /* Clear Pending bit */\r\n  *regaddr =  maskline;\r\n}\r\n\r\n/**\r\n  * @brief  Generate a software interrupt for a dedicated line.\r\n  * @param  hexti Exti handle.\r\n  * @retval None.\r\n  */\r\nvoid HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)\r\n{\r\n  __IO uint32_t *regaddr;\r\n  uint32_t maskline;\r\n  uint32_t offset;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_EXTI_LINE(hexti->Line));\r\n  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));\r\n\r\n  /* compute line register offset and line mask */\r\n  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);\r\n  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));\r\n\r\n  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));\r\n  *regaddr = maskline;\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_EXTI_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_flash.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_flash.c\r\n  * @author  MCD Application Team\r\n  * @brief   FLASH HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the internal FLASH memory:\r\n  *           + Program operations functions\r\n  *           + Memory Control functions\r\n  *           + Peripheral Errors functions\r\n  *\r\n @verbatim\r\n  ==============================================================================\r\n                        ##### FLASH peripheral features #####\r\n  ==============================================================================\r\n\r\n  [..] The Flash memory interface manages CPU AXI I-Code and D-Code accesses\r\n       to the Flash memory. It implements the erase and program Flash memory operations\r\n       and the read and write protection mechanisms.\r\n\r\n  [..] The FLASH main features are:\r\n      (+) Flash memory read operations\r\n      (+) Flash memory program/erase operations\r\n      (+) Read / write protections\r\n      (+) Option bytes programming\r\n      (+) Error code correction (ECC) : Data in flash are 266-bits word\r\n          (10 bits added per flash word)\r\n\r\n                        ##### How to use this driver #####\r\n ==============================================================================\r\n    [..]\r\n      This driver provides functions and macros to configure and program the FLASH\r\n      memory of all STM32H7xx devices.\r\n\r\n      (#) FLASH Memory IO Programming functions:\r\n           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and\r\n                HAL_FLASH_Lock() functions\r\n           (++) Program functions: 256-bit word only\r\n           (++) There Two modes of programming :\r\n            (+++) Polling mode using HAL_FLASH_Program() function\r\n            (+++) Interrupt mode using HAL_FLASH_Program_IT() function\r\n\r\n      (#) Interrupts and flags management functions :\r\n           (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()\r\n           (++) Callback functions are called when the flash operations are finished :\r\n                HAL_FLASH_EndOfOperationCallback() when everything is ok, otherwise\r\n                HAL_FLASH_OperationErrorCallback()\r\n           (++) Get error flag status by calling HAL_FLASH_GetError()\r\n\r\n      (#) Option bytes management functions :\r\n           (++) Lock and Unlock the option bytes using HAL_FLASH_OB_Unlock() and\r\n                HAL_FLASH_OB_Lock() functions\r\n           (++) Launch the reload of the option bytes using HAL_FLASH_OB_Launch() function.\r\n                In this case, a reset is generated\r\n    [..]\r\n      In addition to these functions, this driver includes a set of macros allowing\r\n      to handle the following operations:\r\n       (+) Set the latency\r\n       (+) Enable/Disable the FLASH interrupts\r\n       (+) Monitor the FLASH flags status\r\n     [..]\r\n    (@) For any Flash memory program operation (erase or program), the CPU clock frequency\r\n        (HCLK) must be at least 1MHz.\r\n    (@) The contents of the Flash memory are not guaranteed if a device reset occurs during\r\n        a Flash memory operation.\r\n    (@) The application can simultaneously request a read and a write operation through each AXI\r\n        interface.\r\n        As the Flash memory is divided into two independent banks, the embedded Flash\r\n        memory interface can drive different operations at the same time on each bank. For\r\n        example a read, write or erase operation can be executed on bank 1 while another read,\r\n        write or erase operation is executed on bank 2.\r\n\r\n @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASH FLASH\r\n  * @brief FLASH HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup FLASH_Private_Constants\r\n  * @{\r\n  */\r\n#define FLASH_TIMEOUT_VALUE              50000U /* 50 s */\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\nFLASH_ProcessTypeDef pFlash;\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup FLASH_Exported_Functions FLASH Exported functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions\r\n *  @brief   Programming operation functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                  ##### Programming operation functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the FLASH\r\n    program operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Program a flash word at a specified address\r\n  * @param  TypeProgram Indicate the way to program at a specified address.\r\n  *         This parameter can be a value of @ref FLASH_Type_Program\r\n  * @param  FlashAddress specifies the address to be programmed.\r\n  *         This parameter shall be aligned to the Flash word:\r\n  *          - 256 bits for STM32H74x/5X devices (8x 32bits words)\r\n  *          - 128 bits for STM32H7Ax/BX devices (4x 32bits words)\r\n  *          - 256 bits for STM32H72x/3X devices (8x 32bits words)\r\n  * @param  DataAddress specifies the address of data to be programmed.\r\n  *         This parameter shall be 32-bit aligned\r\n  *\r\n  * @retval HAL_StatusTypeDef HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)\r\n{\r\n  HAL_StatusTypeDef status;\r\n  __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;\r\n  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;\r\n  uint32_t bank;\r\n  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));\r\n  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))\r\n#else\r\n  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n  {\r\n    bank = FLASH_BANK_1;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else if(IS_FLASH_PROGRAM_ADDRESS_BANK2(FlashAddress))\r\n  {\r\n    bank = FLASH_BANK_2;\r\n  }\r\n#endif /* DUAL_BANK */\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Reset error code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);\r\n\r\n  if(status == HAL_OK)\r\n  {\r\n#if defined (DUAL_BANK)\r\n    if(bank == FLASH_BANK_1)\r\n    {\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n      if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n      {\r\n        /* Set OTP_PG bit */\r\n        SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);\r\n      }\r\n      else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n      {\r\n        /* Set PG bit */\r\n        SET_BIT(FLASH->CR1, FLASH_CR_PG);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Set PG bit */\r\n      SET_BIT(FLASH->CR2, FLASH_CR_PG);\r\n    }\r\n#else /* Single Bank */\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n      if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n      {\r\n        /* Set OTP_PG bit */\r\n        SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);\r\n      }\r\n      else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n      {\r\n        /* Set PG bit */\r\n        SET_BIT(FLASH->CR1, FLASH_CR_PG);\r\n      }\r\n#endif /* DUAL_BANK */\r\n\r\n    __ISB();\r\n    __DSB();\r\n\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n    if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n    {\r\n      /* Program an OTP word (16 bits) */\r\n      *(__IO uint16_t *)FlashAddress = *(__IO uint16_t*)DataAddress;\r\n    }\r\n    else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n    {\r\n      /* Program the flash word */\r\n      do\r\n      {\r\n        *dest_addr = *src_addr;\r\n        dest_addr++;\r\n        src_addr++;\r\n        row_index--;\r\n     } while (row_index != 0U);\r\n    }\r\n\r\n    __ISB();\r\n    __DSB();\r\n\r\n    /* Wait for last operation to be completed */\r\n    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);\r\n\r\n#if defined (DUAL_BANK)\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n    if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n    {\r\n      /* If the program operation is completed, disable the OTP_PG */\r\n      CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);\r\n    }\r\n    else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n    {\r\n      if(bank == FLASH_BANK_1)\r\n      {\r\n        /* If the program operation is completed, disable the PG */\r\n        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);\r\n      }\r\n      else\r\n      {\r\n        /* If the program operation is completed, disable the PG */\r\n        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);\r\n      }\r\n    }\r\n#else /* Single Bank */\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n    if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n    {\r\n      /* If the program operation is completed, disable the OTP_PG */\r\n      CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);\r\n    }\r\n    else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n    {\r\n      /* If the program operation is completed, disable the PG */\r\n      CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);\r\n    }\r\n#endif /* DUAL_BANK */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Program a flash word at a specified address with interrupt enabled.\r\n  * @param  TypeProgram Indicate the way to program at a specified address.\r\n  *                      This parameter can be a value of @ref FLASH_Type_Program\r\n  * @param  FlashAddress specifies the address to be programmed.\r\n  *         This parameter shall be aligned to the Flash word:\r\n  *          - 256 bits for STM32H74x/5X devices (8x 32bits words)\r\n  *          - 128 bits for STM32H7Ax/BX devices (4x 32bits words)\r\n  *          - 256 bits for STM32H72x/3X devices (8x 32bits words)\r\n  * @param  DataAddress specifies the address of data to be programmed.\r\n  *         This parameter shall be 32-bit aligned\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)\r\n{\r\n  HAL_StatusTypeDef status;\r\n  __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;\r\n  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;\r\n  uint32_t bank;\r\n  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));\r\n  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Reset error code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))\r\n#else\r\n  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n  {\r\n    bank = FLASH_BANK_1;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else if(IS_FLASH_PROGRAM_ADDRESS_BANK2(FlashAddress))\r\n  {\r\n    bank = FLASH_BANK_2;\r\n  }\r\n#endif /* DUAL_BANK */\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Wait for last operation to be completed */\r\n  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);\r\n\r\n  if (status != HAL_OK)\r\n  {\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(&pFlash);\r\n  }\r\n  else\r\n  {\r\n    pFlash.Address = FlashAddress;\r\n\r\n#if defined (DUAL_BANK)\r\n    if(bank == FLASH_BANK_1)\r\n    {\r\n      /* Set internal variables used by the IRQ handler */\r\n      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;\r\n\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n      if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n      {\r\n        /* Set OTP_PG bit */\r\n        SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);\r\n      }\r\n      else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n      {\r\n        /* Set PG bit */\r\n        SET_BIT(FLASH->CR1, FLASH_CR_PG);\r\n      }\r\n\r\n      /* Enable End of Operation and Error interrupts for Bank 1 */\r\n#if defined (FLASH_CR_OPERRIE)\r\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);\r\n#else\r\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);\r\n#endif /* FLASH_CR_OPERRIE */\r\n    }\r\n    else\r\n    {\r\n      /* Set internal variables used by the IRQ handler */\r\n      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK2;\r\n\r\n      /* Set PG bit */\r\n      SET_BIT(FLASH->CR2, FLASH_CR_PG);\r\n\r\n      /* Enable End of Operation and Error interrupts for Bank2 */\r\n#if defined (FLASH_CR_OPERRIE)\r\n      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\r\n                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2 | FLASH_IT_OPERR_BANK2);\r\n#else\r\n      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\r\n                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);\r\n#endif /* FLASH_CR_OPERRIE */\r\n    }\r\n#else /* Single Bank */\r\n    /* Set internal variables used by the IRQ handler */\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;\r\n\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n    if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n    {\r\n      /* Set OTP_PG bit */\r\n      SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);\r\n    }\r\n    else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n    {\r\n      /* Set PG bit */\r\n      SET_BIT(FLASH->CR1, FLASH_CR_PG);\r\n    }\r\n\r\n      /* Enable End of Operation and Error interrupts for Bank 1 */\r\n#if defined (FLASH_CR_OPERRIE)\r\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);\r\n#else\r\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);\r\n#endif /* FLASH_CR_OPERRIE */\r\n#endif /* DUAL_BANK */\r\n\r\n    __ISB();\r\n    __DSB();\r\n\r\n#if defined (FLASH_OPTCR_PG_OTP)\r\n    if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)\r\n    {\r\n      /* Program an OTP word (16 bits) */\r\n      *(__IO uint16_t *)FlashAddress = *(__IO uint16_t*)DataAddress;\r\n    }\r\n    else\r\n#endif /* FLASH_OPTCR_PG_OTP */\r\n    {\r\n      /* Program the flash word */\r\n      do\r\n      {\r\n        *dest_addr = *src_addr;\r\n        dest_addr++;\r\n        src_addr++;\r\n        row_index--;\r\n      } while (row_index != 0U);\r\n    }\r\n\r\n    __ISB();\r\n    __DSB();\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief This function handles FLASH interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_FLASH_IRQHandler(void)\r\n{\r\n  uint32_t temp;\r\n  uint32_t errorflag;\r\n  FLASH_ProcedureTypeDef procedure;\r\n\r\n  /* Check FLASH Bank1 End of Operation flag  */\r\n  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)\r\n  {\r\n    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)\r\n    {\r\n      /* Nb of sector to erased can be decreased */\r\n      pFlash.NbSectorsToErase--;\r\n\r\n      /* Check if there are still sectors to erase */\r\n      if(pFlash.NbSectorsToErase != 0U)\r\n      {\r\n        /* Indicate user which sector has been erased */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);\r\n\r\n        /* Clear bank 1 End of Operation pending bit */\r\n        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);\r\n\r\n        /* Increment sector number */\r\n        pFlash.Sector++;\r\n        temp = pFlash.Sector;\r\n        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);\r\n      }\r\n      else\r\n      {\r\n        /* No more sectors to Erase, user callback can be called */\r\n        /* Reset Sector and stop Erase sectors procedure */\r\n        pFlash.Sector = 0xFFFFFFFFU;\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);\r\n\r\n        /* Clear FLASH End of Operation pending bit */\r\n        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      procedure = pFlash.ProcedureOnGoing;\r\n\r\n      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))\r\n      {\r\n        /* MassErase ended. Return the selected bank */\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);\r\n      }\r\n      else if(procedure == FLASH_PROC_PROGRAM_BANK1)\r\n      {\r\n        /* Program ended. Return the selected address */\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Address);\r\n      }\r\n      else\r\n      {\r\n        /* Nothing to do */\r\n      }\r\n\r\n      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \\\r\n         (procedure != FLASH_PROC_MASSERASE_BANK2) && \\\r\n         (procedure != FLASH_PROC_PROGRAM_BANK2))\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n        /* Clear FLASH End of Operation pending bit */\r\n        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);\r\n      }\r\n    }\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n /* Check FLASH Bank2 End of Operation flag  */\r\n  if(__HAL_FLASH_GET_FLAG_BANK2(FLASH_SR_EOP) != RESET)\r\n  {\r\n    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK2)\r\n    {\r\n      /*Nb of sector to erased can be decreased*/\r\n      pFlash.NbSectorsToErase--;\r\n\r\n      /* Check if there are still sectors to erase*/\r\n      if(pFlash.NbSectorsToErase != 0U)\r\n      {\r\n        /*Indicate user which sector has been erased*/\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);\r\n\r\n        /* Clear bank 2 End of Operation pending bit */\r\n        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);\r\n\r\n        /*Increment sector number*/\r\n        pFlash.Sector++;\r\n        temp = pFlash.Sector;\r\n        FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);\r\n      }\r\n      else\r\n      {\r\n        /* No more sectors to Erase, user callback can be called */\r\n        /* Reset Sector and stop Erase sectors procedure */\r\n        pFlash.Sector = 0xFFFFFFFFU;\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);\r\n\r\n        /* Clear FLASH End of Operation pending bit */\r\n        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      procedure = pFlash.ProcedureOnGoing;\r\n\r\n      if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))\r\n      {\r\n        /*MassErase ended. Return the selected bank*/\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_2);\r\n      }\r\n      else if(procedure == FLASH_PROC_PROGRAM_BANK2)\r\n      {\r\n        /* Program ended. Return the selected address */\r\n        /* FLASH EOP interrupt user callback */\r\n        HAL_FLASH_EndOfOperationCallback(pFlash.Address);\r\n      }\r\n      else\r\n      {\r\n        /* Nothing to do */\r\n      }\r\n\r\n      if((procedure != FLASH_PROC_SECTERASE_BANK1) && \\\r\n         (procedure != FLASH_PROC_MASSERASE_BANK1) && \\\r\n         (procedure != FLASH_PROC_PROGRAM_BANK1))\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n        /* Clear FLASH End of Operation pending bit */\r\n        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);\r\n      }\r\n    }\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  /* Check FLASH Bank1 operation error flags */\r\n#if defined (FLASH_SR_OPERR)\r\n  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \\\r\n                            FLASH_FLAG_INCERR_BANK1 | FLASH_FLAG_OPERR_BANK1);\r\n#else\r\n  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \\\r\n                            FLASH_FLAG_INCERR_BANK1);\r\n#endif /* FLASH_SR_OPERR */\r\n\r\n  if(errorflag != 0U)\r\n  {\r\n    /* Save the error code */\r\n    pFlash.ErrorCode |= errorflag;\r\n\r\n    /* Clear error programming flags */\r\n    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);\r\n\r\n    procedure = pFlash.ProcedureOnGoing;\r\n\r\n    if(procedure == FLASH_PROC_SECTERASE_BANK1)\r\n    {\r\n      /* Return the faulty sector */\r\n      temp = pFlash.Sector;\r\n      pFlash.Sector = 0xFFFFFFFFU;\r\n    }\r\n    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))\r\n    {\r\n      /* Return the faulty bank */\r\n      temp = FLASH_BANK_1;\r\n    }\r\n    else\r\n    {\r\n      /* Return the faulty address */\r\n      temp = pFlash.Address;\r\n    }\r\n\r\n    /* Stop the procedure ongoing*/\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n\r\n    /* FLASH error interrupt user callback */\r\n    HAL_FLASH_OperationErrorCallback(temp);\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  /* Check FLASH Bank2 operation error flags */\r\n#if defined (FLASH_SR_OPERR)\r\n  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \\\r\n                             FLASH_FLAG_INCERR_BANK2 | FLASH_FLAG_OPERR_BANK2) & 0x7FFFFFFFU);\r\n#else\r\n  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \\\r\n                             FLASH_FLAG_INCERR_BANK2) & 0x7FFFFFFFU);\r\n#endif /* FLASH_SR_OPERR */\r\n\r\n  if(errorflag != 0U)\r\n  {\r\n    /* Save the error code */\r\n    pFlash.ErrorCode |= (errorflag | 0x80000000U);\r\n\r\n    /* Clear error programming flags */\r\n    __HAL_FLASH_CLEAR_FLAG_BANK2(errorflag);\r\n\r\n    procedure = pFlash.ProcedureOnGoing;\r\n\r\n    if(procedure== FLASH_PROC_SECTERASE_BANK2)\r\n    {\r\n      /*return the faulty sector*/\r\n      temp = pFlash.Sector;\r\n      pFlash.Sector = 0xFFFFFFFFU;\r\n    }\r\n    else if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))\r\n    {\r\n      /*return the faulty bank*/\r\n      temp = FLASH_BANK_2;\r\n    }\r\n    else\r\n    {\r\n      /*return the faulty address*/\r\n      temp = pFlash.Address;\r\n    }\r\n\r\n    /*Stop the procedure ongoing*/\r\n    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;\r\n\r\n    /* FLASH error interrupt user callback */\r\n    HAL_FLASH_OperationErrorCallback(temp);\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)\r\n  {\r\n#if defined (FLASH_CR_OPERRIE)\r\n    /* Disable Bank1 Operation and Error source interrupt */\r\n    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                 FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);\r\n\r\n#if defined (DUAL_BANK)\r\n    /* Disable Bank2 Operation and Error source interrupt */\r\n    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\r\n                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2 | FLASH_IT_OPERR_BANK2);\r\n#endif /* DUAL_BANK */\r\n#else\r\n    /* Disable Bank1 Operation and Error source interrupt */\r\n    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                 FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);\r\n\r\n#if defined (DUAL_BANK)\r\n    /* Disable Bank2 Operation and Error source interrupt */\r\n    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\r\n                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);\r\n#endif /* DUAL_BANK */\r\n#endif /* FLASH_CR_OPERRIE */\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(&pFlash);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  FLASH end of operation interrupt callback\r\n  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure\r\n  *                  Mass Erase: Bank number which has been requested to erase\r\n  *                  Sectors Erase: Sector which has been erased\r\n  *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)\r\n  *                  Program: Address which was selected for data program\r\n  * @retval None\r\n  */\r\n__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ReturnValue);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  FLASH operation error interrupt callback\r\n  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure\r\n  *                 Mass Erase: Bank number which has been requested to erase\r\n  *                 Sectors Erase: Sector number which returned an error\r\n  *                 Program: Address which was selected for data program\r\n  * @retval None\r\n  */\r\n__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ReturnValue);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_FLASH_OperationErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions\r\n *  @brief   Management functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the FLASH\r\n    memory operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Unlock the FLASH control registers access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Unlock(void)\r\n{\r\n  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)\r\n  {\r\n    /* Authorize the FLASH Bank1 Registers access */\r\n    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);\r\n    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);\r\n\r\n    /* Verify Flash Bank1 is unlocked */\r\n    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)\r\n  {\r\n    /* Authorize the FLASH Bank2 Registers access */\r\n    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);\r\n    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);\r\n\r\n    /* Verify Flash Bank2 is unlocked */\r\n    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Locks the FLASH control registers access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_Lock(void)\r\n{\r\n  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */\r\n  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);\r\n\r\n  /* Verify Flash Bank1 is locked */\r\n  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */\r\n  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);\r\n\r\n  /* Verify Flash Bank2 is locked */\r\n  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Unlock the FLASH Option Control Registers access.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)\r\n{\r\n  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)\r\n  {\r\n    /* Authorizes the Option Byte registers programming */\r\n    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);\r\n    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);\r\n\r\n    /* Verify that the Option Bytes are unlocked */\r\n    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Lock the FLASH Option Control Registers access.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Lock(void)\r\n{\r\n  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */\r\n  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);\r\n\r\n  /* Verify that the Option Bytes are locked */\r\n  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Launch the option bytes loading.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASH_OB_Launch(void)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  /* Wait for CRC computation to be completed */\r\n  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n#endif /* DUAL_BANK */\r\n  else\r\n  {\r\n    status = HAL_OK;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Set OPTSTRT Bit */\r\n    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);\r\n\r\n    /* Wait for OB change operation to be completed */\r\n    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions\r\n *  @brief   Peripheral Errors functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Peripheral Errors functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection permits to get in run-time Errors of the FLASH peripheral.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Get the specific FLASH error flag.\r\n  * @retval HAL_FLASH_ERRORCode The returned value can be:\r\n  *            @arg HAL_FLASH_ERROR_NONE       : No error set\r\n  *\r\n  *            @arg HAL_FLASH_ERROR_WRP_BANK1  : Write Protection Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_PGS_BANK1  : Program Sequence Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_STRB_BANK1 : Strobe Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_INC_BANK1  : Inconsistency Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_OPE_BANK1  : Operation Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_RDP_BANK1  : Read Protection Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_RDS_BANK1  : Read Secured Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_SNECC_BANK1: ECC Single Correction Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_DBECC_BANK1: ECC Double Detection Error on Bank 1\r\n  *            @arg HAL_FLASH_ERROR_CRCRD_BANK1: CRC Read Error on Bank 1\r\n  *\r\n  *            @arg HAL_FLASH_ERROR_WRP_BANK2  : Write Protection Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_PGS_BANK2  : Program Sequence Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_STRB_BANK2 : Strobe Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_INC_BANK2  : Inconsistency Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_OPE_BANK2  : Operation Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_RDP_BANK2  : Read Protection Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_RDS_BANK2  : Read Secured Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_SNECC_BANK2: SNECC Error on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2\r\n  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2\r\n*/\r\n\r\nuint32_t HAL_FLASH_GetError(void)\r\n{\r\n   return pFlash.ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @addtogroup FLASH_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Wait for a FLASH operation to complete.\r\n  * @param  Timeout maximum flash operation timeout\r\n  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2\r\n  * @retval HAL_StatusTypeDef HAL Status\r\n  */\r\nHAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)\r\n{\r\n  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.\r\n     Even if the FLASH operation fails, the QW flag will be reset and an error\r\n     flag will be set */\r\n\r\n  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;\r\n  uint32_t errorflag = 0;\r\n  uint32_t tickstart = HAL_GetTick();\r\n\r\n  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));\r\n\r\n#if defined (DUAL_BANK)\r\n\r\n  if (Bank == FLASH_BANK_2)\r\n  {\r\n    /* Select bsyflag depending on Bank */\r\n    bsyflag = FLASH_FLAG_QW_BANK2;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  while(__HAL_FLASH_GET_FLAG(bsyflag))\r\n  {\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Get Error Flags */\r\n  if (Bank == FLASH_BANK_1)\r\n  {\r\n    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else\r\n  {\r\n    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  /* In case of error reported in Flash SR1 or SR2 register */\r\n  if((errorflag & 0x7FFFFFFFU) != 0U)\r\n  {\r\n    /*Save the error code*/\r\n    pFlash.ErrorCode |= errorflag;\r\n\r\n    /* Clear error programming flags */\r\n    __HAL_FLASH_CLEAR_FLAG(errorflag);\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check FLASH End of Operation flag  */\r\n  if(Bank == FLASH_BANK_1)\r\n  {\r\n    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))\r\n    {\r\n      /* Clear FLASH End of Operation pending bit */\r\n      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);\r\n    }\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else\r\n  {\r\n    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))\r\n    {\r\n      /* Clear FLASH End of Operation pending bit */\r\n      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);\r\n    }\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Wait for a FLASH Option Bytes change operation to complete.\r\n  * @param  Timeout maximum flash operation timeout\r\n  * @retval HAL_StatusTypeDef HAL Status\r\n  */\r\nHAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)\r\n{\r\n  /* Get timeout */\r\n  uint32_t tickstart = HAL_GetTick();\r\n\r\n  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */\r\n  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)\r\n  {\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Check option byte change error */\r\n  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)\r\n  {\r\n    /* Save the error code */\r\n    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;\r\n\r\n    /* Clear the OB error flag */\r\n    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* If there is no error flag set */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Wait for a FLASH CRC computation to complete.\r\n  * @param  Timeout maximum flash operation timeout\r\n  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2\r\n  * @retval HAL_StatusTypeDef HAL Status\r\n  */\r\nHAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)\r\n{\r\n  uint32_t bsyflag;\r\n  uint32_t tickstart = HAL_GetTick();\r\n\r\n  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));\r\n\r\n  /* Select bsyflag depending on Bank */\r\n  if(Bank == FLASH_BANK_1)\r\n  {\r\n    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;\r\n  }\r\n  else\r\n  {\r\n    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;\r\n  }\r\n\r\n  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */\r\n  while(__HAL_FLASH_GET_FLAG(bsyflag))\r\n  {\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Check FLASH CRC read error flag  */\r\n  if(Bank == FLASH_BANK_1)\r\n  {\r\n    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))\r\n    {\r\n      /* Save the error code */\r\n      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;\r\n\r\n      /* Clear FLASH CRC read error pending bit */\r\n      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else\r\n  {\r\n    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))\r\n    {\r\n      /* Save the error code */\r\n      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;\r\n\r\n      /* Clear FLASH CRC read error pending bit */\r\n      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  /* If there is no error flag set */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n"},{"name":"stm32h7xx_hal_flash_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_flash_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended FLASH HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the FLASH extension peripheral:\r\n  *           + Extended programming operations functions\r\n  *\r\n @verbatim\r\n ==============================================================================\r\n                   ##### Flash Extension features #####\r\n  ==============================================================================\r\n\r\n  [..] Comparing to other previous devices, the FLASH interface for STM32H7xx\r\n       devices contains the following additional features\r\n\r\n       (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write\r\n           capability (RWW)\r\n       (+) Dual bank memory organization\r\n       (+) PCROP protection for all banks\r\n       (+) Global readout protection (RDP)\r\n       (+) Write protection\r\n       (+) Secure access only protection\r\n       (+) Bank / register swapping (when Dual-Bank)\r\n       (+) Cyclic Redundancy Check (CRC)\r\n\r\n                        ##### How to use this driver #####\r\n ==============================================================================\r\n  [..] This driver provides functions to configure and program the FLASH memory\r\n       of all STM32H7xx devices. It includes\r\n      (#) FLASH Memory Erase functions:\r\n           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and\r\n                HAL_FLASH_Lock() functions\r\n           (++) Erase function: Sector erase, bank erase and dual-bank mass erase\r\n           (++) There are two modes of erase :\r\n             (+++) Polling Mode using HAL_FLASHEx_Erase()\r\n             (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()\r\n\r\n      (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to:\r\n        (++) Set/Reset the write protection per bank\r\n        (++) Set the Read protection Level\r\n        (++) Set the BOR level\r\n        (++) Program the user Option Bytes\r\n        (++) PCROP protection configuration and control per bank\r\n        (++) Secure area configuration and control per bank\r\n        (++) Core Boot address configuration\r\n        (++) TCM / AXI shared RAM configuration\r\n        (++) CPU Frequency Boost configuration\r\n\r\n      (#) FLASH Memory Lock and unlock per Bank: HAL_FLASHEx_Lock_Bank1(), HAL_FLASHEx_Unlock_Bank1(),\r\n          HAL_FLASHEx_Lock_Bank2() and HAL_FLASHEx_Unlock_Bank2() functions\r\n\r\n      (#) FLASH CRC computation function: Use HAL_FLASHEx_ComputeCRC() to:\r\n          (++) Enable CRC feature\r\n          (++) Program the desired burst size\r\n          (++) Define the user Flash Area on which the CRC has be computed\r\n          (++) Perform the CRC computation\r\n          (++) Disable CRC feature\r\n\r\n @endverbatim\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASHEx  FLASHEx\r\n  * @brief FLASH HAL Extension module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_FLASH_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @addtogroup FLASHEx_Private_Constants\r\n  * @{\r\n  */\r\n#define FLASH_TIMEOUT_VALUE       50000U /* 50 s */\r\n\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup FLASHEx_Private_Functions FLASHEx Private Functions\r\n  * @{\r\n  */\r\nstatic void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks);\r\nstatic void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks);\r\nstatic void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Bank);\r\nstatic void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank);\r\nstatic void FLASH_OB_RDPConfig(uint32_t RDPLevel);\r\nstatic uint32_t FLASH_OB_GetRDP(void);\r\nstatic void FLASH_OB_PCROPConfig(uint32_t PCROConfigRDP, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks);\r\nstatic void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr,uint32_t *PCROPEndAddr, uint32_t Bank);\r\nstatic void FLASH_OB_BOR_LevelConfig(uint32_t Level);\r\nstatic uint32_t FLASH_OB_GetBOR(void);\r\nstatic void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig);\r\nstatic uint32_t FLASH_OB_GetUser(void);\r\nstatic void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1);\r\nstatic void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1);\r\nstatic void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks);\r\nstatic void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank);\r\nstatic void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank);\r\nstatic void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank);\r\n\r\n#if defined (DUAL_CORE)\r\nstatic void FLASH_OB_CM4BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1);\r\nstatic void FLASH_OB_GetCM4BootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1);\r\n#endif /*DUAL_CORE*/\r\n\r\n#if defined (FLASH_OTPBL_LOCKBL)\r\nstatic void FLASH_OB_OTP_LockConfig(uint32_t OTP_Block);\r\nstatic uint32_t FLASH_OB_OTP_GetLock(void);\r\n#endif /* FLASH_OTPBL_LOCKBL */\r\n\r\n#if defined (FLASH_OPTSR2_TCM_AXI_SHARED)\r\nstatic void FLASH_OB_SharedRAM_Config(uint32_t SharedRamConfig);\r\nstatic uint32_t FLASH_OB_SharedRAM_GetConfig(void);\r\n#endif /* FLASH_OPTSR2_TCM_AXI_SHARED */\r\n\r\n#if defined (FLASH_OPTSR2_CPUFREQ_BOOST)\r\nstatic void FLASH_OB_CPUFreq_BoostConfig(uint32_t FreqBoost);\r\nstatic uint32_t FLASH_OB_CPUFreq_GetBoost(void);\r\n#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions ---------------------------------------------------------*/\r\n/** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions\r\n *  @brief   Extended IO operation functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended programming operation functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the Extension FLASH\r\n    programming operations Operations.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors\r\n  * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\r\n  *         contains the configuration information for the erasing.\r\n  *\r\n  * @param[out]  SectorError pointer to variable  that contains the configuration\r\n  *          information on faulty sector in case of error (0xFFFFFFFF means that all\r\n  *          the sectors have been correctly erased)\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t sector_index;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\r\n  assert_param(IS_FLASH_BANK(pEraseInit->Banks));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Reset error code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n\r\n  /* Wait for last operation to be completed on Bank1 */\r\n  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  /* Wait for last operation to be completed on Bank2 */\r\n  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  if(status == HAL_OK)\r\n  {\r\n    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\r\n    {\r\n      /* Mass erase to be done */\r\n      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);\r\n\r\n      /* Wait for last operation to be completed on Bank 1 */\r\n      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n      {\r\n        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n        /* if the erase operation is completed, disable the Bank1 BER Bit */\r\n        FLASH->CR1 &= (~FLASH_CR_BER);\r\n      }\r\n#if defined (DUAL_BANK)\r\n      /* Wait for last operation to be completed on Bank 2 */\r\n      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n      {\r\n        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n        /* if the erase operation is completed, disable the Bank2 BER Bit */\r\n        FLASH->CR2 &= (~FLASH_CR_BER);\r\n      }\r\n#endif /* DUAL_BANK */\r\n    }\r\n    else\r\n    {\r\n      /*Initialization of SectorError variable*/\r\n      *SectorError = 0xFFFFFFFFU;\r\n\r\n      /* Erase by sector by sector to be done*/\r\n      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)\r\n      {\r\n        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);\r\n\r\n        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n        {\r\n          /* Wait for last operation to be completed */\r\n          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);\r\n\r\n          /* If the erase operation is completed, disable the SER Bit */\r\n          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));\r\n        }\r\n#if defined (DUAL_BANK)\r\n        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n        {\r\n          /* Wait for last operation to be completed */\r\n          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);\r\n\r\n          /* If the erase operation is completed, disable the SER Bit */\r\n          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));\r\n        }\r\n#endif /* DUAL_BANK */\r\n\r\n        if(status != HAL_OK)\r\n        {\r\n          /* In case of error, stop erase procedure and return the faulty sector */\r\n          *SectorError = sector_index;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Perform a mass erase or erase the specified FLASH memory sectors with interrupt enabled\r\n  * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that\r\n  *         contains the configuration information for the erasing.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));\r\n  assert_param(IS_FLASH_BANK(pEraseInit->Banks));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Reset error code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n\r\n  /* Wait for last operation to be completed on Bank 1 */\r\n  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  /* Wait for last operation to be completed on Bank 2 */\r\n  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  if (status != HAL_OK)\r\n  {\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(&pFlash);\r\n  }\r\n  else\r\n  {\r\n    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n    {\r\n      /* Enable End of Operation and Error interrupts for Bank 1 */\r\n#if defined (FLASH_CR_OPERRIE)\r\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);\r\n#else\r\n      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \\\r\n                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);\r\n#endif /* FLASH_CR_OPERRIE */\r\n    }\r\n#if defined (DUAL_BANK)\r\n    if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n    {\r\n      /* Enable End of Operation and Error interrupts for Bank 2 */\r\n#if defined (FLASH_CR_OPERRIE)\r\n      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\r\n                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2 | FLASH_IT_OPERR_BANK2);\r\n#else\r\n      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \\\r\n                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);\r\n#endif /* FLASH_CR_OPERRIE */\r\n    }\r\n#endif /* DUAL_BANK */\r\n\r\n    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)\r\n    {\r\n      /*Mass erase to be done*/\r\n      if(pEraseInit->Banks == FLASH_BANK_1)\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;\r\n      }\r\n#if defined (DUAL_BANK)\r\n      else if(pEraseInit->Banks == FLASH_BANK_2)\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;\r\n      }\r\n#endif /* DUAL_BANK */\r\n      else\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;\r\n      }\r\n\r\n      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);\r\n    }\r\n    else\r\n    {\r\n      /* Erase by sector to be done */\r\n#if defined (DUAL_BANK)\r\n      if(pEraseInit->Banks == FLASH_BANK_1)\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;\r\n      }\r\n      else\r\n      {\r\n        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;\r\n      }\r\n#else\r\n      pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;\r\n#endif /* DUAL_BANK */\r\n\r\n      pFlash.NbSectorsToErase = pEraseInit->NbSectors;\r\n      pFlash.Sector = pEraseInit->Sector;\r\n      pFlash.VoltageForErase = pEraseInit->VoltageRange;\r\n\r\n      /* Erase first sector and wait for IT */\r\n      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Program option bytes\r\n  * @param  pOBInit pointer to an FLASH_OBProgramInitTypeDef structure that\r\n  *         contains the configuration information for the programming.\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(&pFlash);\r\n\r\n  /* Reset Error Code */\r\n  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;\r\n\r\n  /* Wait for last operation to be completed */\r\n  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n#endif /* DUAL_BANK */\r\n  else\r\n  {\r\n    status = HAL_OK;\r\n  }\r\n\r\n  if(status == HAL_OK)\r\n  {\r\n    /*Write protection configuration*/\r\n    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)\r\n    {\r\n      assert_param(IS_WRPSTATE(pOBInit->WRPState));\r\n\r\n      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)\r\n      {\r\n        /*Enable of Write protection on the selected Sector*/\r\n        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);\r\n      }\r\n      else\r\n      {\r\n        /*Disable of Write protection on the selected Sector*/\r\n        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);\r\n      }\r\n    }\r\n\r\n    /* Read protection configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)\r\n    {\r\n      /* Configure the Read protection level */\r\n      FLASH_OB_RDPConfig(pOBInit->RDPLevel);\r\n    }\r\n\r\n    /* User Configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)\r\n    {\r\n      /* Configure the user option bytes */\r\n      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);\r\n    }\r\n\r\n    /* PCROP Configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)\r\n    {\r\n      assert_param(IS_FLASH_BANK(pOBInit->Banks));\r\n\r\n      /*Configure the Proprietary code readout protection */\r\n      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);\r\n    }\r\n\r\n    /* BOR Level configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)\r\n    {\r\n      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);\r\n    }\r\n\r\n#if defined(DUAL_CORE)\r\n    /* CM7 Boot Address  configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_CM7_BOOTADD) == OPTIONBYTE_CM7_BOOTADD)\r\n    {\r\n      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);\r\n    }\r\n\r\n    /* CM4 Boot Address  configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_CM4_BOOTADD) == OPTIONBYTE_CM4_BOOTADD)\r\n    {\r\n      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);\r\n    }\r\n#else /* Single Core*/\r\n    /* Boot Address  configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)\r\n    {\r\n      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);\r\n    }\r\n#endif /*DUAL_CORE*/\r\n\r\n    /* Secure area configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)\r\n    {\r\n      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);\r\n    }\r\n\r\n#if defined(FLASH_OTPBL_LOCKBL)\r\n    /* OTP Block Lock configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_OTP_LOCK) == OPTIONBYTE_OTP_LOCK)\r\n    {\r\n      FLASH_OB_OTP_LockConfig(pOBInit->OTPBlockLock);\r\n    }\r\n#endif /* FLASH_OTPBL_LOCKBL */\r\n\r\n#if defined(FLASH_OPTSR2_TCM_AXI_SHARED)\r\n    /* TCM / AXI Shared RAM configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_SHARED_RAM) == OPTIONBYTE_SHARED_RAM)\r\n    {\r\n      FLASH_OB_SharedRAM_Config(pOBInit->SharedRamConfig);\r\n    }\r\n#endif /* FLASH_OPTSR2_TCM_AXI_SHARED */\r\n\r\n#if defined(FLASH_OPTSR2_CPUFREQ_BOOST)\r\n    /* CPU Frequency Boost configuration */\r\n    if((pOBInit->OptionType & OPTIONBYTE_FREQ_BOOST) == OPTIONBYTE_FREQ_BOOST)\r\n    {\r\n      FLASH_OB_CPUFreq_BoostConfig(pOBInit->FreqBoostState);\r\n    }\r\n#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(&pFlash);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Get the Option byte configuration\r\n  * @param  pOBInit pointer to an FLASH_OBProgramInitTypeDef structure that\r\n  *         contains the configuration information for the programming.\r\n  * @note   The parameter Banks of the pOBInit structure must be set exclusively to FLASH_BANK_1 or FLASH_BANK_2,\r\n  *         as this parameter is use to get the given Bank WRP, PCROP and secured area configuration.\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)\r\n{\r\n  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);\r\n\r\n  /* Get Read protection level */\r\n  pOBInit->RDPLevel = FLASH_OB_GetRDP();\r\n\r\n  /* Get the user option bytes */\r\n  pOBInit->USERConfig = FLASH_OB_GetUser();\r\n\r\n  /*Get BOR Level*/\r\n  pOBInit->BORLevel = FLASH_OB_GetBOR();\r\n\r\n#if defined (DUAL_BANK)\r\n  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))\r\n#else\r\n  if (pOBInit->Banks == FLASH_BANK_1)\r\n#endif /* DUAL_BANK */\r\n  {\r\n    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);\r\n\r\n    /* Get write protection on the selected area */\r\n    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);\r\n\r\n    /* Get the Proprietary code readout protection */\r\n    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);\r\n\r\n    /*Get Bank Secure area*/\r\n    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);\r\n  }\r\n\r\n  /*Get Boot Address*/\r\n  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));\r\n#if defined(DUAL_CORE)\r\n  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;\r\n\r\n  /*Get CM4 Boot Address*/\r\n  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));\r\n#else\r\n  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;\r\n#endif /*DUAL_CORE*/\r\n\r\n#if defined (FLASH_OTPBL_LOCKBL)\r\n  pOBInit->OptionType |= OPTIONBYTE_OTP_LOCK;\r\n\r\n  /* Get OTP Block Lock */\r\n  pOBInit->OTPBlockLock = FLASH_OB_OTP_GetLock();\r\n#endif /* FLASH_OTPBL_LOCKBL */\r\n\r\n#if defined (FLASH_OPTSR2_TCM_AXI_SHARED)\r\n  pOBInit->OptionType |= OPTIONBYTE_SHARED_RAM;\r\n\r\n  /* Get TCM / AXI Shared RAM */\r\n  pOBInit->SharedRamConfig = FLASH_OB_SharedRAM_GetConfig();\r\n#endif /* FLASH_OPTSR2_TCM_AXI_SHARED */\r\n\r\n#if defined (FLASH_OPTSR2_CPUFREQ_BOOST)\r\n  pOBInit->OptionType |= OPTIONBYTE_FREQ_BOOST;\r\n\r\n  /* Get CPU Frequency Boost */\r\n  pOBInit->FreqBoostState = FLASH_OB_CPUFreq_GetBoost();\r\n#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */\r\n}\r\n\r\n/**\r\n  * @brief  Unlock the FLASH Bank1 control registers access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)\r\n{\r\n  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)\r\n  {\r\n    /* Authorize the FLASH Bank1 Registers access */\r\n    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);\r\n    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);\r\n\r\n    /* Verify Flash Bank1 is unlocked */\r\n    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Locks the FLASH Bank1 control registers access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)\r\n{\r\n  /* Set the LOCK Bit to lock the FLASH Bank1 Registers access */\r\n  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);\r\n  return HAL_OK;\r\n}\r\n\r\n#if defined (DUAL_BANK)\r\n/**\r\n  * @brief  Unlock the FLASH Bank2 control registers access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank2(void)\r\n{\r\n  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)\r\n  {\r\n    /* Authorize the FLASH Bank2 Registers access */\r\n    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);\r\n    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);\r\n\r\n    /* Verify Flash Bank1 is unlocked */\r\n    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Locks the FLASH Bank2 control registers access\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_FLASHEx_Lock_Bank2(void)\r\n{\r\n  /* Set the LOCK Bit to lock the FLASH Bank2 Registers access */\r\n  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);\r\n  return HAL_OK;\r\n}\r\n#endif /* DUAL_BANK */\r\n\r\n/*\r\n  * @brief  Perform a CRC computation on the specified FLASH memory area\r\n  * @param  pCRCInit pointer to an FLASH_CRCInitTypeDef structure that\r\n  *         contains the configuration information for the CRC computation.\r\n  * @note   CRC computation uses CRC-32 (Ethernet) polynomial 0x4C11DB7\r\n  * @note   The application should avoid running a CRC on PCROP or secure-only\r\n  *         user Flash memory area since it may alter the expected CRC value.\r\n  *         A special error flag (CRC read error: CRCRDERR) can be used to\r\n  *         detect such a case.\r\n  * @retval HAL Status\r\n*/\r\nHAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)\r\n{\r\n  HAL_StatusTypeDef status;\r\n  uint32_t sector_index;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));\r\n  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));\r\n\r\n  /* Wait for OB change operation to be completed */\r\n  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    if (pCRCInit->Bank == FLASH_BANK_1)\r\n    {\r\n      /* Enable CRC feature */\r\n      FLASH->CR1 |= FLASH_CR_CRC_EN;\r\n\r\n      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */\r\n      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);\r\n\r\n      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */\r\n      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;\r\n\r\n      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)\r\n      {\r\n        /* Clear sectors list */\r\n        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;\r\n\r\n        /* Select CRC sectors */\r\n        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)\r\n        {\r\n          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);\r\n        }\r\n      }\r\n      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)\r\n      {\r\n        /* Enable Bank 1 CRC select bit */\r\n        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;\r\n      }\r\n      else\r\n      {\r\n        /* Select CRC start and end addresses */\r\n        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);\r\n      }\r\n\r\n      /* Start the CRC calculation */\r\n      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;\r\n\r\n      /* Wait on CRC busy flag */\r\n      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);\r\n\r\n      /* Return CRC result */\r\n      (*CRC_Result) = FLASH->CRCDATA;\r\n\r\n      /* Disable CRC feature */\r\n      FLASH->CR1 &= (~FLASH_CR_CRC_EN);\r\n\r\n      /* Clear CRC flags */\r\n      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);\r\n    }\r\n#if defined (DUAL_BANK)\r\n    else\r\n    {\r\n      /* Enable CRC feature */\r\n      FLASH->CR2 |= FLASH_CR_CRC_EN;\r\n\r\n      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */\r\n      FLASH->CCR2 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);\r\n\r\n      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */\r\n      FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;\r\n\r\n      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)\r\n      {\r\n        /* Clear sectors list */\r\n        FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_SECT;\r\n\r\n        /* Add CRC sectors */\r\n        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)\r\n        {\r\n          FLASH_CRC_AddSector(sector_index, FLASH_BANK_2);\r\n        }\r\n      }\r\n      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)\r\n      {\r\n        /* Enable Bank 2 CRC select bit */\r\n        FLASH->CRCCR2 |= FLASH_CRCCR_ALL_BANK;\r\n      }\r\n      else\r\n      {\r\n        /* Select CRC start and end addresses */\r\n        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_2);\r\n      }\r\n\r\n      /* Start the CRC calculation */\r\n      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;\r\n\r\n      /* Wait on CRC busy flag */\r\n      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);\r\n\r\n      /* Return CRC result */\r\n      (*CRC_Result) = FLASH->CRCDATA;\r\n\r\n      /* Disable CRC feature */\r\n      FLASH->CR2 &= (~FLASH_CR_CRC_EN);\r\n\r\n      /* Clear CRC flags */\r\n      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);\r\n    }\r\n#endif /* DUAL_BANK */\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @addtogroup FLASHEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Mass erase of FLASH memory\r\n  * @param  VoltageRange The device program/erase parallelism.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1 : Flash program/erase by 8 bits\r\n  *            @arg FLASH_VOLTAGE_RANGE_2 : Flash program/erase by 16 bits\r\n  *            @arg FLASH_VOLTAGE_RANGE_3 : Flash program/erase by 32 bits\r\n  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits\r\n  *\r\n  * @param  Banks Banks to be erased\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Bank1 to be erased\r\n  *            @arg FLASH_BANK_2: Bank2 to be erased\r\n  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased\r\n  *\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n#if defined (FLASH_CR_PSIZE)\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n#else\r\n  UNUSED(VoltageRange);\r\n#endif /* FLASH_CR_PSIZE */\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n#if defined (DUAL_BANK)\r\n  /* Flash Mass Erase */\r\n  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)\r\n  {\r\n#if defined (FLASH_CR_PSIZE)\r\n    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */\r\n    FLASH->CR1 &= (~FLASH_CR_PSIZE);\r\n    FLASH->CR2 &= (~FLASH_CR_PSIZE);\r\n\r\n    /* Set voltage range */\r\n    FLASH->CR1 |= VoltageRange;\r\n    FLASH->CR2 |= VoltageRange;\r\n#endif /* FLASH_CR_PSIZE */\r\n\r\n    /* Set Mass Erase Bit */\r\n    FLASH->OPTCR |= FLASH_OPTCR_MER;\r\n  }\r\n  else\r\n#endif /* DUAL_BANK */\r\n  {\r\n    /* Proceed to erase Flash Bank  */\r\n    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n    {\r\n#if defined (FLASH_CR_PSIZE)\r\n      /* Set Program/erase VoltageRange for Bank1 */\r\n      FLASH->CR1 &= (~FLASH_CR_PSIZE);\r\n      FLASH->CR1 |=  VoltageRange;\r\n#endif /* FLASH_CR_PSIZE */\r\n\r\n      /* Erase Bank1 */\r\n      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);\r\n    }\r\n\r\n#if defined (DUAL_BANK)\r\n    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n    {\r\n#if defined (FLASH_CR_PSIZE)\r\n      /* Set Program/erase VoltageRange for Bank2 */\r\n      FLASH->CR2 &= (~FLASH_CR_PSIZE);\r\n      FLASH->CR2 |= VoltageRange;\r\n#endif /* FLASH_CR_PSIZE */\r\n\r\n      /* Erase Bank2 */\r\n      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);\r\n    }\r\n#endif /* DUAL_BANK */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Erase the specified FLASH memory sector\r\n  * @param  Sector FLASH sector to erase\r\n  *          This parameter can be a value of @ref FLASH_Sectors\r\n  * @param  Banks Banks to be erased\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Bank1 to be erased\r\n  *            @arg FLASH_BANK_2: Bank2 to be erased\r\n  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased\r\n  * @param  VoltageRange The device program/erase parallelism.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_VOLTAGE_RANGE_1 : Flash program/erase by 8 bits\r\n  *            @arg FLASH_VOLTAGE_RANGE_2 : Flash program/erase by 16 bits\r\n  *            @arg FLASH_VOLTAGE_RANGE_3 : Flash program/erase by 32 bits\r\n  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits\r\n  *\r\n  * @retval None\r\n  */\r\nvoid FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)\r\n{\r\n  assert_param(IS_FLASH_SECTOR(Sector));\r\n  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));\r\n#if defined (FLASH_CR_PSIZE)\r\n  assert_param(IS_VOLTAGERANGE(VoltageRange));\r\n#else\r\n  UNUSED(VoltageRange);\r\n#endif /* FLASH_CR_PSIZE */\r\n\r\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n#if defined (FLASH_CR_PSIZE)\r\n    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */\r\n    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);\r\n\r\n    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\r\n#else\r\n    /* Reset Sector Number for Bank1 */\r\n    FLASH->CR1 &= ~(FLASH_CR_SNB);\r\n\r\n    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\r\n#endif /* FLASH_CR_PSIZE */\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n#if defined (FLASH_CR_PSIZE)\r\n    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */\r\n    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);\r\n\r\n    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\r\n#else\r\n    /* Reset Sector Number for Bank2 */\r\n    FLASH->CR2 &= ~(FLASH_CR_SNB);\r\n\r\n    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);\r\n#endif /* FLASH_CR_PSIZE */\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n\r\n/**\r\n  * @brief  Enable the write protection of the desired bank1 or bank 2 sectors\r\n  * @param  WRPSector specifies the sector(s) to be write protected.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg WRPSector:  A combination of OB_WRP_SECTOR_0 to OB_WRP_SECTOR_7 or OB_WRP_SECTOR_ALL\r\n  *\r\n  * @param  Banks the specific bank to apply WRP sectors\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: enable WRP on specified bank1 sectors\r\n  *            @arg FLASH_BANK_2: enable WRP on specified bank2 sectors\r\n  *            @arg FLASH_BANK_BOTH: enable WRP on both bank1 and bank2 specified sectors\r\n  *\r\n  * @retval HAL FLASH State\r\n  */\r\nstatic void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n    /* Enable Write Protection for bank 1 */\r\n    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n    /* Enable Write Protection for bank 2 */\r\n    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n\r\n/**\r\n  * @brief  Disable the write protection of the desired bank1 or bank 2 sectors\r\n  * @param  WRPSector specifies the sector(s) to disable write protection.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg WRPSector:  A combination of FLASH_OB_WRP_SECTOR_0 to FLASH_OB_WRP_SECTOR_7 or FLASH_OB_WRP_SECTOR_ALL\r\n  *\r\n  * @param  Banks the specific bank to apply WRP sectors\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: disable WRP on specified bank1 sectors\r\n  *            @arg FLASH_BANK_2: disable WRP on specified bank2 sectors\r\n  *            @arg FLASH_BANK_BOTH: disable WRP on both bank1 and bank2 specified sectors\r\n  *\r\n  * @retval HAL FLASH State\r\n  */\r\nstatic void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_WRP_SECTOR(WRPSector));\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n\r\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n    /* Disable Write Protection for bank 1 */\r\n    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n    /* Disable Write Protection for bank 2 */\r\n    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n\r\n/**\r\n  * @brief  Get the write protection of the given bank 1 or bank 2 sectors\r\n  * @param  WRPState gives the write protection state on the given bank.\r\n  *          This parameter can be one of the following values:\r\n  *          @arg WRPState: OB_WRPSTATE_DISABLE or OB_WRPSTATE_ENABLE\r\n\r\n  * @param  WRPSector gives the write protected sector(s) on the given bank .\r\n  *          This parameter can be one of the following values:\r\n  *          @arg WRPSector: A combination of FLASH_OB_WRP_SECTOR_0 to FLASH_OB_WRP_SECTOR_7 or FLASH_OB_WRP_SECTOR_ALL\r\n  *\r\n  * @param  Bank the specific bank to apply WRP sectors\r\n  *          This parameter can be exclusively one of the following values:\r\n  *            @arg FLASH_BANK_1: Get bank1 WRP sectors\r\n  *            @arg FLASH_BANK_2: Get bank2 WRP sectors\r\n  *            @arg FLASH_BANK_BOTH: note allowed in this functions\r\n  *\r\n  * @retval HAL FLASH State\r\n  */\r\nstatic void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)\r\n{\r\n  uint32_t regvalue = 0U;\r\n\r\n  if(Bank == FLASH_BANK_1)\r\n  {\r\n    regvalue = FLASH->WPSN_CUR1;\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if(Bank == FLASH_BANK_2)\r\n  {\r\n    regvalue = FLASH->WPSN_CUR2;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;\r\n\r\n  if(*WRPSector == 0U)\r\n  {\r\n    (*WRPState) = OB_WRPSTATE_DISABLE;\r\n  }\r\n  else\r\n  {\r\n    (*WRPState) = OB_WRPSTATE_ENABLE;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Set the read protection level.\r\n  *\r\n  * @note   To configure the RDP level, the option lock bit OPTLOCK must be\r\n  *         cleared with the call of the HAL_FLASH_OB_Unlock() function.\r\n  * @note   To validate the RDP level, the option bytes must be reloaded\r\n  *         through the call of the HAL_FLASH_OB_Launch() function.\r\n  * @note   !!! Warning : When enabling OB_RDP level 2 it's no more possible\r\n  *         to go back to level 1 or 0 !!!\r\n  *\r\n  * @param  RDPLevel specifies the read protection level.\r\n  *         This parameter can be one of the following values:\r\n  *            @arg OB_RDP_LEVEL_0: No protection\r\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\r\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\r\n  *\r\n  * @retval HAL status\r\n  */\r\nstatic void FLASH_OB_RDPConfig(uint32_t RDPLevel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_RDP_LEVEL(RDPLevel));\r\n\r\n  /* Configure the RDP level in the option bytes register */\r\n  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);\r\n}\r\n\r\n/**\r\n  * @brief  Get the read protection level.\r\n  * @retval RDPLevel specifies the read protection level.\r\n  *         This return value can be one of the following values:\r\n  *            @arg OB_RDP_LEVEL_0: No protection\r\n  *            @arg OB_RDP_LEVEL_1: Read protection of the memory\r\n  *            @arg OB_RDP_LEVEL_2: Full chip protection\r\n  */\r\nstatic uint32_t FLASH_OB_GetRDP(void)\r\n{\r\n  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);\r\n  \r\n  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))\r\n  {\r\n    return (OB_RDP_LEVEL_1);\r\n  }\r\n  else\r\n  {\r\n    return rdp_level;\r\n  }\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Program the FLASH User Option Byte.\r\n  *\r\n  * @note   To configure the user option bytes, the option lock bit OPTLOCK must\r\n  *         be cleared with the call of the HAL_FLASH_OB_Unlock() function.\r\n  *\r\n  * @note   To validate the user option bytes, the option bytes must be reloaded\r\n  *         through the call of the HAL_FLASH_OB_Launch() function.\r\n  *\r\n  * @param  UserType The FLASH User Option Bytes to be modified :\r\n  *                   a combination of @ref FLASHEx_OB_USER_Type\r\n  *\r\n  * @param  UserConfig The FLASH User Option Bytes values:\r\n  *         IWDG1_SW(Bit4), IWDG2_SW(Bit 5), nRST_STOP_D1(Bit 6), nRST_STDY_D1(Bit 7),\r\n  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),\r\n  *         SECURITY(Bit 21), BCM4(Bit 22), BCM7(Bit 23), nRST_STOP_D2(Bit 24),\r\n  *         nRST_STDY_D2(Bit 25), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).\r\n  *\r\n  * @retval HAL status\r\n  */\r\n#else\r\n/**\r\n  * @brief  Program the FLASH User Option Byte.\r\n  *\r\n  * @note   To configure the user option bytes, the option lock bit OPTLOCK must\r\n  *         be cleared with the call of the HAL_FLASH_OB_Unlock() function.\r\n  *\r\n  * @note   To validate the user option bytes, the option bytes must be reloaded\r\n  *         through the call of the HAL_FLASH_OB_Launch() function.\r\n  *\r\n  * @param  UserType The FLASH User Option Bytes to be modified :\r\n  *                   a combination of @arg FLASHEx_OB_USER_Type\r\n  *\r\n  * @param  UserConfig The FLASH User Option Bytes values:\r\n  *         IWDG_SW(Bit4), nRST_STOP_D1(Bit 6), nRST_STDY_D1(Bit 7),\r\n  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),\r\n  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).\r\n  *\r\n  * @retval HAL status\r\n  */\r\n#endif /*DUAL_CORE*/\r\nstatic void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)\r\n{\r\n  uint32_t optr_reg_val = 0;\r\n  uint32_t optr_reg_mask = 0;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_USER_TYPE(UserType));\r\n\r\n  if((UserType & OB_USER_IWDG1_SW) != 0U)\r\n  {\r\n    /* IWDG_HW option byte should be modified */\r\n    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));\r\n\r\n    /* Set value and mask for IWDG_HW option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);\r\n    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;\r\n  }\r\n#if defined(DUAL_CORE)\r\n  if((UserType & OB_USER_IWDG2_SW) != 0U)\r\n  {\r\n    /* IWDG2_SW option byte should be modified */\r\n    assert_param(IS_OB_IWDG2_SOURCE(UserConfig & FLASH_OPTSR_IWDG2_SW));\r\n\r\n    /* Set value and mask for IWDG2_SW option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);\r\n    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;\r\n  }\r\n#endif /*DUAL_CORE*/\r\n  if((UserType & OB_USER_NRST_STOP_D1) != 0U)\r\n  {\r\n    /* NRST_STOP option byte should be modified */\r\n    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));\r\n\r\n    /* Set value and mask for NRST_STOP option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);\r\n    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;\r\n  }\r\n\r\n  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)\r\n  {\r\n    /* NRST_STDBY option byte should be modified */\r\n    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));\r\n\r\n    /* Set value and mask for NRST_STDBY option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);\r\n    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;\r\n  }\r\n\r\n  if((UserType & OB_USER_IWDG_STOP) != 0U)\r\n  {\r\n    /* IWDG_STOP option byte should be modified */\r\n    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));\r\n\r\n    /* Set value and mask for IWDG_STOP option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);\r\n    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;\r\n  }\r\n\r\n  if((UserType & OB_USER_IWDG_STDBY) != 0U)\r\n  {\r\n    /* IWDG_STDBY option byte should be modified */\r\n    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));\r\n\r\n    /* Set value and mask for IWDG_STDBY option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);\r\n    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;\r\n  }\r\n\r\n  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)\r\n  {\r\n    /* ST_RAM_SIZE option byte should be modified */\r\n    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));\r\n\r\n    /* Set value and mask for ST_RAM_SIZE option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);\r\n    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;\r\n  }\r\n\r\n  if((UserType & OB_USER_SECURITY) != 0U)\r\n  {\r\n    /* SECURITY option byte should be modified */\r\n    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));\r\n\r\n    /* Set value and mask for SECURITY option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);\r\n    optr_reg_mask |= FLASH_OPTSR_SECURITY;\r\n  }\r\n\r\n#if defined(DUAL_CORE)\r\n  if((UserType & OB_USER_BCM4) != 0U)\r\n  {\r\n    /* BCM4 option byte should be modified */\r\n    assert_param(IS_OB_USER_BCM4(UserConfig & FLASH_OPTSR_BCM4));\r\n\r\n    /* Set value and mask for BCM4 option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_BCM4);\r\n    optr_reg_mask |= FLASH_OPTSR_BCM4;\r\n  }\r\n\r\n  if((UserType & OB_USER_BCM7) != 0U)\r\n  {\r\n    /* BCM7 option byte should be modified */\r\n    assert_param(IS_OB_USER_BCM7(UserConfig & FLASH_OPTSR_BCM7));\r\n\r\n    /* Set value and mask for BCM7 option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_BCM7);\r\n    optr_reg_mask |= FLASH_OPTSR_BCM7;\r\n  }\r\n#endif /* DUAL_CORE */\r\n\r\n#if defined (FLASH_OPTSR_NRST_STOP_D2)\r\n  if((UserType & OB_USER_NRST_STOP_D2) != 0U)\r\n  {\r\n    /* NRST_STOP option byte should be modified */\r\n    assert_param(IS_OB_STOP_D2_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D2));\r\n\r\n    /* Set value and mask for NRST_STOP option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D2);\r\n    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D2;\r\n  }\r\n\r\n  if((UserType & OB_USER_NRST_STDBY_D2) != 0U)\r\n  {\r\n    /* NRST_STDBY option byte should be modified */\r\n    assert_param(IS_OB_STDBY_D2_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D2));\r\n\r\n    /* Set value and mask for NRST_STDBY option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D2);\r\n    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;\r\n  }\r\n#endif /* FLASH_OPTSR_NRST_STOP_D2 */\r\n\r\n#if defined (DUAL_BANK)\r\n  if((UserType & OB_USER_SWAP_BANK) != 0U)\r\n  {\r\n    /* SWAP_BANK_OPT option byte should be modified */\r\n    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));\r\n\r\n    /* Set value and mask for SWAP_BANK_OPT option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);\r\n    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  if((UserType & OB_USER_IOHSLV) != 0U)\r\n  {\r\n    /* IOHSLV_OPT option byte should be modified */\r\n    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));\r\n\r\n    /* Set value and mask for IOHSLV_OPT option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);\r\n    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;\r\n  }\r\n\r\n#if defined (FLASH_OPTSR_VDDMMC_HSLV)\r\n  if((UserType & OB_USER_VDDMMC_HSLV) != 0U)\r\n  {\r\n    /* VDDMMC_HSLV option byte should be modified */\r\n    assert_param(IS_OB_USER_VDDMMC_HSLV(UserConfig & FLASH_OPTSR_VDDMMC_HSLV));\r\n\r\n    /* Set value and mask for VDDMMC_HSLV option byte */\r\n    optr_reg_val |= (UserConfig & FLASH_OPTSR_VDDMMC_HSLV);\r\n    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;\r\n  }\r\n#endif /* FLASH_OPTSR_VDDMMC_HSLV */\r\n\r\n  /* Configure the option bytes register */\r\n  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Return the FLASH User Option Byte value.\r\n  * @retval The FLASH User Option Bytes values\r\n  *         IWDG1_SW(Bit4), IWDG2_SW(Bit 5), nRST_STOP_D1(Bit 6), nRST_STDY_D1(Bit 7),\r\n  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),\r\n  *         SECURITY(Bit 21), BCM4(Bit 22), BCM7(Bit 23), nRST_STOP_D2(Bit 24),\r\n  *         nRST_STDY_D2(Bit 25), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).\r\n  */\r\n#else\r\n/**\r\n  * @brief  Return the FLASH User Option Byte value.\r\n  * @retval The FLASH User Option Bytes values\r\n  *         IWDG_SW(Bit4), nRST_STOP_D1(Bit 6), nRST_STDY_D1(Bit 7),\r\n  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),\r\n  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).\r\n  */\r\n#endif /*DUAL_CORE*/\r\nstatic uint32_t FLASH_OB_GetUser(void)\r\n{\r\n  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);\r\n  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));\r\n\r\n  return userConfig;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Proprietary code readout protection of the desired addresses\r\n  *\r\n  * @note   To configure the PCROP options, the option lock bit OPTLOCK must be\r\n  *         cleared with the call of the HAL_FLASH_OB_Unlock() function.\r\n  * @note   To validate the PCROP options, the option bytes must be reloaded\r\n  *         through the call of the HAL_FLASH_OB_Launch() function.\r\n  *\r\n  * @param  PCROPConfig specifies if the PCROP area for the given Bank shall be erased or not\r\n  *         when RDP level decreased from Level 1 to Level 0, or after a bank erase with protection removal\r\n  *         This parameter must be a value of @arg FLASHEx_OB_PCROP_RDP enumeration\r\n  *\r\n  * @param  PCROPStartAddr specifies the start address of the Proprietary code readout protection\r\n  *          This parameter can be an address between begin and end of the bank\r\n  *\r\n  * @param  PCROPEndAddr specifies the end address of the Proprietary code readout protection\r\n  *          This parameter can be an address between PCROPStartAddr and end of the bank\r\n  *\r\n  * @param  Banks the specific bank to apply PCROP protection\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: PCROP on specified bank1 area\r\n  *            @arg FLASH_BANK_2: PCROP on specified bank2 area\r\n  *            @arg FLASH_BANK_BOTH: PCROP on specified bank1 and bank2 area (same config will be applied on both banks)\r\n  *\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n  assert_param(IS_OB_PCROP_RDP(PCROPConfig));\r\n\r\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));\r\n\r\n    /* Configure the Proprietary code readout protection */\r\n    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \\\r\n                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \\\r\n                       PCROPConfig;\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));\r\n\r\n    /* Configure the Proprietary code readout protection */\r\n    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \\\r\n                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \\\r\n                       PCROPConfig;\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n\r\n/**\r\n  * @brief  Get the Proprietary code readout protection configuration on a given Bank\r\n  *\r\n  * @param  PCROPConfig indicates if the PCROP area for the given Bank shall be erased or not\r\n  *         when RDP level decreased from Level 1 to Level 0 or after a bank erase with protection removal\r\n  *\r\n  * @param  PCROPStartAddr gives the start address of the Proprietary code readout protection of the bank\r\n  *\r\n  * @param  PCROPEndAddr gives the end address of the Proprietary code readout protection of the bank\r\n  *\r\n  * @param  Bank the specific bank to apply PCROP protection\r\n  *          This parameter can be exclusively one of the following values:\r\n  *            @arg FLASH_BANK_1: PCROP on specified bank1 area\r\n  *            @arg FLASH_BANK_2: PCROP on specified bank2 area\r\n  *            @arg FLASH_BANK_BOTH: is  not allowed here\r\n  *\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)\r\n{\r\n  uint32_t regvalue = 0;\r\n  uint32_t bankBase = 0;\r\n\r\n  if(Bank == FLASH_BANK_1)\r\n  {\r\n    regvalue = FLASH->PRAR_CUR1;\r\n    bankBase = FLASH_BANK1_BASE;\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if(Bank == FLASH_BANK_2)\r\n  {\r\n    regvalue = FLASH->PRAR_CUR2;\r\n    bankBase = FLASH_BANK2_BASE;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);\r\n\r\n  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;\r\n  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;\r\n  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;\r\n}\r\n\r\n/**\r\n  * @brief  Set the BOR Level.\r\n  * @param  Level specifies the Option Bytes BOR Reset Level.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg OB_BOR_LEVEL0: Reset level threshold is set to 1.6V\r\n  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V\r\n  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V\r\n  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_BOR_LevelConfig(uint32_t Level)\r\n{\r\n  assert_param(IS_OB_BOR_LEVEL(Level));\r\n\r\n  /* Configure BOR_LEV option byte */\r\n  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);\r\n}\r\n\r\n/**\r\n  * @brief  Get the BOR Level.\r\n  * @retval The Option Bytes BOR Reset Level.\r\n  *            This parameter can be one of the following values:\r\n  *            @arg OB_BOR_LEVEL0: Reset level threshold is set to 1.6V\r\n  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V\r\n  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V\r\n  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V\r\n  */\r\nstatic uint32_t FLASH_OB_GetBOR(void)\r\n{\r\n  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);\r\n}\r\n\r\n/**\r\n  * @brief  Set Boot address\r\n  * @param  BootOption Boot address option byte to be programmed,\r\n  *                     This parameter must be a value of @ref FLASHEx_OB_BOOT_OPTION\r\n                        (OB_BOOT_ADD0, OB_BOOT_ADD1 or OB_BOOT_ADD_BOTH)\r\n  *\r\n  * @param  BootAddress0 Specifies the Boot Address 0\r\n  * @param  BootAddress1 Specifies the Boot Address 1\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));\r\n\r\n  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_BOOT_ADDRESS(BootAddress0));\r\n\r\n    /* Configure CM7 BOOT ADD0 */\r\n#if defined(DUAL_CORE)\r\n    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));\r\n#else /* Single Core*/\r\n    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));\r\n#endif /* DUAL_CORE */\r\n  }\r\n\r\n  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_BOOT_ADDRESS(BootAddress1));\r\n\r\n    /* Configure CM7 BOOT ADD1 */\r\n#if defined(DUAL_CORE)\r\n    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);\r\n#else /* Single Core*/\r\n    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);\r\n#endif /* DUAL_CORE */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Get Boot address\r\n  * @param  BootAddress0 Specifies the Boot Address 0.\r\n  * @param  BootAddress1 Specifies the Boot Address 1.\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)\r\n{\r\n  uint32_t regvalue;\r\n\r\n#if defined(DUAL_CORE)\r\n  regvalue = FLASH->BOOT7_CUR;\r\n\r\n  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;\r\n  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);\r\n#else /* Single Core */\r\n  regvalue = FLASH->BOOT_CUR;\r\n\r\n  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;\r\n  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);\r\n#endif /* DUAL_CORE */\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Set CM4 Boot address\r\n  * @param  BootOption Boot address option byte to be programmed,\r\n  *                     This parameter must be a value of @ref FLASHEx_OB_BOOT_OPTION\r\n                        (OB_BOOT_ADD0, OB_BOOT_ADD1 or OB_BOOT_ADD_BOTH)\r\n  *\r\n  * @param  BootAddress0 Specifies the CM4 Boot Address 0.\r\n  * @param  BootAddress1 Specifies the CM4 Boot Address 1.\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_OB_CM4BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));\r\n\r\n  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_BOOT_ADDRESS(BootAddress0));\r\n\r\n    /* Configure CM4 BOOT ADD0 */\r\n    MODIFY_REG(FLASH->BOOT4_PRG, FLASH_BOOT4_BCM4_ADD0, (BootAddress0 >> 16));\r\n\r\n  }\r\n\r\n  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_BOOT_ADDRESS(BootAddress1));\r\n\r\n    /* Configure CM4 BOOT ADD1 */\r\n    MODIFY_REG(FLASH->BOOT4_PRG, FLASH_BOOT4_BCM4_ADD1, BootAddress1);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Get CM4 Boot address\r\n  * @param  BootAddress0 Specifies the CM4 Boot Address 0.\r\n  * @param  BootAddress1 Specifies the CM4 Boot Address 1.\r\n  * @retval HAL Status\r\n  */\r\nstatic void FLASH_OB_GetCM4BootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)\r\n{\r\n  uint32_t regvalue;\r\n\r\n  regvalue = FLASH->BOOT4_CUR;\r\n\r\n  (*BootAddress0) = (regvalue & FLASH_BOOT4_BCM4_ADD0) << 16;\r\n  (*BootAddress1) = (regvalue & FLASH_BOOT4_BCM4_ADD1);\r\n}\r\n#endif /*DUAL_CORE*/\r\n\r\n/**\r\n  * @brief  Set secure area configuration\r\n  * @param  SecureAreaConfig specify if the secure area will be deleted or not\r\n  *         when RDP level decreased from Level 1 to Level 0 or during a mass erase.\r\n  *\r\n  * @param  SecureAreaStartAddr Specifies the secure area start address\r\n  * @param  SecureAreaEndAddr Specifies the secure area end address\r\n  * @param  Banks the specific bank to apply Security protection\r\n  *          This parameter can be one of the following values:\r\n  *            @arg FLASH_BANK_1: Secure area on specified bank1 area\r\n  *            @arg FLASH_BANK_2: Secure area on specified bank2 area\r\n  *            @arg FLASH_BANK_BOTH: Secure area on specified bank1 and bank2 area (same config will be applied on both banks)\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_BANK(Banks));\r\n  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));\r\n\r\n  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));\r\n\r\n    /* Configure the secure area */\r\n    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \\\r\n                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \\\r\n                       (SecureAreaConfig & FLASH_SCAR_DMES);\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));\r\n\r\n    /* Configure the secure area */\r\n    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \\\r\n                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \\\r\n                       (SecureAreaConfig & FLASH_SCAR_DMES);\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n\r\n/**\r\n  * @brief  Get secure area configuration\r\n  * @param  SecureAreaConfig indicates if the secure area will be deleted or not\r\n  *         when RDP level decreased from Level 1 to Level 0 or during a mass erase.\r\n  * @param  SecureAreaStartAddr gives the secure area start address\r\n  * @param  SecureAreaEndAddr gives the secure area end address\r\n  * @param  Bank Specifies the Bank\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)\r\n{\r\n  uint32_t regvalue = 0;\r\n  uint32_t bankBase = 0;\r\n\r\n  /* Check Bank parameter value */\r\n  if(Bank == FLASH_BANK_1)\r\n  {\r\n    regvalue = FLASH->SCAR_CUR1;\r\n    bankBase = FLASH_BANK1_BASE;\r\n  }\r\n\r\n#if defined (DUAL_BANK)\r\n  if(Bank == FLASH_BANK_2)\r\n  {\r\n    regvalue = FLASH->SCAR_CUR2;\r\n    bankBase = FLASH_BANK2_BASE;\r\n  }\r\n#endif /* DUAL_BANK */\r\n\r\n  /* Get the secure area settings */\r\n  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);\r\n  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;\r\n  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;\r\n  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;\r\n}\r\n\r\n/**\r\n  * @brief  Add a CRC sector to the list of sectors on which the CRC will be calculated\r\n  * @param  Sector Specifies the CRC sector number\r\n  * @param  Bank Specifies the Bank\r\n  * @retval None\r\n  */\r\nstatic void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_FLASH_SECTOR(Sector));\r\n\r\n  if (Bank == FLASH_BANK_1)\r\n  {\r\n    /* Clear CRC sector */\r\n    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);\r\n\r\n    /* Select CRC Sector and activate ADD_SECT bit */\r\n    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else\r\n  {\r\n    /* Clear CRC sector */\r\n    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);\r\n\r\n    /* Select CRC Sector and activate ADD_SECT bit */\r\n    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n\r\n/**\r\n  * @brief  Select CRC start and end memory addresses on which the CRC will be calculated\r\n  * @param  CRCStartAddr Specifies the CRC start address\r\n  * @param  CRCEndAddr Specifies the CRC end address\r\n  * @param  Bank Specifies the Bank\r\n  * @retval None\r\n  */\r\nstatic void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)\r\n{\r\n  if (Bank == FLASH_BANK_1)\r\n  {\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));\r\n\r\n    /* Write CRC Start and End addresses */\r\n    FLASH->CRCSADD1 = CRCStartAddr;\r\n    FLASH->CRCEADD1 = CRCEndAddr;\r\n  }\r\n#if defined (DUAL_BANK)\r\n  else\r\n  {\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCStartAddr));\r\n    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCEndAddr));\r\n\r\n    /* Write CRC Start and End addresses */\r\n    FLASH->CRCSADD2 = CRCStartAddr;\r\n    FLASH->CRCEADD2 = CRCEndAddr;\r\n  }\r\n#endif /* DUAL_BANK */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n#if defined (FLASH_OTPBL_LOCKBL)\r\n/**\r\n  * @brief  Configure the OTP Block Lock.\r\n  * @param  OTP_Block specifies the OTP Block to lock.\r\n  *         This parameter can be a value of @ref FLASHEx_OTP_Blocks\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_OTP_LockConfig(uint32_t OTP_Block)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OTP_BLOCK(OTP_Block));\r\n\r\n  /* Configure the OTP Block lock in the option bytes register */\r\n  FLASH->OTPBL_PRG |= (OTP_Block & FLASH_OTPBL_LOCKBL);\r\n}\r\n\r\n/**\r\n  * @brief  Get the OTP Block Lock.\r\n  * @retval OTP_Block specifies the OTP Block to lock.\r\n  *         This return value can be a value of @ref FLASHEx_OTP_Blocks\r\n  */\r\nstatic uint32_t FLASH_OB_OTP_GetLock(void)\r\n{\r\n  return (FLASH->OTPBL_CUR);\r\n}\r\n#endif /* FLASH_OTPBL_LOCKBL */\r\n\r\n#if defined (FLASH_OPTSR2_TCM_AXI_SHARED)\r\n/**\r\n  * @brief  Configure the TCM / AXI Shared RAM.\r\n  * @param  SharedRamConfig specifies the Shared RAM configuration.\r\n  *         This parameter can be a value of @ref FLASHEx_OB_TCM_AXI_SHARED\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_SharedRAM_Config(uint32_t SharedRamConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_USER_TCM_AXI_SHARED(SharedRamConfig));\r\n\r\n  /* Configure the TCM / AXI Shared RAM in the option bytes register */\r\n  MODIFY_REG(FLASH->OPTSR2_PRG, FLASH_OPTSR2_TCM_AXI_SHARED, SharedRamConfig);\r\n}\r\n\r\n/**\r\n  * @brief  Get the TCM / AXI Shared RAM configuration.\r\n  * @retval SharedRamConfig returns the TCM / AXI Shared RAM configuration.\r\n  *         This return value can be a value of @ref FLASHEx_OB_TCM_AXI_SHARED\r\n  */\r\nstatic uint32_t FLASH_OB_SharedRAM_GetConfig(void)\r\n{\r\n  return (FLASH->OPTSR2_CUR & FLASH_OPTSR2_TCM_AXI_SHARED);\r\n}\r\n#endif /* FLASH_OPTSR2_TCM_AXI_SHARED */\r\n\r\n#if defined (FLASH_OPTSR2_CPUFREQ_BOOST)\r\n/**\r\n  * @brief  Configure the CPU Frequency Boost.\r\n  * @param  FreqBoost specifies the CPU Frequency Boost state.\r\n  *         This parameter can be a value of @ref FLASHEx_OB_CPUFREQ_BOOST\r\n  * @retval None\r\n  */\r\nstatic void FLASH_OB_CPUFreq_BoostConfig(uint32_t FreqBoost)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_OB_USER_CPUFREQ_BOOST(FreqBoost));\r\n\r\n  /* Configure the CPU Frequency Boost in the option bytes register */\r\n  MODIFY_REG(FLASH->OPTSR2_PRG, FLASH_OPTSR2_CPUFREQ_BOOST, FreqBoost);\r\n}\r\n\r\n/**\r\n  * @brief  Get the CPU Frequency Boost state.\r\n  * @retval FreqBoost returns the CPU Frequency Boost state.\r\n  *         This return value can be a value of @ref FLASHEx_OB_CPUFREQ_BOOST\r\n  */\r\nstatic uint32_t FLASH_OB_CPUFreq_GetBoost(void)\r\n{\r\n  return (FLASH->OPTSR2_CUR & FLASH_OPTSR2_CPUFREQ_BOOST);\r\n}\r\n#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */\r\n\r\n#endif /* HAL_FLASH_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_gpio.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_gpio.c\r\n  * @author  MCD Application Team\r\n  * @brief   GPIO HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the General Purpose Input/Output (GPIO) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                    ##### GPIO Peripheral features #####\r\n  ==============================================================================\r\n  [..]\r\n    (+) Each port bit of the general-purpose I/O (GPIO) ports can be individually\r\n        configured by software in several modes:\r\n        (++) Input mode\r\n        (++) Analog mode\r\n        (++) Output mode\r\n        (++) Alternate function mode\r\n        (++) External interrupt/event lines\r\n\r\n    (+) During and just after reset, the alternate functions and external interrupt\r\n        lines are not active and the I/O ports are configured in input floating mode.\r\n\r\n    (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be\r\n        activated or not.\r\n\r\n    (+) In Output or Alternate mode, each IO can be configured on open-drain or push-pull\r\n        type and the IO speed can be selected depending on the VDD value.\r\n\r\n    (+) The microcontroller IO pins are connected to onboard peripherals/modules through a\r\n        multiplexer that allows only one peripheral alternate function (AF) connected\r\n       to an IO pin at a time. In this way, there can be no conflict between peripherals\r\n       sharing the same IO pin.\r\n\r\n    (+) All ports have external interrupt/event capability. To use external interrupt\r\n        lines, the port must be configured in input mode. All available GPIO pins are\r\n        connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.\r\n\r\n  The external interrupt/event controller consists of up to 23 edge detectors\r\n        (16 lines are connected to GPIO) for generating event/interrupt requests (each\r\n        input line can be independently configured to select the type (interrupt or event)\r\n        and the corresponding trigger event (rising or falling or both). Each line can\r\n        also be masked independently.\r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n    (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE().\r\n\r\n    (#) Configure the GPIO pin(s) using HAL_GPIO_Init().\r\n        (++) Configure the IO mode using \"Mode\" member from GPIO_InitTypeDef structure\r\n        (++) Activate Pull-up, Pull-down resistor using \"Pull\" member from GPIO_InitTypeDef\r\n             structure.\r\n        (++) In case of Output or alternate function mode selection: the speed is\r\n             configured through \"Speed\" member from GPIO_InitTypeDef structure.\r\n        (++) In alternate mode is selection, the alternate function connected to the IO\r\n             is configured through \"Alternate\" member from GPIO_InitTypeDef structure.\r\n        (++) Analog mode is required when a pin is to be used as ADC channel\r\n             or DAC output.\r\n        (++) In case of external interrupt/event selection the \"Mode\" member from\r\n             GPIO_InitTypeDef structure select the type (interrupt or event) and\r\n             the corresponding trigger event (rising or falling or both).\r\n\r\n    (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority\r\n        mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using\r\n        HAL_NVIC_EnableIRQ().\r\n\r\n    (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().\r\n\r\n    (#) To set/reset the level of a pin configured in output mode use\r\n        HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().\r\n\r\n   (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().\r\n\r\n\r\n    (#) During and just after reset, the alternate functions are not\r\n        active and the GPIO pins are configured in input floating mode (except JTAG\r\n        pins).\r\n\r\n    (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose\r\n        (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has\r\n        priority over the GPIO function.\r\n\r\n    (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as\r\n        general purpose PH0 and PH1, respectively, when the HSE oscillator is off.\r\n        The HSE has priority over the GPIO function.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup GPIO  GPIO\r\n  * @brief GPIO HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_GPIO_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines ------------------------------------------------------------*/\r\n/** @addtogroup GPIO_Private_Constants GPIO Private Constants\r\n  * @{\r\n  */\r\n\r\n#if defined(DUAL_CORE)\r\n#define EXTI_CPU1             (0x01000000U)\r\n#define EXTI_CPU2             (0x02000000U)\r\n#endif /*DUAL_CORE*/\r\n#define GPIO_NUMBER           (16U)\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup GPIO_Exported_Functions GPIO Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n  [..]\r\n    This section provides functions allowing to initialize and de-initialize the GPIOs\r\n    to be ready for use.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.\r\n  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains\r\n  *         the configuration information for the specified GPIO peripheral.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)\r\n{\r\n  uint32_t position = 0x00U;\r\n  uint32_t iocurrent;\r\n  uint32_t temp;\r\n  EXTI_Core_TypeDef *EXTI_CurrentCPU;\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */\r\n#else\r\n  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */\r\n#endif\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));\r\n  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));\r\n\r\n  /* Configure the port pins */\r\n  while (((GPIO_Init->Pin) >> position) != 0x00U)\r\n  {\r\n    /* Get current io position */\r\n    iocurrent = (GPIO_Init->Pin) & (1UL << position);\r\n\r\n    if (iocurrent != 0x00U)\r\n    {\r\n      /*--------------------- GPIO Mode Configuration ------------------------*/\r\n      /* In case of Output or Alternate function mode selection */\r\n      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))\r\n      {\r\n        /* Check the Speed parameter */\r\n        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\r\n\r\n        /* Configure the IO Speed */\r\n        temp = GPIOx->OSPEEDR;\r\n        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));\r\n        temp |= (GPIO_Init->Speed << (position * 2U));\r\n        GPIOx->OSPEEDR = temp;\r\n\r\n        /* Configure the IO Output Type */\r\n        temp = GPIOx->OTYPER;\r\n        temp &= ~(GPIO_OTYPER_OT0 << position) ;\r\n        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);\r\n        GPIOx->OTYPER = temp;\r\n      }\r\n\r\n      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)\r\n      {\r\n       /* Check the Pull parameter */\r\n       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));\r\n\r\n      /* Activate the Pull-up or Pull down resistor for the current IO */\r\n      temp = GPIOx->PUPDR;\r\n      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));\r\n      temp |= ((GPIO_Init->Pull) << (position * 2U));\r\n      GPIOx->PUPDR = temp;\r\n      }\r\n\r\n      /* In case of Alternate function mode selection */\r\n      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)\r\n      {\r\n        /* Check the Alternate function parameters */\r\n        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));\r\n        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));\r\n\r\n        /* Configure Alternate function mapped with the current IO */\r\n        temp = GPIOx->AFR[position >> 3U];\r\n        temp &= ~(0xFU << ((position & 0x07U) * 4U));\r\n        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));\r\n        GPIOx->AFR[position >> 3U] = temp;\r\n      }\r\n\r\n      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */\r\n      temp = GPIOx->MODER;\r\n      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));\r\n      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));\r\n      GPIOx->MODER = temp;\r\n\r\n      /*--------------------- EXTI Mode Configuration ------------------------*/\r\n      /* Configure the External Interrupt or event for the current IO */\r\n      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)\r\n      {\r\n        /* Enable SYSCFG Clock */\r\n        __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n        temp = SYSCFG->EXTICR[position >> 2U];\r\n        temp &= ~(0x0FUL << (4U * (position & 0x03U)));\r\n        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));\r\n        SYSCFG->EXTICR[position >> 2U] = temp;\r\n\r\n        /* Clear Rising Falling edge configuration */\r\n        temp = EXTI->RTSR1;\r\n        temp &= ~(iocurrent);\r\n        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->RTSR1 = temp;\r\n\r\n        temp = EXTI->FTSR1;\r\n        temp &= ~(iocurrent);\r\n        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI->FTSR1 = temp;\r\n\r\n        temp = EXTI_CurrentCPU->EMR1;\r\n        temp &= ~(iocurrent);\r\n        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI_CurrentCPU->EMR1 = temp;\r\n\r\n        /* Clear EXTI line configuration */\r\n        temp = EXTI_CurrentCPU->IMR1;\r\n        temp &= ~(iocurrent);\r\n        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)\r\n        {\r\n          temp |= iocurrent;\r\n        }\r\n        EXTI_CurrentCPU->IMR1 = temp;\r\n      }\r\n    }\r\n\r\n    position++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  De-initializes the GPIOx peripheral registers to their default reset values.\r\n  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin: specifies the port bit to be written.\r\n  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\r\n{\r\n  uint32_t position = 0x00U;\r\n  uint32_t iocurrent;\r\n  uint32_t tmp;\r\n  EXTI_Core_TypeDef *EXTI_CurrentCPU;\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */\r\n#else\r\n  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */\r\n#endif\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* Configure the port pins */\r\n  while ((GPIO_Pin >> position) != 0x00U)\r\n  {\r\n    /* Get current io position */\r\n    iocurrent = GPIO_Pin & (1UL << position) ;\r\n\r\n    if (iocurrent != 0x00U)\r\n    {\r\n      /*------------------------- EXTI Mode Configuration --------------------*/\r\n      /* Clear the External Interrupt or Event for the current IO */\r\n      tmp = SYSCFG->EXTICR[position >> 2U];\r\n      tmp &= (0x0FUL << (4U * (position & 0x03U)));\r\n      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))\r\n      {\r\n        /* Clear EXTI line configuration for Current CPU */\r\n        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);\r\n        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);\r\n\r\n        /* Clear Rising Falling edge configuration */\r\n        EXTI->FTSR1 &= ~(iocurrent);\r\n        EXTI->RTSR1 &= ~(iocurrent);\r\n\r\n        tmp = 0x0FUL << (4U * (position & 0x03U));\r\n        SYSCFG->EXTICR[position >> 2U] &= ~tmp;\r\n      }\r\n\r\n      /*------------------------- GPIO Mode Configuration --------------------*/\r\n      /* Configure IO in Analog Mode */\r\n      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));\r\n\r\n      /* Configure the default Alternate Function in current IO */\r\n      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;\r\n\r\n      /* Deactivate the Pull-up and Pull-down resistor for the current IO */\r\n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));\r\n\r\n      /* Configure the default value IO Output Type */\r\n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;\r\n\r\n      /* Configure the default value for IO Speed */\r\n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));\r\n    }\r\n\r\n    position++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup GPIO_Exported_Functions_Group2 IO operation functions\r\n *  @brief GPIO Read, Write, Toggle, Lock and EXTI management functions.\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                       ##### IO operation functions #####\r\n ===============================================================================\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Reads the specified input port pin.\r\n  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin: specifies the port bit to read.\r\n  *         This parameter can be GPIO_PIN_x where x can be (0..15).\r\n  * @retval The input port pin value.\r\n  */\r\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  GPIO_PinState bitstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)\r\n  {\r\n    bitstatus = GPIO_PIN_SET;\r\n  }\r\n  else\r\n  {\r\n    bitstatus = GPIO_PIN_RESET;\r\n  }\r\n  return bitstatus;\r\n}\r\n\r\n/**\r\n  * @brief  Sets or clears the selected data port bit.\r\n  *\r\n  * @note   This function uses GPIOx_BSRR register to allow atomic read/modify\r\n  *         accesses. In this way, there is no risk of an IRQ occurring between\r\n  *         the read and the modify access.\r\n  *\r\n  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin: specifies the port bit to be written.\r\n  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).\r\n  * @param  PinState: specifies the value to be written to the selected bit.\r\n  *          This parameter can be one of the GPIO_PinState enum values:\r\n  *            @arg GPIO_PIN_RESET: to clear the port pin\r\n  *            @arg GPIO_PIN_SET: to set the port pin\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\r\n\r\n  if (PinState != GPIO_PIN_RESET)\r\n  {\r\n    GPIOx->BSRR = GPIO_Pin;\r\n  }\r\n  else\r\n  {\r\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Toggles the specified GPIO pins.\r\n  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.\r\n  * @param  GPIO_Pin: Specifies the pins to be toggled.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  uint32_t odr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* get current Output Data Register value */\r\n  odr = GPIOx->ODR;\r\n\r\n  /* Set selected pins that were at low level, and reset ones that were high */\r\n  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);\r\n}\r\n\r\n/**\r\n  * @brief  Locks GPIO Pins configuration registers.\r\n  * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,\r\n  *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.\r\n  * @note   The configuration of the locked GPIO pins can no longer be modified\r\n  *         until the next reset.\r\n  * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32H7 family\r\n  * @param  GPIO_Pin: specifies the port bit to be locked.\r\n  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\r\n{\r\n  __IO uint32_t tmp = GPIO_LCKR_LCKK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));\r\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\r\n\r\n  /* Apply lock key write sequence */\r\n  tmp |= GPIO_Pin;\r\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\r\n  GPIOx->LCKR = tmp;\r\n  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */\r\n  GPIOx->LCKR = GPIO_Pin;\r\n  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */\r\n  GPIOx->LCKR = tmp;\r\n  /* Read LCKK register. This read is mandatory to complete key lock sequence*/\r\n  tmp = GPIOx->LCKR;\r\n\r\n  /* read again in order to confirm lock is active */\r\n  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)\r\n  {\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Handle EXTI interrupt request.\r\n  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.\r\n  * @retval None\r\n  */\r\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\r\n{\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  if (__HAL_GPIO_EXTID2_GET_IT(GPIO_Pin) != 0x00U)\r\n  {\r\n    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);\r\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\r\n  }\r\n#else\r\n  /* EXTI line interrupt detected */\r\n  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)\r\n  {\r\n    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);\r\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\r\n  }\r\n#endif\r\n}\r\n\r\n/**\r\n  * @brief  EXTI line detection callback.\r\n  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.\r\n  * @retval None\r\n  */\r\n__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(GPIO_Pin);\r\n\r\n  /* NOTE: This function Should not be modified, when the callback is needed,\r\n           the HAL_GPIO_EXTI_Callback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_GPIO_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_hsem.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_hsem.c\r\n  * @author  MCD Application Team\r\n  * @brief   HSEM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the semaphore peripheral:\r\n  *           + Semaphore Take function (2-Step Procedure) , non blocking\r\n  *           + Semaphore FastTake function (1-Step Procedure) , non blocking\r\n  *           + Semaphore Status check\r\n  *           + Semaphore Clear Key Set and Get\r\n  *           + Release and release all functions\r\n  *           + Semaphore notification enabling and disabling and callnack functions\r\n  *           + IRQ handler management\r\n  *\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n      (#)Take a semaphore In 2-Step mode Using function HAL_HSEM_Take. This function takes as parameters :\r\n           (++) the semaphore ID from 0 to 31\r\n           (++) the process ID from 0 to 255\r\n      (#) Fast Take semaphore In 1-Step mode Using function HAL_HSEM_FastTake. This function takes as parameter :\r\n           (++) the semaphore ID from 0_ID to 31. Note that the process ID value is implicitly assumed as zero\r\n      (#) Check if a semaphore is Taken using function HAL_HSEM_IsSemTaken. This function takes as parameter :\r\n          (++) the semaphore ID from 0_ID to 31\r\n          (++) It returns 1 if the given semaphore is taken otherwise (Free) zero\r\n      (#)Release a semaphore using function with HAL_HSEM_Release. This function takes as parameters :\r\n           (++) the semaphore ID from 0 to 31\r\n           (++) the process ID from 0 to 255:\r\n           (++) Note: If ProcessID and MasterID match, semaphore is freed, and an interrupt\r\n         may be generated when enabled (notification activated). If ProcessID or MasterID does not match,\r\n         semaphore remains taken (locked)\r\n\r\n      (#)Release all semaphores at once taken by a given Master using function HAL_HSEM_Release_All\r\n          This function takes as parameters :\r\n           (++) the Release Key (value from 0 to 0xFFFF) can be Set or Get respectively by\r\n              HAL_HSEM_SetClearKey() or HAL_HSEM_GetClearKey functions\r\n           (++) the Master ID:\r\n           (++) Note: If the Key and MasterID match, all semaphores taken by the given CPU that corresponds\r\n           to MasterID  will be freed, and an interrupt may be generated when enabled (notification activated). If the\r\n           Key or the MasterID doesn't match, semaphores remains taken (locked)\r\n\r\n      (#)Semaphores Release all key functions:\r\n         (++)  HAL_HSEM_SetClearKey() to set semaphore release all Key\r\n         (++)  HAL_HSEM_GetClearKey() to get release all Key\r\n      (#)Semaphores notification functions :\r\n         (++)  HAL_HSEM_ActivateNotification to activate a notification callback on\r\n               a given semaphores Mask (bitfield). When one or more semaphores defined by the mask are released\r\n               the callback HAL_HSEM_FreeCallback will be asserted giving as parameters a mask of the released\r\n               semaphores (bitfield).\r\n\r\n         (++)  HAL_HSEM_DeactivateNotification to deactivate the notification of a given semaphores Mask (bitfield).\r\n         (++) See the description of the macro __HAL_HSEM_SEMID_TO_MASK to check how to calculate a semaphore mask\r\n                Used by the notification functions\r\n     *** HSEM HAL driver macros list ***\r\n     =============================================\r\n     [..] Below the list of most used macros in HSEM HAL driver.\r\n\r\n      (+) __HAL_HSEM_SEMID_TO_MASK: Helper macro to convert a Semaphore ID to a Mask.\r\n      [..] Example of use :\r\n      [..] mask = __HAL_HSEM_SEMID_TO_MASK(8)  |  __HAL_HSEM_SEMID_TO_MASK(21) | __HAL_HSEM_SEMID_TO_MASK(25).\r\n      [..] All next macros take as parameter a semaphore Mask (bitfiled) that can be constructed using  __HAL_HSEM_SEMID_TO_MASK as the above example.\r\n      (+) __HAL_HSEM_ENABLE_IT: Enable the specified semaphores Mask interrupts.\r\n      (+) __HAL_HSEM_DISABLE_IT: Disable the specified semaphores Mask interrupts.\r\n      (+) __HAL_HSEM_GET_IT: Checks whether the specified semaphore interrupt has occurred or not.\r\n      (+) __HAL_HSEM_GET_FLAG: Get the semaphores status release flags.\r\n      (+) __HAL_HSEM_CLEAR_FLAG: Clear the semaphores status release flags.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HSEM HSEM\r\n  * @brief HSEM HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_HSEM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n#if defined(DUAL_CORE)\r\n/** @defgroup HSEM_Private_Constants  HSEM Private Constants\r\n  * @{\r\n  */\r\n\r\n#ifndef HSEM_R_MASTERID\r\n#define HSEM_R_MASTERID HSEM_R_COREID\r\n#endif\r\n\r\n#ifndef HSEM_RLR_MASTERID\r\n#define HSEM_RLR_MASTERID HSEM_RLR_COREID\r\n#endif\r\n\r\n#ifndef HSEM_CR_MASTERID\r\n#define HSEM_CR_MASTERID HSEM_CR_COREID\r\n#endif\r\n\r\n/**\r\n  * @}\r\n  */  \r\n#endif /* DUAL_CORE */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup HSEM_Exported_Functions  HSEM Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup HSEM_Exported_Functions_Group1 Take and Release functions\r\n  *  @brief    HSEM Take and Release functions\r\n  *\r\n@verbatim\r\n ==============================================================================\r\n              ##### HSEM Take and Release functions #####\r\n ==============================================================================\r\n[..] This section provides functions allowing to:\r\n      (+) Take a semaphore with 2 Step method\r\n      (+) Fast Take a semaphore with 1 Step method\r\n      (+) Check semaphore state Taken or not\r\n      (+) Release a semaphore\r\n      (+) Release all semaphore at once\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Take a semaphore in 2 Step mode.\r\n  * @param  SemID: semaphore ID from 0 to 31\r\n  * @param  ProcessID: Process ID from 0 to 255\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef  HAL_HSEM_Take(uint32_t SemID, uint32_t ProcessID)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_HSEM_SEMID(SemID));\r\n  assert_param(IS_HSEM_PROCESSID(ProcessID));\r\n\r\n#if  USE_MULTI_CORE_SHARED_CODE != 0U\r\n  /* First step  write R register with MasterID, processID and take bit=1*/\r\n  HSEM->R[SemID] = ((ProcessID & HSEM_R_PROCID) | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID) | HSEM_R_LOCK);\r\n\r\n  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */\r\n  if (HSEM->R[SemID] == ((ProcessID & HSEM_R_PROCID) | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID) | HSEM_R_LOCK))\r\n  {\r\n    /*take success when MasterID and ProcessID match and take bit set*/\r\n    return HAL_OK;\r\n  }\r\n#else\r\n  /* First step  write R register with MasterID, processID and take bit=1*/\r\n  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);\r\n\r\n  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */\r\n  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))\r\n  {\r\n    /*take success when MasterID and ProcessID match and take bit set*/\r\n    return HAL_OK;\r\n  }\r\n#endif\r\n\r\n  /* Semaphore take fails*/\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Fast Take a semaphore with 1 Step mode.\r\n  * @param  SemID: semaphore ID from 0 to 31\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_HSEM_SEMID(SemID));\r\n\r\n#if  USE_MULTI_CORE_SHARED_CODE != 0U\r\n  /* Read the RLR register to take the semaphore */\r\n  if (HSEM->RLR[SemID] == (((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_RLR_MASTERID) | HSEM_RLR_LOCK))\r\n  {\r\n    /*take success when MasterID match and take bit set*/\r\n    return HAL_OK;\r\n  }\r\n#else  \r\n  /* Read the RLR register to take the semaphore */\r\n  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))\r\n  {\r\n    /*take success when MasterID match and take bit set*/\r\n    return HAL_OK;\r\n  }\r\n#endif\r\n\r\n  /* Semaphore take fails */\r\n  return HAL_ERROR;\r\n}\r\n/**\r\n  * @brief  Check semaphore state Taken or not.\r\n  * @param  SemID: semaphore ID\r\n  * @retval HAL HSEM state\r\n  */\r\nuint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)\r\n{\r\n  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Release a semaphore.\r\n  * @param  SemID: semaphore ID from 0 to 31\r\n  * @param  ProcessID: Process ID from 0 to 255\r\n  * @retval None\r\n  */\r\nvoid  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_HSEM_SEMID(SemID));\r\n  assert_param(IS_HSEM_PROCESSID(ProcessID));\r\n\r\n  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */\r\n#if  USE_MULTI_CORE_SHARED_CODE != 0U\r\n  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));\r\n#else\r\n  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);\r\n#endif\r\n\r\n}\r\n\r\n/**\r\n  * @brief  Release All semaphore used by a given Master .\r\n  * @param  Key: Semaphore Key , value from 0 to 0xFFFF\r\n  * @param  CoreID: CoreID of the CPU that is using semaphores to be released\r\n  * @retval None\r\n  */\r\nvoid HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)\r\n{\r\n  assert_param(IS_HSEM_KEY(Key));\r\n  assert_param(IS_HSEM_COREID(CoreID));\r\n\r\n  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup HSEM_Exported_Functions_Group2 HSEM Set and Get Key functions\r\n  *  @brief    HSEM Set and Get Key functions.\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### HSEM Set and Get Key functions #####\r\n  ==============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Set semaphore Key\r\n      (+) Get semaphore Key\r\n@endverbatim\r\n\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Set semaphore Key .\r\n  * @param  Key: Semaphore Key , value from 0 to 0xFFFF\r\n  * @retval None\r\n  */\r\nvoid  HAL_HSEM_SetClearKey(uint32_t Key)\r\n{\r\n  assert_param(IS_HSEM_KEY(Key));\r\n\r\n  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));\r\n\r\n}\r\n\r\n/**\r\n  * @brief  Get semaphore Key .\r\n  * @retval Semaphore Key , value from 0 to 0xFFFF\r\n  */\r\nuint32_t HAL_HSEM_GetClearKey(void)\r\n{\r\n  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup HSEM_Exported_Functions_Group3 HSEM IRQ handler management\r\n  *  @brief    HSEM Notification functions.\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n      ##### HSEM IRQ handler management and Notification functions #####\r\n  ==============================================================================\r\n[..]  This section provides HSEM IRQ handler and Notification function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .\r\n  * @param  SemMask: Mask of Released semaphores\r\n  * @retval Semaphore Key\r\n  */\r\nvoid HAL_HSEM_ActivateNotification(uint32_t SemMask)\r\n{\r\n#if  USE_MULTI_CORE_SHARED_CODE != 0U\r\n  /*enable the semaphore mask interrupts */\r\n  if (HAL_GetCurrentCPUID() == HSEM_CPU1_COREID)\r\n  {\r\n    /*Use interrupt line 0 for CPU1 Master */\r\n    HSEM->C1IER |= SemMask;\r\n  }\r\n  else /* HSEM_CPU2_COREID */\r\n  {\r\n    /*Use interrupt line 1 for CPU2 Master*/\r\n    HSEM->C2IER |= SemMask;\r\n  }\r\n#else\r\n  HSEM_COMMON->IER |= SemMask;\r\n#endif\r\n}\r\n\r\n/**\r\n  * @brief  Deactivate Semaphore release Notification for a given Semaphores Mask .\r\n  * @param  SemMask: Mask of Released semaphores\r\n  * @retval Semaphore Key\r\n  */\r\nvoid HAL_HSEM_DeactivateNotification(uint32_t SemMask)\r\n{\r\n#if  USE_MULTI_CORE_SHARED_CODE != 0U\r\n  /*enable the semaphore mask interrupts */\r\n  if (HAL_GetCurrentCPUID() == HSEM_CPU1_COREID)\r\n  {\r\n    /*Use interrupt line 0 for CPU1 Master */\r\n    HSEM->C1IER &= ~SemMask;\r\n  }\r\n  else /* HSEM_CPU2_COREID */\r\n  {\r\n    /*Use interrupt line 1 for CPU2 Master*/\r\n    HSEM->C2IER &= ~SemMask;\r\n  }\r\n#else\r\n  HSEM_COMMON->IER &= ~SemMask;\r\n#endif\r\n}\r\n\r\n/**\r\n  * @brief  This function handles HSEM interrupt request\r\n  * @retval None\r\n  */\r\nvoid HAL_HSEM_IRQHandler(void)\r\n{\r\n  uint32_t statusreg;\r\n#if  USE_MULTI_CORE_SHARED_CODE != 0U\r\n  if (HAL_GetCurrentCPUID() == HSEM_CPU1_COREID)\r\n  {\r\n    /* Get the list of masked freed semaphores*/\r\n    statusreg = HSEM->C1MISR; /*Use interrupt line 0 for CPU1 Master*/\r\n\r\n    /*Disable Interrupts*/\r\n    HSEM->C1IER &= ~((uint32_t)statusreg);\r\n\r\n    /*Clear Flags*/\r\n    HSEM->C1ICR = ((uint32_t)statusreg);\r\n  }\r\n  else /* HSEM_CPU2_COREID */\r\n  {\r\n    /* Get the list of masked freed semaphores*/\r\n    statusreg = HSEM->C2MISR;/*Use interrupt line 1 for CPU2 Master*/\r\n\r\n    /*Disable Interrupts*/\r\n    HSEM->C2IER &= ~((uint32_t)statusreg);\r\n\r\n    /*Clear Flags*/\r\n    HSEM->C2ICR = ((uint32_t)statusreg);\r\n  }\r\n#else\r\n  /* Get the list of masked freed semaphores*/\r\n  statusreg = HSEM_COMMON->MISR;\r\n\r\n  /*Disable Interrupts*/\r\n  HSEM_COMMON->IER &= ~((uint32_t)statusreg);\r\n\r\n  /*Clear Flags*/\r\n  HSEM_COMMON->ICR = ((uint32_t)statusreg);\r\n\r\n#endif\r\n  /* Call FreeCallback */\r\n  HAL_HSEM_FreeCallback(statusreg);\r\n}\r\n\r\n/**\r\n  * @brief Semaphore Released Callback.\r\n  * @param SemMask: Mask of Released semaphores\r\n  * @retval None\r\n  */\r\n__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(SemMask);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n  the HAL_HSEM_FreeCallback can be implemented in the user file\r\n    */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_HSEM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_i2c.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_i2c.c\r\n  * @author  MCD Application Team\r\n  * @brief   I2C HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Inter Integrated Circuit (I2C) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral State and Errors functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n    The I2C HAL driver can be used as follows:\r\n\r\n    (#) Declare a I2C_HandleTypeDef handle structure, for example:\r\n        I2C_HandleTypeDef  hi2c;\r\n\r\n    (#)Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API:\r\n        (##) Enable the I2Cx interface clock\r\n        (##) I2C pins configuration\r\n            (+++) Enable the clock for the I2C GPIOs\r\n            (+++) Configure I2C pins as alternate function open-drain\r\n        (##) NVIC configuration if you need to use interrupt process\r\n            (+++) Configure the I2Cx interrupt priority\r\n            (+++) Enable the NVIC I2C IRQ Channel\r\n        (##) DMA Configuration if you need to use DMA process\r\n            (+++) Declare a DMA_HandleTypeDef handle structure for\r\n                  the transmit or receive stream or channel depends on Instance\r\n            (+++) Enable the DMAx interface clock using\r\n            (+++) Configure the DMA handle parameters\r\n            (+++) Configure the DMA Tx or Rx stream or channel depends on Instance\r\n            (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle\r\n            (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on\r\n                  the DMA Tx or Rx stream or channel depends on Instance\r\n\r\n    (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,\r\n        Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.\r\n\r\n    (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware\r\n        (GPIO, CLOCK, NVIC...etc) by calling the customized HAL_I2C_MspInit(&hi2c) API.\r\n\r\n    (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()\r\n\r\n    (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :\r\n\r\n    *** Polling mode IO operation ***\r\n    =================================\r\n    [..]\r\n      (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()\r\n      (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()\r\n      (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()\r\n      (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()\r\n\r\n    *** Polling mode IO MEM operation ***\r\n    =====================================\r\n    [..]\r\n      (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()\r\n      (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()\r\n\r\n\r\n    *** Interrupt mode IO operation ***\r\n    ===================================\r\n    [..]\r\n      (+) Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT()\r\n      (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()\r\n      (+) Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT()\r\n      (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()\r\n      (+) Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT()\r\n      (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()\r\n      (+) Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT()\r\n      (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n      (+) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()\r\n      (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()\r\n      (+) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.\r\n           This action will inform Master to generate a Stop condition to discard the communication.\r\n\r\n\r\n    *** Interrupt mode or DMA mode IO sequential operation ***\r\n    ==========================================================\r\n    [..]\r\n      (@) These interfaces allow to manage a sequential transfer with a repeated start condition\r\n          when a direction change during transfer\r\n    [..]\r\n      (+) A specific option field manage the different steps of a sequential transfer\r\n      (+) Option field values are defined through I2C_XFEROPTIONS and are listed below:\r\n      (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functional is same as associated interfaces in\r\n           no sequential mode\r\n      (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address\r\n                            and data to transfer without a final stop condition\r\n      (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with\r\n                            start condition, address and data to transfer without a final stop condition,\r\n                            an then permit a call the same master sequential interface several times\r\n                            (like HAL_I2C_Master_Seq_Transmit_IT() then HAL_I2C_Master_Seq_Transmit_IT()\r\n                            or HAL_I2C_Master_Seq_Transmit_DMA() then HAL_I2C_Master_Seq_Transmit_DMA())\r\n      (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address\r\n                            and with new data to transfer if the direction change or manage only the new data to\r\n                            transfer\r\n                            if no direction change and without a final stop condition in both cases\r\n      (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address\r\n                            and with new data to transfer if the direction change or manage only the new data to\r\n                            transfer\r\n                            if no direction change and with a final stop condition in both cases\r\n      (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition\r\n                            after several call of the same master sequential interface several times\r\n                            (link with option I2C_FIRST_AND_NEXT_FRAME).\r\n                            Usage can, transfer several bytes one by one using\r\n                              HAL_I2C_Master_Seq_Transmit_IT\r\n                              or HAL_I2C_Master_Seq_Receive_IT\r\n                              or HAL_I2C_Master_Seq_Transmit_DMA\r\n                              or HAL_I2C_Master_Seq_Receive_DMA\r\n                              with option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME.\r\n                             Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or\r\n                              Receive sequence permit to call the opposite interface Receive or Transmit\r\n                              without stopping the communication and so generate a restart condition.\r\n      (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after\r\n                            each call of the same master sequential\r\n                            interface.\r\n                            Usage can, transfer several bytes one by one with a restart with slave address between\r\n                            each bytes using\r\n                              HAL_I2C_Master_Seq_Transmit_IT\r\n                              or HAL_I2C_Master_Seq_Receive_IT\r\n                              or HAL_I2C_Master_Seq_Transmit_DMA\r\n                              or HAL_I2C_Master_Seq_Receive_DMA\r\n                              with option I2C_FIRST_FRAME then I2C_OTHER_FRAME.\r\n                            Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic\r\n                            generation of STOP condition.\r\n\r\n      (+) Different sequential I2C interfaces are listed below:\r\n      (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Master_Seq_Transmit_IT() or using HAL_I2C_Master_Seq_Transmit_DMA()\r\n      (+++) At transmission end of current frame transfer, HAL_I2C_MasterTxCpltCallback() is executed and\r\n            users can add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()\r\n      (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Master_Seq_Receive_IT() or using HAL_I2C_Master_Seq_Receive_DMA()\r\n      (+++) At reception end of current frame transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()\r\n      (++) Abort a master IT or DMA I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()\r\n      (+++) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()\r\n      (++) Enable/disable the Address listen mode in slave I2C mode using HAL_I2C_EnableListen_IT()\r\n            HAL_I2C_DisableListen_IT()\r\n      (+++) When address slave I2C match, HAL_I2C_AddrCallback() is executed and users can\r\n           add their own code to check the Address Match Code and the transmission direction request by master\r\n           (Write/Read).\r\n      (+++) At Listen mode end HAL_I2C_ListenCpltCallback() is executed and users can\r\n          add their own code by customization of function pointer HAL_I2C_ListenCpltCallback()\r\n      (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Slave_Seq_Transmit_IT() or using HAL_I2C_Slave_Seq_Transmit_DMA()\r\n      (+++) At transmission end of current frame transfer, HAL_I2C_SlaveTxCpltCallback() is executed and\r\n            users can add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()\r\n      (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using\r\n            HAL_I2C_Slave_Seq_Receive_IT() or using HAL_I2C_Slave_Seq_Receive_DMA()\r\n      (+++) At reception end of current frame transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()\r\n      (++) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n      (++) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.\r\n           This action will inform Master to generate a Stop condition to discard the communication.\r\n\r\n    *** Interrupt mode IO MEM operation ***\r\n    =======================================\r\n    [..]\r\n      (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using\r\n          HAL_I2C_Mem_Write_IT()\r\n      (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemTxCpltCallback()\r\n      (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using\r\n          HAL_I2C_Mem_Read_IT()\r\n      (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n\r\n    *** DMA mode IO operation ***\r\n    ==============================\r\n    [..]\r\n      (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Master_Transmit_DMA()\r\n      (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()\r\n      (+) Receive in master mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Master_Receive_DMA()\r\n      (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()\r\n      (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Slave_Transmit_DMA()\r\n      (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()\r\n      (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using\r\n          HAL_I2C_Slave_Receive_DMA()\r\n      (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n      (+) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()\r\n      (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()\r\n      (+) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.\r\n           This action will inform Master to generate a Stop condition to discard the communication.\r\n\r\n    *** DMA mode IO MEM operation ***\r\n    =================================\r\n    [..]\r\n      (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using\r\n          HAL_I2C_Mem_Write_DMA()\r\n      (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemTxCpltCallback()\r\n      (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using\r\n          HAL_I2C_Mem_Read_DMA()\r\n      (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_MemRxCpltCallback()\r\n      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can\r\n           add their own code by customization of function pointer HAL_I2C_ErrorCallback()\r\n\r\n\r\n     *** I2C HAL driver macros list ***\r\n     ==================================\r\n     [..]\r\n       Below the list of most used macros in I2C HAL driver.\r\n\r\n      (+) __HAL_I2C_ENABLE: Enable the I2C peripheral\r\n      (+) __HAL_I2C_DISABLE: Disable the I2C peripheral\r\n      (+) __HAL_I2C_GENERATE_NACK: Generate a Non-Acknowledge I2C peripheral in Slave mode\r\n      (+) __HAL_I2C_GET_FLAG: Check whether the specified I2C flag is set or not\r\n      (+) __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag\r\n      (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt\r\n      (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt\r\n\r\n     *** Callback registration ***\r\n     =============================================\r\n    [..]\r\n     The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1\r\n     allows the user to configure dynamically the driver callbacks.\r\n     Use Functions HAL_I2C_RegisterCallback() or HAL_I2C_RegisterAddrCallback()\r\n     to register an interrupt callback.\r\n    [..]\r\n     Function HAL_I2C_RegisterCallback() allows to register following callbacks:\r\n       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.\r\n       (+) MasterRxCpltCallback : callback for Master reception end of transfer.\r\n       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.\r\n       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.\r\n       (+) ListenCpltCallback   : callback for end of listen mode.\r\n       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.\r\n       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.\r\n       (+) ErrorCallback        : callback for error detection.\r\n       (+) AbortCpltCallback    : callback for abort completion process.\r\n       (+) MspInitCallback      : callback for Msp Init.\r\n       (+) MspDeInitCallback    : callback for Msp DeInit.\r\n     This function takes as parameters the HAL peripheral handle, the Callback ID\r\n     and a pointer to the user callback function.\r\n    [..]\r\n     For specific callback AddrCallback use dedicated register callbacks : HAL_I2C_RegisterAddrCallback().\r\n    [..]\r\n     Use function HAL_I2C_UnRegisterCallback to reset a callback to the default\r\n     weak function.\r\n     HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n     and the Callback ID.\r\n     This function allows to reset following callbacks:\r\n       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.\r\n       (+) MasterRxCpltCallback : callback for Master reception end of transfer.\r\n       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.\r\n       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.\r\n       (+) ListenCpltCallback   : callback for end of listen mode.\r\n       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.\r\n       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.\r\n       (+) ErrorCallback        : callback for error detection.\r\n       (+) AbortCpltCallback    : callback for abort completion process.\r\n       (+) MspInitCallback      : callback for Msp Init.\r\n       (+) MspDeInitCallback    : callback for Msp DeInit.\r\n    [..]\r\n     For callback AddrCallback use dedicated register callbacks : HAL_I2C_UnRegisterAddrCallback().\r\n    [..]\r\n     By default, after the HAL_I2C_Init() and when the state is HAL_I2C_STATE_RESET\r\n     all callbacks are set to the corresponding weak functions:\r\n     examples HAL_I2C_MasterTxCpltCallback(), HAL_I2C_MasterRxCpltCallback().\r\n     Exception done for MspInit and MspDeInit functions that are\r\n     reset to the legacy weak functions in the HAL_I2C_Init()/ HAL_I2C_DeInit() only when\r\n     these callbacks are null (not registered beforehand).\r\n     If MspInit or MspDeInit are not null, the HAL_I2C_Init()/ HAL_I2C_DeInit()\r\n     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.\r\n    [..]\r\n     Callbacks can be registered/unregistered in HAL_I2C_STATE_READY state only.\r\n     Exception done MspInit/MspDeInit functions that can be registered/unregistered\r\n     in HAL_I2C_STATE_READY or HAL_I2C_STATE_RESET state,\r\n     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.\r\n     Then, the user first registers the MspInit/MspDeInit user callbacks\r\n     using HAL_I2C_RegisterCallback() before calling HAL_I2C_DeInit()\r\n     or HAL_I2C_Init() function.\r\n    [..]\r\n     When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or\r\n     not defined, the callback registration feature is not available and all callbacks\r\n     are set to the corresponding weak functions.\r\n\r\n     [..]\r\n       (@) You can refer to the I2C HAL driver header file for more useful macros\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2C I2C\r\n  * @brief I2C HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_I2C_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n\r\n/** @defgroup I2C_Private_Define I2C Private Define\r\n  * @{\r\n  */\r\n#define TIMING_CLEAR_MASK   (0xF0FFFFFFU)  /*!< I2C TIMING clear register Mask */\r\n#define I2C_TIMEOUT_ADDR    (10000U)       /*!< 10 s  */\r\n#define I2C_TIMEOUT_BUSY    (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_DIR     (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_RXNE    (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_STOPF   (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_TC      (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_TCR     (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_TXIS    (25U)          /*!< 25 ms */\r\n#define I2C_TIMEOUT_FLAG    (25U)          /*!< 25 ms */\r\n\r\n#define MAX_NBYTE_SIZE      255U\r\n#define SLAVE_ADDR_SHIFT     7U\r\n#define SLAVE_ADDR_MSK       0x06U\r\n\r\n/* Private define for @ref PreviousState usage */\r\n#define I2C_STATE_MSK             ((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | \\\r\n                                                         (uint32_t)HAL_I2C_STATE_BUSY_RX) & \\\r\n                                              (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY))))\r\n/*!< Mask State define, keep only RX and TX bits */\r\n#define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))\r\n/*!< Default Value */\r\n#define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MASTER))\r\n/*!< Master Busy TX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MASTER))\r\n/*!< Master Busy RX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_SLAVE))\r\n/*!< Slave Busy TX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_SLAVE))\r\n/*!< Slave Busy RX, combinaison of State LSB and Mode enum  */\r\n#define I2C_STATE_MEM_BUSY_TX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MEM))\r\n/*!< Memory Busy TX, combinaison of State LSB and Mode enum */\r\n#define I2C_STATE_MEM_BUSY_RX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | \\\r\n                                              (uint32_t)HAL_I2C_MODE_MEM))\r\n/*!< Memory Busy RX, combinaison of State LSB and Mode enum */\r\n\r\n\r\n/* Private define to centralize the enable/disable of Interrupts */\r\n#define I2C_XFER_TX_IT          (uint16_t)(0x0001U)   /*!< Bit field can be combinated with\r\n                                                         @ref I2C_XFER_LISTEN_IT */\r\n#define I2C_XFER_RX_IT          (uint16_t)(0x0002U)   /*!< Bit field can be combinated with\r\n                                                         @ref I2C_XFER_LISTEN_IT */\r\n#define I2C_XFER_LISTEN_IT      (uint16_t)(0x8000U)   /*!< Bit field can be combinated with @ref I2C_XFER_TX_IT\r\n                                                         and @ref I2C_XFER_RX_IT */\r\n\r\n#define I2C_XFER_ERROR_IT       (uint16_t)(0x0010U)   /*!< Bit definition to manage addition of global Error\r\n                                                         and NACK treatment */\r\n#define I2C_XFER_CPLT_IT        (uint16_t)(0x0020U)   /*!< Bit definition to manage only STOP evenement */\r\n#define I2C_XFER_RELOAD_IT      (uint16_t)(0x0040U)   /*!< Bit definition to manage only Reload of NBYTE */\r\n\r\n/* Private define Sequential Transfer Options default/reset value */\r\n#define I2C_NO_OPTION_FRAME     (0xFFFF0000U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Macro to get remaining data to transfer on DMA side */\r\n#define I2C_GET_DMA_REMAIN_DATA(__HANDLE__)     __HAL_DMA_GET_COUNTER(__HANDLE__)\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/** @defgroup I2C_Private_Functions I2C Private Functions\r\n  * @{\r\n  */\r\n/* Private functions to handle DMA transfer */\r\nstatic void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMAError(DMA_HandleTypeDef *hdma);\r\nstatic void I2C_DMAAbort(DMA_HandleTypeDef *hdma);\r\n\r\n/* Private functions to handle IT transfer */\r\nstatic void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c);\r\nstatic void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c);\r\nstatic void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);\r\nstatic void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode);\r\n\r\n/* Private functions to handle IT transfer */\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                                uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                               uint32_t Tickstart);\r\n\r\n/* Private functions for I2C transfer IRQ handler */\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources);\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                          uint32_t ITSources);\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                            uint32_t ITSources);\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources);\r\n\r\n/* Private functions to handle flags during polling transfer */\r\nstatic HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,\r\n                                                    uint32_t Timeout, uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart);\r\nstatic HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                             uint32_t Tickstart);\r\n\r\n/* Private functions to centralize the enable/disable of Interrupts */\r\nstatic void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);\r\nstatic void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);\r\n\r\n/* Private function to treat different error callback */\r\nstatic void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c);\r\n\r\n/* Private function to flush TXDR register */\r\nstatic void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c);\r\n\r\n/* Private function to handle  start, restart or stop a transfer */\r\nstatic void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,\r\n                               uint32_t Request);\r\n\r\n/* Private function to Convert Specific options */\r\nstatic void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup I2C_Exported_Functions I2C Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]  This subsection provides a set of functions allowing to initialize and\r\n          deinitialize the I2Cx peripheral:\r\n\r\n      (+) User must Implement HAL_I2C_MspInit() function in which he configures\r\n          all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).\r\n\r\n      (+) Call the function HAL_I2C_Init() to configure the selected device with\r\n          the selected configuration:\r\n        (++) Clock Timing\r\n        (++) Own Address 1\r\n        (++) Addressing mode (Master, Slave)\r\n        (++) Dual Addressing mode\r\n        (++) Own Address 2\r\n        (++) Own Address 2 Mask\r\n        (++) General call mode\r\n        (++) Nostretch mode\r\n\r\n      (+) Call the function HAL_I2C_DeInit() to restore the default configuration\r\n          of the selected I2Cx peripheral.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the I2C according to the specified parameters\r\n  *         in the I2C_InitTypeDef and initialize the associated handle.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Check the I2C handle allocation */\r\n  if (hi2c == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));\r\n  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));\r\n  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));\r\n  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));\r\n  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));\r\n  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));\r\n  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    hi2c->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    /* Init the I2C Callback settings */\r\n    hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */\r\n    hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */\r\n    hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */\r\n    hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */\r\n    hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */\r\n    hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */\r\n    hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */\r\n    hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */\r\n    hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */\r\n    hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */\r\n\r\n    if (hi2c->MspInitCallback == NULL)\r\n    {\r\n      hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */\r\n    }\r\n\r\n    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */\r\n    hi2c->MspInitCallback(hi2c);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */\r\n    HAL_I2C_MspInit(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n  /* Disable the selected I2C peripheral */\r\n  __HAL_I2C_DISABLE(hi2c);\r\n\r\n  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/\r\n  /* Configure I2Cx: Frequency range */\r\n  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;\r\n\r\n  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/\r\n  /* Disable Own Address1 before set the Own Address1 configuration */\r\n  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;\r\n\r\n  /* Configure I2Cx: Own Address1 and ack own address1 mode */\r\n  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)\r\n  {\r\n    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);\r\n  }\r\n  else /* I2C_ADDRESSINGMODE_10BIT */\r\n  {\r\n    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);\r\n  }\r\n\r\n  /*---------------------------- I2Cx CR2 Configuration ----------------------*/\r\n  /* Configure I2Cx: Addressing Master mode */\r\n  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)\r\n  {\r\n    hi2c->Instance->CR2 = (I2C_CR2_ADD10);\r\n  }\r\n  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */\r\n  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);\r\n\r\n  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/\r\n  /* Disable Own Address2 before set the Own Address2 configuration */\r\n  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;\r\n\r\n  /* Configure I2Cx: Dual mode and Own Address2 */\r\n  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \\\r\n                          (hi2c->Init.OwnAddress2Masks << 8));\r\n\r\n  /*---------------------------- I2Cx CR1 Configuration ----------------------*/\r\n  /* Configure I2Cx: Generalcall and NoStretch mode */\r\n  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);\r\n\r\n  /* Enable the selected I2C peripheral */\r\n  __HAL_I2C_ENABLE(hi2c);\r\n\r\n  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n  hi2c->State = HAL_I2C_STATE_READY;\r\n  hi2c->PreviousState = I2C_STATE_NONE;\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitialize the I2C peripheral.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Check the I2C handle allocation */\r\n  if (hi2c == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n\r\n  hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n  /* Disable the I2C Peripheral Clock */\r\n  __HAL_I2C_DISABLE(hi2c);\r\n\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n  if (hi2c->MspDeInitCallback == NULL)\r\n  {\r\n    hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */\r\n  }\r\n\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  hi2c->MspDeInitCallback(hi2c);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_I2C_MspDeInit(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n\r\n  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n  hi2c->State = HAL_I2C_STATE_RESET;\r\n  hi2c->PreviousState = I2C_STATE_NONE;\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Initialize the I2C MSP.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief DeInitialize the I2C MSP.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Register a User I2C Callback\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  CallbackID ID of the callback to be registered\r\n  *         This parameter can be one of the following values:\r\n  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID\r\n  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID\r\n  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID\r\n  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID\r\n  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID\r\n  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @param  pCallback pointer to the Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID,\r\n                                           pI2C_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :\r\n        hi2c->MasterTxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :\r\n        hi2c->MasterRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :\r\n        hi2c->SlaveTxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :\r\n        hi2c->SlaveRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_LISTEN_COMPLETE_CB_ID :\r\n        hi2c->ListenCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MEM_TX_COMPLETE_CB_ID :\r\n        hi2c->MemTxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MEM_RX_COMPLETE_CB_ID :\r\n        hi2c->MemRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_ERROR_CB_ID :\r\n        hi2c->ErrorCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_ABORT_CB_ID :\r\n        hi2c->AbortCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_I2C_STATE_RESET == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister an I2C Callback\r\n  *         I2C callback is redirected to the weak predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  CallbackID ID of the callback to be unregistered\r\n  *         This parameter can be one of the following values:\r\n  *         This parameter can be one of the following values:\r\n  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID\r\n  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID\r\n  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID\r\n  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID\r\n  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID\r\n  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID\r\n  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :\r\n        hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */\r\n        break;\r\n\r\n      case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :\r\n        hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :\r\n        hi2c->SlaveTxCpltCallback = HAL_I2C_SlaveTxCpltCallback;   /* Legacy weak SlaveTxCpltCallback  */\r\n        break;\r\n\r\n      case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :\r\n        hi2c->SlaveRxCpltCallback = HAL_I2C_SlaveRxCpltCallback;   /* Legacy weak SlaveRxCpltCallback  */\r\n        break;\r\n\r\n      case HAL_I2C_LISTEN_COMPLETE_CB_ID :\r\n        hi2c->ListenCpltCallback = HAL_I2C_ListenCpltCallback;     /* Legacy weak ListenCpltCallback   */\r\n        break;\r\n\r\n      case HAL_I2C_MEM_TX_COMPLETE_CB_ID :\r\n        hi2c->MemTxCpltCallback = HAL_I2C_MemTxCpltCallback;       /* Legacy weak MemTxCpltCallback    */\r\n        break;\r\n\r\n      case HAL_I2C_MEM_RX_COMPLETE_CB_ID :\r\n        hi2c->MemRxCpltCallback = HAL_I2C_MemRxCpltCallback;       /* Legacy weak MemRxCpltCallback    */\r\n        break;\r\n\r\n      case HAL_I2C_ERROR_CB_ID :\r\n        hi2c->ErrorCallback = HAL_I2C_ErrorCallback;               /* Legacy weak ErrorCallback        */\r\n        break;\r\n\r\n      case HAL_I2C_ABORT_CB_ID :\r\n        hi2c->AbortCpltCallback = HAL_I2C_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */\r\n        break;\r\n\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_I2C_STATE_RESET == hi2c->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_I2C_MSPINIT_CB_ID :\r\n        hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */\r\n        break;\r\n\r\n      case HAL_I2C_MSPDEINIT_CB_ID :\r\n        hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register the Slave Address Match I2C Callback\r\n  *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pCallback pointer to the Address Match Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    hi2c->AddrCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister the Slave Address Match I2C Callback\r\n  *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if (HAL_I2C_STATE_READY == hi2c->State)\r\n  {\r\n    hi2c->AddrCallback = HAL_I2C_AddrCallback; /* Legacy weak AddrCallback  */\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hi2c);\r\n  return status;\r\n}\r\n\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions\r\n  *  @brief   Data transfers functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to manage the I2C data\r\n    transfers.\r\n\r\n    (#) There are two modes of transfer:\r\n       (++) Blocking mode : The communication is performed in the polling mode.\r\n            The status of all data processing is returned by the same function\r\n            after finishing transfer.\r\n       (++) No-Blocking mode : The communication is performed using Interrupts\r\n            or DMA. These functions return the status of the transfer startup.\r\n            The end of the data processing will be indicated through the\r\n            dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when\r\n            using DMA mode.\r\n\r\n    (#) Blocking mode functions are :\r\n        (++) HAL_I2C_Master_Transmit()\r\n        (++) HAL_I2C_Master_Receive()\r\n        (++) HAL_I2C_Slave_Transmit()\r\n        (++) HAL_I2C_Slave_Receive()\r\n        (++) HAL_I2C_Mem_Write()\r\n        (++) HAL_I2C_Mem_Read()\r\n        (++) HAL_I2C_IsDeviceReady()\r\n\r\n    (#) No-Blocking mode functions with Interrupt are :\r\n        (++) HAL_I2C_Master_Transmit_IT()\r\n        (++) HAL_I2C_Master_Receive_IT()\r\n        (++) HAL_I2C_Slave_Transmit_IT()\r\n        (++) HAL_I2C_Slave_Receive_IT()\r\n        (++) HAL_I2C_Mem_Write_IT()\r\n        (++) HAL_I2C_Mem_Read_IT()\r\n        (++) HAL_I2C_Master_Seq_Transmit_IT()\r\n        (++) HAL_I2C_Master_Seq_Receive_IT()\r\n        (++) HAL_I2C_Slave_Seq_Transmit_IT()\r\n        (++) HAL_I2C_Slave_Seq_Receive_IT()\r\n        (++) HAL_I2C_EnableListen_IT()\r\n        (++) HAL_I2C_DisableListen_IT()\r\n        (++) HAL_I2C_Master_Abort_IT()\r\n\r\n    (#) No-Blocking mode functions with DMA are :\r\n        (++) HAL_I2C_Master_Transmit_DMA()\r\n        (++) HAL_I2C_Master_Receive_DMA()\r\n        (++) HAL_I2C_Slave_Transmit_DMA()\r\n        (++) HAL_I2C_Slave_Receive_DMA()\r\n        (++) HAL_I2C_Mem_Write_DMA()\r\n        (++) HAL_I2C_Mem_Read_DMA()\r\n        (++) HAL_I2C_Master_Seq_Transmit_DMA()\r\n        (++) HAL_I2C_Master_Seq_Receive_DMA()\r\n        (++) HAL_I2C_Slave_Seq_Transmit_DMA()\r\n        (++) HAL_I2C_Slave_Seq_Receive_DMA()\r\n\r\n    (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:\r\n        (++) HAL_I2C_MasterTxCpltCallback()\r\n        (++) HAL_I2C_MasterRxCpltCallback()\r\n        (++) HAL_I2C_SlaveTxCpltCallback()\r\n        (++) HAL_I2C_SlaveRxCpltCallback()\r\n        (++) HAL_I2C_MemTxCpltCallback()\r\n        (++) HAL_I2C_MemRxCpltCallback()\r\n        (++) HAL_I2C_AddrCallback()\r\n        (++) HAL_I2C_ListenCpltCallback()\r\n        (++) HAL_I2C_ErrorCallback()\r\n        (++) HAL_I2C_AbortCpltCallback()\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Transmits in master mode an amount of data in blocking mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                          uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until TXIS flag is set */\r\n      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receives in master mode an amount of data in blocking mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                         uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until RXNE flag is set */\r\n      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    }\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmits in slave mode an amount of data in blocking mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                         uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Wait until ADDR flag is set */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear ADDR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n    /* If 10bit addressing mode is selected */\r\n    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)\r\n    {\r\n      /* Wait until ADDR flag is set */\r\n      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        /* Disable Address Acknowledge */\r\n        hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Clear ADDR flag */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Wait until DIR flag is set Transmitter mode */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until TXIS flag is set */\r\n      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        /* Disable Address Acknowledge */\r\n        hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n    }\r\n\r\n    /* Wait until AF flag is set */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n\r\n    /* Clear AF flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Wait until STOP flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Wait until BUSY flag is reset */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Address Acknowledge */\r\n    hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in slave mode an amount of data in blocking mode\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                        uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferSize = hi2c->XferCount;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Wait until ADDR flag is set */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear ADDR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n    /* Wait until DIR flag is reset Receiver mode */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    while (hi2c->XferCount > 0U)\r\n    {\r\n      /* Wait until RXNE flag is set */\r\n      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        /* Disable Address Acknowledge */\r\n        hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n        /* Store Last receive data if any */\r\n        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)\r\n        {\r\n          /* Read data from RXDR */\r\n          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n          /* Increment Buffer pointer */\r\n          hi2c->pBuffPtr++;\r\n\r\n          hi2c->XferCount--;\r\n          hi2c->XferSize--;\r\n        }\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n    }\r\n\r\n    /* Wait until STOP flag is set */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Wait until BUSY flag is reset */\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Disable Address Acknowledge */\r\n      hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Address Acknowledge */\r\n    hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                             uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                            uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, RXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, RXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                              uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmatx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream or channel depends on Instance */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address */\r\n        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to write and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in master mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                             uint16_t Size)\r\n{\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmarx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream or channel depends on Instance */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address */\r\n        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to read and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream or channel depends on Instance */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Enable Address Acknowledge */\r\n      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, STOP, NACK, ADDR interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream or channel depends on Instance */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Enable Address Acknowledge */\r\n      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, STOP, NACK, ADDR interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @brief  Write an amount of data in blocking mode to a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);\r\n    }\r\n\r\n    do\r\n    {\r\n      /* Wait until TXIS flag is set */\r\n      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n\r\n    } while (hi2c->XferCount > 0U);\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is reset */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Read an amount of data in blocking mode from a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr  = pData;\r\n    hi2c->XferCount = Size;\r\n    hi2c->XferISR   = NULL;\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Send Slave Address */\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n    }\r\n\r\n    do\r\n    {\r\n      /* Wait until RXNE flag is set */\r\n      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n\r\n      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n      {\r\n        /* Wait until TCR flag is set */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n        {\r\n          hi2c->XferSize = MAX_NBYTE_SIZE;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          hi2c->XferSize = hi2c->XferCount;\r\n          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                             I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    } while (hi2c->XferCount > 0U);\r\n\r\n    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n    /* Wait until STOPF flag is reset */\r\n    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Clear STOP Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart)\r\n        != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                      uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n\r\n    /* Enable ERR, TC, STOP, NACK, RXI interrupt */\r\n    /* possible to enable all of these */\r\n    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                        uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart)\r\n        != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream or channel depends on Instance */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);\r\n\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR and NACK interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be read\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\r\n                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t xfermode;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Init tickstart for timeout management*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    hi2c->State       = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode        = HAL_I2C_MODE_MEM;\r\n    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = I2C_AUTOEND_MODE;\r\n    }\r\n\r\n    /* Send Slave Address and Memory Address */\r\n    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)\r\n    {\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream or channel depends on Instance */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);\r\n\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR and NACK interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n      /* Enable DMA Request */\r\n      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_READY;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Checks if target device is ready for communication.\r\n  * @note   This function is used with Memory devices\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  Trials Number of trials\r\n  * @param  Timeout Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials,\r\n                                        uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  __IO uint32_t I2C_Trials = 0UL;\r\n\r\n  FlagStatus tmp1;\r\n  FlagStatus tmp2;\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    do\r\n    {\r\n      /* Generate Start */\r\n      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);\r\n\r\n      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */\r\n      /* Wait until STOPF flag is set or a NACK flag is set*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);\r\n      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n      while ((tmp1 == RESET) && (tmp2 == RESET))\r\n      {\r\n        if (Timeout != HAL_MAX_DELAY)\r\n        {\r\n          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n          {\r\n            /* Update I2C state */\r\n            hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n            /* Update I2C error code */\r\n            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n\r\n            /* Process Unlocked */\r\n            __HAL_UNLOCK(hi2c);\r\n\r\n            return HAL_ERROR;\r\n          }\r\n        }\r\n\r\n        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);\r\n        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);\r\n      }\r\n\r\n      /* Check if the NACKF flag has not been set */\r\n      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)\r\n      {\r\n        /* Wait until STOPF flag is reset */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        /* Clear STOP Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n        /* Device is ready */\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_OK;\r\n      }\r\n      else\r\n      {\r\n        /* Wait until STOPF flag is reset */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n        /* Clear STOP Flag, auto generated with autoend*/\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n      }\r\n\r\n      /* Check if the maximum allowed number of trials has been reached */\r\n      if (I2C_Trials == Trials)\r\n      {\r\n        /* Generate Stop */\r\n        hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n\r\n        /* Wait until STOPF flag is reset */\r\n        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n\r\n        /* Clear STOP Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n      }\r\n\r\n      /* Increment Trials */\r\n      I2C_Trials++;\r\n    } while (I2C_Trials < Trials);\r\n\r\n    /* Update I2C state */\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Update I2C error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                 uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_WRITE;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    /* Send Slave Address and set NBYTES to write */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                  uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_WRITE;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmatx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream or channel depends on Instance */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address and set NBYTES to write */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to write and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_WRITE);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_READ;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_IT;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    /* Send Slave Address and set NBYTES to read */\r\n    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with DMA\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\r\n                                                 uint16_t Size, uint32_t XferOptions)\r\n{\r\n  uint32_t xfermode;\r\n  uint32_t xferrequest = I2C_GENERATE_START_READ;\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX;\r\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Master_ISR_DMA;\r\n\r\n    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n      xfermode = I2C_RELOAD_MODE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n      xfermode = hi2c->XferOptions;\r\n    }\r\n\r\n    /* If transfer direction not change and there is no request to start another frame,\r\n       do not generate Restart Condition */\r\n    /* Mean Previous state is same as current state */\r\n    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \\\r\n        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))\r\n    {\r\n      xferrequest = I2C_NO_STARTSTOP;\r\n    }\r\n    else\r\n    {\r\n      /* Convert OTHER_xxx XferOptions if any */\r\n      I2C_ConvertOtherXferOptions(hi2c);\r\n\r\n      /* Update xfermode accordingly if no reload is necessary */\r\n      if (hi2c->XferCount <= MAX_NBYTE_SIZE)\r\n      {\r\n        xfermode = hi2c->XferOptions;\r\n      }\r\n    }\r\n\r\n    if (hi2c->XferSize > 0U)\r\n    {\r\n      if (hi2c->hdmarx != NULL)\r\n      {\r\n        /* Set the I2C DMA transfer complete callback */\r\n        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;\r\n\r\n        /* Set the DMA error callback */\r\n        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n        /* Set the unused DMA callbacks to NULL */\r\n        hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n        hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n        /* Enable the DMA stream or channel depends on Instance */\r\n        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,\r\n                                         hi2c->XferSize);\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      if (dmaxferstatus == HAL_OK)\r\n      {\r\n        /* Send Slave Address and set NBYTES to read */\r\n        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);\r\n\r\n        /* Update XferCount value */\r\n        hi2c->XferCount -= hi2c->XferSize;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                  to avoid the risk of I2C interrupt handle execution before current\r\n                  process unlock */\r\n        /* Enable ERR and NACK interrupts */\r\n        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);\r\n\r\n        /* Enable DMA Request */\r\n        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        /* Update I2C state */\r\n        hi2c->State     = HAL_I2C_STATE_READY;\r\n        hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n        /* Update I2C error code */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Update Transfer ISR function pointer */\r\n      hi2c->XferISR = I2C_Master_ISR_IT;\r\n\r\n      /* Send Slave Address */\r\n      /* Set NBYTES to read and generate START condition */\r\n      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,\r\n                         I2C_GENERATE_START_READ);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Note : The I2C interrupts must be enabled after unlocking current process\r\n                to avoid the risk of I2C interrupt handle execution before current\r\n                process unlock */\r\n      /* Enable ERR, TC, STOP, NACK, TXI interrupt */\r\n      /* possible to enable all of these */\r\n      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |\r\n        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with Interrupt\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                                uint32_t XferOptions)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave RX state to TX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n      /* Abort DMA Xfer if any */\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n        if (hi2c->hdmarx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA RX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* REnable ADDR interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with DMA\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                                 uint32_t XferOptions)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave RX state to TX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n      {\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmarx != NULL)\r\n        {\r\n          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA RX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n    {\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmatx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA TX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Nothing to do */\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmatx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream or channel depends on Instance */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,\r\n                                       hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Reset XferSize */\r\n      hi2c->XferSize = 0;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Enable DMA Request */\r\n    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* Enable ERR, STOP, NACK, ADDR interrupts */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with Interrupt\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                               uint32_t XferOptions)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave TX state to RX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmatx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA TX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_IT;\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* REnable ADDR interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with DMA\r\n  * @note   This interface allow to manage repeated start condition when a direction change during transfer\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  pData Pointer to data buffer\r\n  * @param  Size Amount of data to be sent\r\n  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,\r\n                                                uint32_t XferOptions)\r\n{\r\n  HAL_StatusTypeDef dmaxferstatus;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));\r\n\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);\r\n\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */\r\n    /* and then toggle the HAL slave TX state to RX state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n    {\r\n      /* Disable associated Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n      {\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmatx != NULL)\r\n        {\r\n          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA TX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n    {\r\n      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n      {\r\n        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n        /* Abort DMA Xfer if any */\r\n        if (hi2c->hdmarx != NULL)\r\n        {\r\n          /* Set the I2C DMA Abort callback :\r\n           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n          /* Abort DMA RX */\r\n          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n          {\r\n            /* Call Directly XferAbortCallback function in case of error */\r\n            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Nothing to do */\r\n    }\r\n\r\n    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;\r\n    hi2c->Mode      = HAL_I2C_MODE_SLAVE;\r\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n\r\n    /* Enable Address Acknowledge */\r\n    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;\r\n\r\n    /* Prepare transfer parameters */\r\n    hi2c->pBuffPtr    = pData;\r\n    hi2c->XferCount   = Size;\r\n    hi2c->XferSize    = hi2c->XferCount;\r\n    hi2c->XferOptions = XferOptions;\r\n    hi2c->XferISR     = I2C_Slave_ISR_DMA;\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      /* Set the I2C DMA transfer complete callback */\r\n      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;\r\n\r\n      /* Set the unused DMA callbacks to NULL */\r\n      hi2c->hdmarx->XferHalfCpltCallback = NULL;\r\n      hi2c->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the DMA stream or channel depends on Instance */\r\n      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR,\r\n                                       (uint32_t)pData, hi2c->XferSize);\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (dmaxferstatus == HAL_OK)\r\n    {\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Reset XferSize */\r\n      hi2c->XferSize = 0;\r\n    }\r\n    else\r\n    {\r\n      /* Update I2C state */\r\n      hi2c->State     = HAL_I2C_STATE_LISTEN;\r\n      hi2c->Mode      = HAL_I2C_MODE_NONE;\r\n\r\n      /* Update I2C error code */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)\r\n    {\r\n      /* Clear ADDR flag after prepare the transfer parameters */\r\n      /* This action will generate an acknowledge to the Master */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n    }\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Enable DMA Request */\r\n    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n    to avoid the risk of I2C interrupt handle execution before current\r\n    process unlock */\r\n    /* REnable ADDR interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enable the Address listen mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_LISTEN;\r\n    hi2c->XferISR = I2C_Slave_ISR_IT;\r\n\r\n    /* Enable the Address Match interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Disable the Address listen mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Declaration of tmp to prevent undefined behavior of volatile usage */\r\n  uint32_t tmp;\r\n\r\n  /* Disable Address listen mode only if a transfer is not ongoing */\r\n  if (hi2c->State == HAL_I2C_STATE_LISTEN)\r\n  {\r\n    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;\r\n    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode = HAL_I2C_MODE_NONE;\r\n    hi2c->XferISR = NULL;\r\n\r\n    /* Disable the Address Match interrupt */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Abort a master I2C IT or DMA process communication with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)\r\n{\r\n  if (hi2c->Mode == HAL_I2C_MODE_MASTER)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    /* Disable Interrupts and Store Previous state */\r\n    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n    {\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;\r\n    }\r\n    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n    {\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;\r\n    }\r\n    else\r\n    {\r\n      /* Do nothing */\r\n    }\r\n\r\n    /* Set State at HAL_I2C_STATE_ABORT */\r\n    hi2c->State = HAL_I2C_STATE_ABORT;\r\n\r\n    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */\r\n    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */\r\n    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Note : The I2C interrupts must be enabled after unlocking current process\r\n              to avoid the risk of I2C interrupt handle execution before current\r\n              process unlock */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    /* Wrong usage of abort function */\r\n    /* This function should be used only in case of abort monitored by master device */\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function handles I2C event interrupt request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Get current IT Flags and IT sources value */\r\n  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);\r\n  uint32_t itsources = READ_REG(hi2c->Instance->CR1);\r\n\r\n  /* I2C events treatment -------------------------------------*/\r\n  if (hi2c->XferISR != NULL)\r\n  {\r\n    hi2c->XferISR(hi2c, itflags, itsources);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C error interrupt request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)\r\n{\r\n  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);\r\n  uint32_t itsources = READ_REG(hi2c->Instance->CR1);\r\n  uint32_t tmperror;\r\n\r\n  /* I2C Bus error interrupt occurred ------------------------------------*/\r\n  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))\r\n  {\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;\r\n\r\n    /* Clear BERR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);\r\n  }\r\n\r\n  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/\r\n  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))\r\n  {\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;\r\n\r\n    /* Clear OVR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);\r\n  }\r\n\r\n  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/\r\n  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))\r\n  {\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;\r\n\r\n    /* Clear ARLO flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);\r\n  }\r\n\r\n  /* Store current volatile hi2c->ErrorCode, misra rule */\r\n  tmperror = hi2c->ErrorCode;\r\n\r\n  /* Call the Error Callback in case of Error detected */\r\n  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)\r\n  {\r\n    I2C_ITError(hi2c, tmperror);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Master Tx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Master Rx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/** @brief  Slave Tx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Slave Rx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Slave Address Match callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION\r\n  * @param  AddrMatchCode Address Match Code\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n  UNUSED(TransferDirection);\r\n  UNUSED(AddrMatchCode);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_AddrCallback() could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Listen Complete callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_ListenCpltCallback() could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Memory Tx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MemTxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Memory Rx Transfer completed callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_MemRxCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  I2C error callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_ErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  I2C abort callback.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval None\r\n  */\r\n__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hi2c);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_I2C_AbortCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions\r\n  *  @brief   Peripheral State, Mode and Error functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n            ##### Peripheral State, Mode and Error functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection permit to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the I2C handle state.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @retval HAL state\r\n  */\r\nHAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Return I2C handle state */\r\n  return hi2c->State;\r\n}\r\n\r\n/**\r\n  * @brief  Returns the I2C Master, Slave, Memory or no mode.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *         the configuration information for I2C module\r\n  * @retval HAL mode\r\n  */\r\nHAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)\r\n{\r\n  return hi2c->Mode;\r\n}\r\n\r\n/**\r\n  * @brief  Return the I2C error code.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *              the configuration information for the specified I2C.\r\n  * @retval I2C Error Code\r\n  */\r\nuint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)\r\n{\r\n  return hi2c->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup I2C_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources)\r\n{\r\n  uint16_t devaddress;\r\n  uint32_t tmpITFlags = ITFlags;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Clear NACK Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Set corresponding Error Code */\r\n    /* No need to generate STOP, it is automatically done */\r\n    /* Error callback will be send during stop flag treatment */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))\r\n  {\r\n    /* Remove RXNE flag on temporary variable as read done */\r\n    tmpITFlags &= ~I2C_FLAG_RXNE;\r\n\r\n    /* Read data from RXDR */\r\n    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    hi2c->XferSize--;\r\n    hi2c->XferCount--;\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))\r\n  {\r\n    /* Write data to TXDR */\r\n    hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    hi2c->XferSize--;\r\n    hi2c->XferCount--;\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))\r\n    {\r\n      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);\r\n\r\n      if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n      {\r\n        hi2c->XferSize = MAX_NBYTE_SIZE;\r\n        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);\r\n      }\r\n      else\r\n      {\r\n        hi2c->XferSize = hi2c->XferCount;\r\n        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)\r\n        {\r\n          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,\r\n                             hi2c->XferOptions, I2C_NO_STARTSTOP);\r\n        }\r\n        else\r\n        {\r\n          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,\r\n                             I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Call TxCpltCallback() if no stop mode is set */\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Call I2C Master Sequential complete process */\r\n        I2C_ITMasterSeqCplt(hi2c);\r\n      }\r\n      else\r\n      {\r\n        /* Wrong size Status regarding TCR flag event */\r\n        /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n      }\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    if (hi2c->XferCount == 0U)\r\n    {\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Generate a stop condition in case of no transfer option */\r\n        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)\r\n        {\r\n          /* Generate Stop */\r\n          hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n        }\r\n        else\r\n        {\r\n          /* Call I2C Master Sequential complete process */\r\n          I2C_ITMasterSeqCplt(hi2c);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Wrong size Status regarding TC flag event */\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Master complete process */\r\n    I2C_ITMasterCplt(hi2c, tmpITFlags);\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with Interrupt.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                          uint32_t ITSources)\r\n{\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n  uint32_t tmpITFlags = ITFlags;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  /* Check if STOPF is set */\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Slave complete process */\r\n    I2C_ITSlaveCplt(hi2c, tmpITFlags);\r\n  }\r\n\r\n  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Check that I2C transfer finished */\r\n    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */\r\n    /* Mean XferCount == 0*/\r\n    /* So clear Flag NACKF only */\r\n    if (hi2c->XferCount == 0U)\r\n    {\r\n      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))\r\n        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for\r\n           Warning[Pa134]: left and right operands are identical */\r\n      {\r\n        /* Call I2C Listen complete process */\r\n        I2C_ITListenCplt(hi2c, tmpITFlags);\r\n      }\r\n      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))\r\n      {\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n        /* Flush TX register */\r\n        I2C_Flush_TXDR(hi2c);\r\n\r\n        /* Last Byte is Transmitted */\r\n        /* Call I2C Slave Sequential complete process */\r\n        I2C_ITSlaveSeqCplt(hi2c);\r\n      }\r\n      else\r\n      {\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/\r\n      /* Clear NACK Flag */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n      /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))\r\n      {\r\n        /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n        I2C_ITError(hi2c, hi2c->ErrorCode);\r\n      }\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))\r\n  {\r\n    if (hi2c->XferCount > 0U)\r\n    {\r\n      /* Read data from RXDR */\r\n      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n    }\r\n\r\n    if ((hi2c->XferCount == 0U) && \\\r\n        (tmpoptions != I2C_NO_OPTION_FRAME))\r\n    {\r\n      /* Call I2C Slave Sequential complete process */\r\n      I2C_ITSlaveSeqCplt(hi2c);\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))\r\n  {\r\n    I2C_ITAddrCplt(hi2c, tmpITFlags);\r\n  }\r\n  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))\r\n  {\r\n    /* Write data to TXDR only if XferCount not reach \"0\" */\r\n    /* A TXIS flag can be set, during STOP treatment      */\r\n    /* Check if all Data have already been sent */\r\n    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */\r\n    if (hi2c->XferCount > 0U)\r\n    {\r\n      /* Write data to TXDR */\r\n      hi2c->Instance->TXDR = *hi2c->pBuffPtr;\r\n\r\n      /* Increment Buffer pointer */\r\n      hi2c->pBuffPtr++;\r\n\r\n      hi2c->XferCount--;\r\n      hi2c->XferSize--;\r\n    }\r\n    else\r\n    {\r\n      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))\r\n      {\r\n        /* Last Byte is Transmitted */\r\n        /* Call I2C Slave Sequential complete process */\r\n        I2C_ITSlaveSeqCplt(hi2c);\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with DMA.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                            uint32_t ITSources)\r\n{\r\n  uint16_t devaddress;\r\n  uint32_t xfermode;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Clear NACK Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Set corresponding Error Code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n    /* No need to generate STOP, it is automatically done */\r\n    /* But enable STOP interrupt, to treat it */\r\n    /* Error callback will be send during stop flag treatment */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    /* Disable TC interrupt */\r\n    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);\r\n\r\n    if (hi2c->XferCount != 0U)\r\n    {\r\n      /* Recover Slave address */\r\n      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);\r\n\r\n      /* Prepare the new XferSize to transfer */\r\n      if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n      {\r\n        hi2c->XferSize = MAX_NBYTE_SIZE;\r\n        xfermode = I2C_RELOAD_MODE;\r\n      }\r\n      else\r\n      {\r\n        hi2c->XferSize = hi2c->XferCount;\r\n        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)\r\n        {\r\n          xfermode = hi2c->XferOptions;\r\n        }\r\n        else\r\n        {\r\n          xfermode = I2C_AUTOEND_MODE;\r\n        }\r\n      }\r\n\r\n      /* Set the new XferSize in Nbytes register */\r\n      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);\r\n\r\n      /* Update XferCount value */\r\n      hi2c->XferCount -= hi2c->XferSize;\r\n\r\n      /* Enable DMA Request */\r\n      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n      {\r\n        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;\r\n      }\r\n      else\r\n      {\r\n        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Call TxCpltCallback() if no stop mode is set */\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Call I2C Master Sequential complete process */\r\n        I2C_ITMasterSeqCplt(hi2c);\r\n      }\r\n      else\r\n      {\r\n        /* Wrong size Status regarding TCR flag event */\r\n        /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n      }\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))\r\n  {\r\n    if (hi2c->XferCount == 0U)\r\n    {\r\n      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)\r\n      {\r\n        /* Generate a stop condition in case of no transfer option */\r\n        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)\r\n        {\r\n          /* Generate Stop */\r\n          hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n        }\r\n        else\r\n        {\r\n          /* Call I2C Master Sequential complete process */\r\n          I2C_ITMasterSeqCplt(hi2c);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Wrong size Status regarding TC flag event */\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Master complete process */\r\n    I2C_ITMasterCplt(hi2c, ITFlags);\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with DMA.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @param  ITSources Interrupt sources enabled.\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,\r\n                                           uint32_t ITSources)\r\n{\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n  uint32_t treatdmanack = 0U;\r\n  HAL_I2C_StateTypeDef tmpstate;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hi2c);\r\n\r\n  /* Check if STOPF is set */\r\n  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))\r\n  {\r\n    /* Call I2C Slave complete process */\r\n    I2C_ITSlaveCplt(hi2c, ITFlags);\r\n  }\r\n\r\n  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \\\r\n      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))\r\n  {\r\n    /* Check that I2C transfer finished */\r\n    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */\r\n    /* Mean XferCount == 0 */\r\n    /* So clear Flag NACKF only */\r\n    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||\r\n        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))\r\n    {\r\n      /* Split check of hdmarx, for MISRA compliance */\r\n      if (hi2c->hdmarx != NULL)\r\n      {\r\n        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)\r\n        {\r\n          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)\r\n          {\r\n            treatdmanack = 1U;\r\n          }\r\n        }\r\n      }\r\n\r\n      /* Split check of hdmatx, for MISRA compliance  */\r\n      if (hi2c->hdmatx != NULL)\r\n      {\r\n        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)\r\n        {\r\n          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)\r\n          {\r\n            treatdmanack = 1U;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (treatdmanack == 1U)\r\n      {\r\n        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))\r\n          /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for\r\n             Warning[Pa134]: left and right operands are identical */\r\n        {\r\n          /* Call I2C Listen complete process */\r\n          I2C_ITListenCplt(hi2c, ITFlags);\r\n        }\r\n        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))\r\n        {\r\n          /* Clear NACK Flag */\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n          /* Flush TX register */\r\n          I2C_Flush_TXDR(hi2c);\r\n\r\n          /* Last Byte is Transmitted */\r\n          /* Call I2C Slave Sequential complete process */\r\n          I2C_ITSlaveSeqCplt(hi2c);\r\n        }\r\n        else\r\n        {\r\n          /* Clear NACK Flag */\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/\r\n        /* Clear NACK Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n        /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n\r\n        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */\r\n        tmpstate = hi2c->State;\r\n\r\n        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))\r\n        {\r\n          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))\r\n          {\r\n            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;\r\n          }\r\n          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))\r\n          {\r\n            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;\r\n          }\r\n          else\r\n          {\r\n            /* Do nothing */\r\n          }\r\n\r\n          /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n          I2C_ITError(hi2c, hi2c->ErrorCode);\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Only Clear NACK Flag, no DMA treatment is pending */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n    }\r\n  }\r\n  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \\\r\n           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))\r\n  {\r\n    I2C_ITAddrCplt(hi2c, ITFlags);\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Master sends target device address followed by internal memory address for write request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                                uint32_t Tickstart)\r\n{\r\n  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);\r\n\r\n  /* Wait until TXIS flag is set */\r\n  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* If Memory address size is 8Bit */\r\n  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)\r\n  {\r\n    /* Send Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n  /* If Memory address size is 16Bit */\r\n  else\r\n  {\r\n    /* Send MSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);\r\n\r\n    /* Wait until TXIS flag is set */\r\n    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Send LSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n\r\n  /* Wait until TCR flag is set */\r\n  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Master sends target device address followed by internal memory address for read request.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  DevAddress Target device address: The device 7 bits address value\r\n  *         in datasheet must be shifted to the left before calling the interface\r\n  * @param  MemAddress Internal memory address\r\n  * @param  MemAddSize Size of internal memory address\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,\r\n                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,\r\n                                               uint32_t Tickstart)\r\n{\r\n  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);\r\n\r\n  /* Wait until TXIS flag is set */\r\n  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* If Memory address size is 8Bit */\r\n  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)\r\n  {\r\n    /* Send Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n  /* If Memory address size is 16Bit */\r\n  else\r\n  {\r\n    /* Send MSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);\r\n\r\n    /* Wait until TXIS flag is set */\r\n    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Send LSB of Memory Address */\r\n    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);\r\n  }\r\n\r\n  /* Wait until TC flag is set */\r\n  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  I2C Address complete process callback.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  uint8_t transferdirection;\r\n  uint16_t slaveaddrcode;\r\n  uint16_t ownadd1code;\r\n  uint16_t ownadd2code;\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(ITFlags);\r\n\r\n  /* In case of Listen state, need to inform upper layer of address match code event */\r\n  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)\r\n  {\r\n    transferdirection = I2C_GET_DIR(hi2c);\r\n    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);\r\n    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);\r\n    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);\r\n\r\n    /* If 10bits addressing mode is selected */\r\n    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)\r\n    {\r\n      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))\r\n      {\r\n        slaveaddrcode = ownadd1code;\r\n        hi2c->AddrEventCount++;\r\n        if (hi2c->AddrEventCount == 2U)\r\n        {\r\n          /* Reset Address Event counter */\r\n          hi2c->AddrEventCount = 0U;\r\n\r\n          /* Clear ADDR flag */\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(hi2c);\r\n\r\n          /* Call Slave Addr callback */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#else\r\n          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n      else\r\n      {\r\n        slaveaddrcode = ownadd2code;\r\n\r\n        /* Disable ADDR Interrupts */\r\n        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        /* Call Slave Addr callback */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n        hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#else\r\n        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n    /* else 7 bits addressing mode is selected */\r\n    else\r\n    {\r\n      /* Disable ADDR Interrupts */\r\n      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call Slave Addr callback */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#else\r\n      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* Else clear address flag only */\r\n  else\r\n  {\r\n    /* Clear ADDR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Master sequential complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Reset I2C handle mode */\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  /* No Generate Stop, to permit restart mode */\r\n  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */\r\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n  {\r\n    hi2c->State         = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;\r\n    hi2c->XferISR       = NULL;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->MasterTxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_MasterTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  /* hi2c->State == HAL_I2C_STATE_BUSY_RX */\r\n  else\r\n  {\r\n    hi2c->State         = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;\r\n    hi2c->XferISR       = NULL;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->MasterRxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_MasterRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Slave sequential complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)\r\n{\r\n  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);\r\n\r\n  /* Reset I2C handle mode */\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n  /* If a DMA is ongoing, Update handle size context */\r\n  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n  }\r\n  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)\r\n  {\r\n    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */\r\n    hi2c->State         = HAL_I2C_STATE_LISTEN;\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveTxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)\r\n  {\r\n    /* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN */\r\n    hi2c->State         = HAL_I2C_STATE_LISTEN;\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;\r\n\r\n    /* Disable Interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveRxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Master complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  uint32_t tmperror;\r\n  uint32_t tmpITFlags = ITFlags;\r\n  __IO uint32_t tmpreg;\r\n\r\n  /* Clear STOP Flag */\r\n  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n  /* Disable Interrupts and Store Previous state */\r\n  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;\r\n  }\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);\r\n    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  /* Clear Configuration Register 2 */\r\n  I2C_RESET_CR2(hi2c);\r\n\r\n  /* Reset handle parameters */\r\n  hi2c->XferISR       = NULL;\r\n  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;\r\n\r\n  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)\r\n  {\r\n    /* Clear NACK Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Set acknowledge error code */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n  }\r\n\r\n  /* Fetch Last receive data if any */\r\n  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))\r\n  {\r\n    /* Read data from RXDR */\r\n    tmpreg = (uint8_t)hi2c->Instance->RXDR;\r\n    UNUSED(tmpreg);\r\n  }\r\n\r\n  /* Flush TX register */\r\n  I2C_Flush_TXDR(hi2c);\r\n\r\n  /* Store current volatile hi2c->ErrorCode, misra rule */\r\n  tmperror = hi2c->ErrorCode;\r\n\r\n  /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))\r\n  {\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n    I2C_ITError(hi2c, hi2c->ErrorCode);\r\n  }\r\n  /* hi2c->State == HAL_I2C_STATE_BUSY_TX */\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    if (hi2c->Mode == HAL_I2C_MODE_MEM)\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MemTxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MemTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MasterTxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MasterTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* hi2c->State == HAL_I2C_STATE_BUSY_RX */\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    if (hi2c->Mode == HAL_I2C_MODE_MEM)\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MemRxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MemRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n      hi2c->MasterRxCpltCallback(hi2c);\r\n#else\r\n      HAL_I2C_MasterRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Slave complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);\r\n  uint32_t tmpITFlags = ITFlags;\r\n  HAL_I2C_StateTypeDef tmpstate = hi2c->State;\r\n\r\n  /* Clear STOP Flag */\r\n  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n  /* Disable Interrupts and Store Previous state */\r\n  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;\r\n  }\r\n  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))\r\n  {\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);\r\n    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  /* Disable Address Acknowledge */\r\n  hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n  /* Clear Configuration Register 2 */\r\n  I2C_RESET_CR2(hi2c);\r\n\r\n  /* Flush TX register */\r\n  I2C_Flush_TXDR(hi2c);\r\n\r\n  /* If a DMA is ongoing, Update handle size context */\r\n  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n    if (hi2c->hdmatx != NULL)\r\n    {\r\n      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);\r\n    }\r\n  }\r\n  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n    if (hi2c->hdmarx != NULL)\r\n    {\r\n      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Do nothing */\r\n  }\r\n\r\n  /* Store Last receive data if any */\r\n  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)\r\n  {\r\n    /* Remove RXNE flag on temporary variable as read done */\r\n    tmpITFlags &= ~I2C_FLAG_RXNE;\r\n\r\n    /* Read data from RXDR */\r\n    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    if ((hi2c->XferSize > 0U))\r\n    {\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n    }\r\n  }\r\n\r\n  /* All data are not transferred, so set error code accordingly */\r\n  if (hi2c->XferCount != 0U)\r\n  {\r\n    /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n  }\r\n\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n  hi2c->XferISR = NULL;\r\n\r\n  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)\r\n  {\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n    I2C_ITError(hi2c, hi2c->ErrorCode);\r\n\r\n    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */\r\n    if (hi2c->State == HAL_I2C_STATE_LISTEN)\r\n    {\r\n      /* Call I2C Listen complete process */\r\n      I2C_ITListenCplt(hi2c, tmpITFlags);\r\n    }\r\n  }\r\n  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)\r\n  {\r\n    /* Call the Sequential Complete callback, to inform upper layer of the end of Transfer */\r\n    I2C_ITSlaveSeqCplt(hi2c);\r\n\r\n    hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->ListenCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_ListenCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveRxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveRxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->SlaveTxCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Listen complete process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ITFlags Interrupt flags to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)\r\n{\r\n  /* Reset handle parameters */\r\n  hi2c->XferOptions = I2C_NO_OPTION_FRAME;\r\n  hi2c->PreviousState = I2C_STATE_NONE;\r\n  hi2c->State = HAL_I2C_STATE_READY;\r\n  hi2c->Mode = HAL_I2C_MODE_NONE;\r\n  hi2c->XferISR = NULL;\r\n\r\n  /* Store Last receive data if any */\r\n  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)\r\n  {\r\n    /* Read data from RXDR */\r\n    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;\r\n\r\n    /* Increment Buffer pointer */\r\n    hi2c->pBuffPtr++;\r\n\r\n    if ((hi2c->XferSize > 0U))\r\n    {\r\n      hi2c->XferSize--;\r\n      hi2c->XferCount--;\r\n\r\n      /* Set ErrorCode corresponding to a Non-Acknowledge */\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;\r\n    }\r\n  }\r\n\r\n  /* Disable all Interrupts*/\r\n  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);\r\n\r\n  /* Clear NACK Flag */\r\n  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hi2c);\r\n\r\n  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n  hi2c->ListenCpltCallback(hi2c);\r\n#else\r\n  HAL_I2C_ListenCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  I2C interrupts error process.\r\n  * @param  hi2c I2C handle.\r\n  * @param  ErrorCode Error code to handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)\r\n{\r\n  HAL_I2C_StateTypeDef tmpstate = hi2c->State;\r\n  uint32_t tmppreviousstate;\r\n\r\n  /* Reset handle parameters */\r\n  hi2c->Mode          = HAL_I2C_MODE_NONE;\r\n  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;\r\n  hi2c->XferCount     = 0U;\r\n\r\n  /* Set new error code */\r\n  hi2c->ErrorCode |= ErrorCode;\r\n\r\n  /* Disable Interrupts */\r\n  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||\r\n      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||\r\n      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))\r\n  {\r\n    /* Disable all interrupts, except interrupts related to LISTEN state */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);\r\n\r\n    /* keep HAL_I2C_STATE_LISTEN if set */\r\n    hi2c->State         = HAL_I2C_STATE_LISTEN;\r\n    hi2c->XferISR       = I2C_Slave_ISR_IT;\r\n  }\r\n  else\r\n  {\r\n    /* Disable all interrupts */\r\n    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);\r\n\r\n    /* If state is an abort treatment on going, don't change state */\r\n    /* This change will be do later */\r\n    if (hi2c->State != HAL_I2C_STATE_ABORT)\r\n    {\r\n      /* Set HAL_I2C_STATE_READY */\r\n      hi2c->State         = HAL_I2C_STATE_READY;\r\n    }\r\n    hi2c->XferISR       = NULL;\r\n  }\r\n\r\n  /* Abort DMA TX transfer if any */\r\n  tmppreviousstate = hi2c->PreviousState;\r\n  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \\\r\n                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))\r\n  {\r\n    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)\r\n    {\r\n      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n    }\r\n\r\n    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)\r\n    {\r\n      /* Set the I2C DMA Abort callback :\r\n       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Abort DMA TX */\r\n      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)\r\n      {\r\n        /* Call Directly XferAbortCallback function in case of error */\r\n        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      I2C_TreatErrorCallback(hi2c);\r\n    }\r\n  }\r\n  /* Abort DMA RX transfer if any */\r\n  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \\\r\n                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))\r\n  {\r\n    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)\r\n    {\r\n      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n    }\r\n\r\n    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)\r\n    {\r\n      /* Set the I2C DMA Abort callback :\r\n        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */\r\n      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      /* Abort DMA RX */\r\n      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)\r\n      {\r\n        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */\r\n        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      I2C_TreatErrorCallback(hi2c);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    I2C_TreatErrorCallback(hi2c);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Error callback treatment.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)\r\n{\r\n  if (hi2c->State == HAL_I2C_STATE_ABORT)\r\n  {\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->AbortCpltCallback(hi2c);\r\n#else\r\n    HAL_I2C_AbortCpltCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    hi2c->PreviousState = I2C_STATE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)\r\n    hi2c->ErrorCallback(hi2c);\r\n#else\r\n    HAL_I2C_ErrorCallback(hi2c);\r\n#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  I2C Tx data register flush process.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* If a pending TXIS flag is set */\r\n  /* Write a dummy data in TXDR to clear it */\r\n  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)\r\n  {\r\n    hi2c->Instance->TXDR = 0x00U;\r\n  }\r\n\r\n  /* Flush TX register if not empty */\r\n  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)\r\n  {\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C master transmit process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  /* Disable DMA Request */\r\n  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n  /* If last transfer, enable STOP interrupt */\r\n  if (hi2c->XferCount == 0U)\r\n  {\r\n    /* Enable STOP interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n  }\r\n  /* else prepare a new DMA transfer and enable TCReload interrupt */\r\n  else\r\n  {\r\n    /* Update Buffer pointer */\r\n    hi2c->pBuffPtr += hi2c->XferSize;\r\n\r\n    /* Set the XferSize to transfer */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n    }\r\n\r\n    /* Enable the DMA stream or channel depends on Instance */\r\n    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,\r\n                         hi2c->XferSize) != HAL_OK)\r\n    {\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);\r\n    }\r\n    else\r\n    {\r\n      /* Enable TC interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C slave transmit process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n\r\n  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;\r\n\r\n    /* Last Byte is Transmitted */\r\n    /* Call I2C Slave Sequential complete process */\r\n    I2C_ITSlaveSeqCplt(hi2c);\r\n  }\r\n  else\r\n  {\r\n    /* No specific action, Master fully manage the generation of STOP condition */\r\n    /* Mean that this generation can arrive at any time, at the end or during DMA process */\r\n    /* So STOP condition should be manage through Interrupt treatment */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA I2C master receive process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  /* Disable DMA Request */\r\n  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n  /* If last transfer, enable STOP interrupt */\r\n  if (hi2c->XferCount == 0U)\r\n  {\r\n    /* Enable STOP interrupt */\r\n    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);\r\n  }\r\n  /* else prepare a new DMA transfer and enable TCReload interrupt */\r\n  else\r\n  {\r\n    /* Update Buffer pointer */\r\n    hi2c->pBuffPtr += hi2c->XferSize;\r\n\r\n    /* Set the XferSize to transfer */\r\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\r\n    {\r\n      hi2c->XferSize = MAX_NBYTE_SIZE;\r\n    }\r\n    else\r\n    {\r\n      hi2c->XferSize = hi2c->XferCount;\r\n    }\r\n\r\n    /* Enable the DMA stream or channel depends on Instance */\r\n    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr,\r\n                         hi2c->XferSize) != HAL_OK)\r\n    {\r\n      /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);\r\n    }\r\n    else\r\n    {\r\n      /* Enable TC interrupts */\r\n      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C slave receive process complete callback.\r\n  * @param  hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n  uint32_t tmpoptions = hi2c->XferOptions;\r\n\r\n  if ((I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U) && \\\r\n      (tmpoptions != I2C_NO_OPTION_FRAME))\r\n  {\r\n    /* Disable DMA Request */\r\n    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;\r\n\r\n    /* Call I2C Slave Sequential complete process */\r\n    I2C_ITSlaveSeqCplt(hi2c);\r\n  }\r\n  else\r\n  {\r\n    /* No specific action, Master fully manage the generation of STOP condition */\r\n    /* Mean that this generation can arrive at any time, at the end or during DMA process */\r\n    /* So STOP condition should be manage through Interrupt treatment */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA I2C communication error callback.\r\n  * @param hdma DMA handle\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  uint32_t treatdmaerror = 0U;\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  if (hi2c->hdmatx != NULL)\r\n  {\r\n    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)\r\n    {\r\n      treatdmaerror = 1U;\r\n    }\r\n  }\r\n\r\n  if (hi2c->hdmarx != NULL)\r\n  {\r\n    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)\r\n    {\r\n      treatdmaerror = 1U;\r\n    }\r\n  }\r\n\r\n  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */\r\n  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))\r\n  {\r\n    /* Disable Acknowledge */\r\n    hi2c->Instance->CR2 |= I2C_CR2_NACK;\r\n\r\n    /* Call the corresponding callback to inform upper layer of End of Transfer */\r\n    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA I2C communication abort callback\r\n  *        (To be called at end of DMA Abort procedure).\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_DMAAbort(DMA_HandleTypeDef *hdma)\r\n{\r\n  /* Derogation MISRAC2012-Rule-11.5 */\r\n  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);\r\n\r\n  /* Reset AbortCpltCallback */\r\n  if (hi2c->hdmatx != NULL)\r\n  {\r\n    hi2c->hdmatx->XferAbortCallback = NULL;\r\n  }\r\n  if (hi2c->hdmarx != NULL)\r\n  {\r\n    hi2c->hdmarx->XferAbortCallback = NULL;\r\n  }\r\n\r\n  I2C_TreatErrorCallback(hi2c);\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout. It waits\r\n  *                until a flag is no longer in the specified status.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Flag Specifies the I2C flag to check.\r\n  * @param  Status The actual Flag status (SET or RESET).\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,\r\n                                                    uint32_t Timeout, uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)\r\n  {\r\n    /* Check for the Timeout */\r\n    if (Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n        hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)\r\n  {\r\n    /* Check if an error is detected */\r\n    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if (Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n        hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)\r\n  {\r\n    /* Check if an error is detected */\r\n    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n    {\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n      hi2c->State = HAL_I2C_STATE_READY;\r\n      hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,\r\n                                                        uint32_t Tickstart)\r\n{\r\n  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)\r\n  {\r\n    /* Check if an error is detected */\r\n    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Check if a STOPF is detected */\r\n    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)\r\n    {\r\n      /* Check if an RXNE is pending */\r\n      /* Store Last receive data if any */\r\n      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))\r\n      {\r\n        /* Return HAL_OK */\r\n        /* The Reading of data from RXDR will be done in caller function */\r\n        return HAL_OK;\r\n      }\r\n      else\r\n      {\r\n        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)\r\n        {\r\n          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n          hi2c->ErrorCode = HAL_I2C_ERROR_AF;\r\n        }\r\n        else\r\n        {\r\n          hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\r\n        }\r\n\r\n        /* Clear STOP Flag */\r\n        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n\r\n        /* Clear Configuration Register 2 */\r\n        I2C_RESET_CR2(hi2c);\r\n\r\n        hi2c->State = HAL_I2C_STATE_READY;\r\n        hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hi2c);\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n    {\r\n      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n      hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hi2c);\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles errors detection during an I2C Communication.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  Timeout Timeout duration\r\n  * @param  Tickstart Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t itflag   = hi2c->Instance->ISR;\r\n  uint32_t error_code = 0;\r\n  uint32_t tickstart = Tickstart;\r\n  uint32_t tmp1;\r\n  HAL_I2C_ModeTypeDef tmp2;\r\n\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))\r\n  {\r\n    /* Clear NACKF Flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);\r\n\r\n    /* Wait until STOP Flag is set or timeout occurred */\r\n    /* AutoEnd should be initiate after AF */\r\n    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))\r\n    {\r\n      /* Check for the Timeout */\r\n      if (Timeout != HAL_MAX_DELAY)\r\n      {\r\n        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n        {\r\n          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);\r\n          tmp2 = hi2c->Mode;\r\n\r\n          /* In case of I2C still busy, try to regenerate a STOP manually */\r\n          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \\\r\n              (tmp1 != I2C_CR2_STOP) && \\\r\n              (tmp2 != HAL_I2C_MODE_SLAVE))\r\n          {\r\n            /* Generate Stop */\r\n            hi2c->Instance->CR2 |= I2C_CR2_STOP;\r\n            \r\n            /* Update Tick with new reference */\r\n            tickstart = HAL_GetTick();\r\n          }\r\n          \r\n          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)\r\n          {\r\n            /* Check for the Timeout */\r\n            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)\r\n            {\r\n              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;\r\n              hi2c->State = HAL_I2C_STATE_READY;\r\n              hi2c->Mode = HAL_I2C_MODE_NONE;\r\n              \r\n              /* Process Unlocked */\r\n              __HAL_UNLOCK(hi2c);\r\n              \r\n              status = HAL_ERROR;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* In case STOP Flag is detected, clear it */\r\n    if (status == HAL_OK)\r\n    {\r\n      /* Clear STOP Flag */\r\n      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\r\n    }\r\n\r\n    error_code |= HAL_I2C_ERROR_AF;\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Refresh Content of Status register */\r\n  itflag = hi2c->Instance->ISR;\r\n\r\n  /* Then verify if an additional errors occurs */\r\n  /* Check if a Bus error occurred */\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))\r\n  {\r\n    error_code |= HAL_I2C_ERROR_BERR;\r\n\r\n    /* Clear BERR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Check if an Over-Run/Under-Run error occurred */\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))\r\n  {\r\n    error_code |= HAL_I2C_ERROR_OVR;\r\n\r\n    /* Clear OVR flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Check if an Arbitration Loss error occurred */\r\n  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))\r\n  {\r\n    error_code |= HAL_I2C_ERROR_ARLO;\r\n\r\n    /* Clear ARLO flag */\r\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);\r\n\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  if (status != HAL_OK)\r\n  {\r\n    /* Flush TX register */\r\n    I2C_Flush_TXDR(hi2c);\r\n\r\n    /* Clear Configuration Register 2 */\r\n    I2C_RESET_CR2(hi2c);\r\n\r\n    hi2c->ErrorCode |= error_code;\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n    hi2c->Mode = HAL_I2C_MODE_NONE;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).\r\n  * @param  hi2c I2C handle.\r\n  * @param  DevAddress Specifies the slave address to be programmed.\r\n  * @param  Size Specifies the number of bytes to be programmed.\r\n  *   This parameter must be a value between 0 and 255.\r\n  * @param  Mode New state of the I2C START condition generation.\r\n  *   This parameter can be one of the following values:\r\n  *     @arg @ref I2C_RELOAD_MODE Enable Reload mode .\r\n  *     @arg @ref I2C_AUTOEND_MODE Enable Automatic end mode.\r\n  *     @arg @ref I2C_SOFTEND_MODE Enable Software end mode.\r\n  * @param  Request New state of the I2C START condition generation.\r\n  *   This parameter can be one of the following values:\r\n  *     @arg @ref I2C_NO_STARTSTOP Don't Generate stop and start condition.\r\n  *     @arg @ref I2C_GENERATE_STOP Generate stop condition (Size should be set to 0).\r\n  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.\r\n  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.\r\n  * @retval None\r\n  */\r\nstatic void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,\r\n                               uint32_t Request)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_TRANSFER_MODE(Mode));\r\n  assert_param(IS_TRANSFER_REQUEST(Request));\r\n\r\n  /* Declaration of tmp to prevent undefined behavior of volatile usage */\r\n  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \\\r\n                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \\\r\n                              (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));\r\n\r\n  /* update CR2 register */\r\n  MODIFY_REG(hi2c->Instance->CR2, \\\r\n             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \\\r\n               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \\\r\n                I2C_CR2_START | I2C_CR2_STOP)), tmp);\r\n}\r\n\r\n/**\r\n  * @brief  Manage the enabling of Interrupts.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.\r\n  * @retval None\r\n  */\r\nstatic void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)\r\n{\r\n  uint32_t tmpisr = 0U;\r\n\r\n  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \\\r\n      (hi2c->XferISR == I2C_Slave_ISR_DMA))\r\n  {\r\n    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)\r\n    {\r\n      /* Enable ERR, STOP, NACK and ADDR interrupts */\r\n      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_ERROR_IT)\r\n    {\r\n      /* Enable ERR and NACK interrupts */\r\n      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_CPLT_IT)\r\n    {\r\n      /* Enable STOP interrupts */\r\n      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_RELOAD_IT)\r\n    {\r\n      /* Enable TC interrupts */\r\n      tmpisr |= I2C_IT_TCI;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)\r\n    {\r\n      /* Enable ERR, STOP, NACK, and ADDR interrupts */\r\n      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n\r\n    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)\r\n    {\r\n      /* Enable ERR, TC, STOP, NACK and RXI interrupts */\r\n      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;\r\n    }\r\n\r\n    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)\r\n    {\r\n      /* Enable ERR, TC, STOP, NACK and TXI interrupts */\r\n      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;\r\n    }\r\n\r\n    if (InterruptRequest == I2C_XFER_CPLT_IT)\r\n    {\r\n      /* Enable STOP interrupts */\r\n      tmpisr |= I2C_IT_STOPI;\r\n    }\r\n  }\r\n\r\n  /* Enable interrupts only at the end */\r\n  /* to avoid the risk of I2C interrupt handle execution before */\r\n  /* all interrupts requested done */\r\n  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);\r\n}\r\n\r\n/**\r\n  * @brief  Manage the disabling of Interrupts.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2C.\r\n  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.\r\n  * @retval None\r\n  */\r\nstatic void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)\r\n{\r\n  uint32_t tmpisr = 0U;\r\n\r\n  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)\r\n  {\r\n    /* Disable TC and TXI interrupts */\r\n    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;\r\n\r\n    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)\r\n    {\r\n      /* Disable NACK and STOP interrupts */\r\n      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n  }\r\n\r\n  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)\r\n  {\r\n    /* Disable TC and RXI interrupts */\r\n    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;\r\n\r\n    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)\r\n    {\r\n      /* Disable NACK and STOP interrupts */\r\n      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n    }\r\n  }\r\n\r\n  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)\r\n  {\r\n    /* Disable ADDR, NACK and STOP interrupts */\r\n    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;\r\n  }\r\n\r\n  if (InterruptRequest == I2C_XFER_ERROR_IT)\r\n  {\r\n    /* Enable ERR and NACK interrupts */\r\n    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;\r\n  }\r\n\r\n  if (InterruptRequest == I2C_XFER_CPLT_IT)\r\n  {\r\n    /* Enable STOP interrupts */\r\n    tmpisr |= I2C_IT_STOPI;\r\n  }\r\n\r\n  if (InterruptRequest == I2C_XFER_RELOAD_IT)\r\n  {\r\n    /* Enable TC interrupts */\r\n    tmpisr |= I2C_IT_TCI;\r\n  }\r\n\r\n  /* Disable interrupts only at the end */\r\n  /* to avoid a breaking situation like at \"t\" time */\r\n  /* all disable interrupts request are not done */\r\n  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);\r\n}\r\n\r\n/**\r\n  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.\r\n  * @param  hi2c I2C handle.\r\n  * @retval None\r\n  */\r\nstatic void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* if user set XferOptions to I2C_OTHER_FRAME            */\r\n  /* it request implicitly to generate a restart condition */\r\n  /* set XferOptions to I2C_FIRST_FRAME                    */\r\n  if (hi2c->XferOptions == I2C_OTHER_FRAME)\r\n  {\r\n    hi2c->XferOptions = I2C_FIRST_FRAME;\r\n  }\r\n  /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */\r\n  /* it request implicitly to generate a restart condition    */\r\n  /* then generate a stop condition at the end of transfer    */\r\n  /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */\r\n  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)\r\n  {\r\n    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;\r\n  }\r\n  else\r\n  {\r\n    /* Nothing to do */\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_I2C_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_i2c_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_i2c_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   I2C Extended HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of I2C Extended peripheral:\r\n  *           + Filter Mode Functions\r\n  *           + WakeUp Mode Functions\r\n  *           + FastModePlus Functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n               ##### I2C peripheral Extended features  #####\r\n  ==============================================================================\r\n\r\n  [..] Comparing to other previous devices, the I2C interface for STM32H7xx\r\n       devices contains the following additional features\r\n\r\n       (+) Possibility to disable or enable Analog Noise Filter\r\n       (+) Use of a configured Digital Noise Filter\r\n       (+) Disable or enable wakeup from Stop mode(s)\r\n       (+) Disable or enable Fast Mode Plus\r\n\r\n                     ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..] This driver provides functions to configure Noise Filter and Wake Up Feature\r\n    (#) Configure I2C Analog noise filter using the function HAL_I2CEx_ConfigAnalogFilter()\r\n    (#) Configure I2C Digital noise filter using the function HAL_I2CEx_ConfigDigitalFilter()\r\n    (#) Configure the enable or disable of I2C Wake Up Mode using the functions :\r\n          (++) HAL_I2CEx_EnableWakeUp()\r\n          (++) HAL_I2CEx_DisableWakeUp()\r\n    (#) Configure the enable or disable of fast mode plus driving capability using the functions :\r\n          (++) HAL_I2CEx_EnableFastModePlus()\r\n          (++) HAL_I2CEx_DisableFastModePlus()\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2CEx I2CEx\r\n  * @brief I2C Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_I2C_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup I2CEx_Exported_Functions I2C Extended Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup I2CEx_Exported_Functions_Group1 Filter Mode Functions\r\n  * @brief    Filter Mode Functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Filter Mode Functions #####\r\n ===============================================================================\r\n    [..] This section provides functions allowing to:\r\n      (+) Configure Noise Filters\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configure I2C Analog noise filter.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2Cx peripheral.\r\n  * @param  AnalogFilter New state of the Analog filter.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n    /* Disable the selected I2C peripheral */\r\n    __HAL_I2C_DISABLE(hi2c);\r\n\r\n    /* Reset I2Cx ANOFF bit */\r\n    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);\r\n\r\n    /* Set analog filter bit*/\r\n    hi2c->Instance->CR1 |= AnalogFilter;\r\n\r\n    __HAL_I2C_ENABLE(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure I2C Digital noise filter.\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2Cx peripheral.\r\n  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)\r\n{\r\n  uint32_t tmpreg;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));\r\n  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n    /* Disable the selected I2C peripheral */\r\n    __HAL_I2C_DISABLE(hi2c);\r\n\r\n    /* Get the old register value */\r\n    tmpreg = hi2c->Instance->CR1;\r\n\r\n    /* Reset I2Cx DNF bits [11:8] */\r\n    tmpreg &= ~(I2C_CR1_DNF);\r\n\r\n    /* Set I2Cx DNF coefficient */\r\n    tmpreg |= DigitalFilter << 8U;\r\n\r\n    /* Store the new register value */\r\n    hi2c->Instance->CR1 = tmpreg;\r\n\r\n    __HAL_I2C_ENABLE(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2CEx_Exported_Functions_Group2 WakeUp Mode Functions\r\n  * @brief    WakeUp Mode Functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### WakeUp Mode Functions #####\r\n ===============================================================================\r\n    [..] This section provides functions allowing to:\r\n      (+) Configure Wake Up Feature\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Enable I2C wakeup from Stop mode(s).\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2Cx peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n    /* Disable the selected I2C peripheral */\r\n    __HAL_I2C_DISABLE(hi2c);\r\n\r\n    /* Enable wakeup from stop mode */\r\n    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;\r\n\r\n    __HAL_I2C_ENABLE(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Disable I2C wakeup from Stop mode(s).\r\n  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified I2Cx peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));\r\n\r\n  if (hi2c->State == HAL_I2C_STATE_READY)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_BUSY;\r\n\r\n    /* Disable the selected I2C peripheral */\r\n    __HAL_I2C_DISABLE(hi2c);\r\n\r\n    /* Enable wakeup from stop mode */\r\n    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);\r\n\r\n    __HAL_I2C_ENABLE(hi2c);\r\n\r\n    hi2c->State = HAL_I2C_STATE_READY;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hi2c);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup I2CEx_Exported_Functions_Group3 Fast Mode Plus Functions\r\n  * @brief    Fast Mode Plus Functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Fast Mode Plus Functions #####\r\n ===============================================================================\r\n    [..] This section provides functions allowing to:\r\n      (+) Configure Fast Mode Plus\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Enable the I2C fast mode plus driving capability.\r\n  * @param ConfigFastModePlus Selects the pin.\r\n  *   This parameter can be one of the @ref I2CEx_FastModePlus values\r\n  * @note  For I2C1, fast mode plus driving capability can be enabled on all selected\r\n  *        I2C1 pins using I2C_FASTMODEPLUS_I2C1 parameter or independently\r\n  *        on each one of the following pins PB6, PB7, PB8 and PB9.\r\n  * @note  For remaining I2C1 pins (PA14, PA15...) fast mode plus driving capability\r\n  *        can be enabled only by using I2C_FASTMODEPLUS_I2C1 parameter.\r\n  * @note  For all I2C2 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C2 parameter.\r\n  * @note  For all I2C3 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.\r\n  * @note  For all I2C4 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.\r\n  * @note  For all I2C5 pins fast mode plus driving capability can be enabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C5 parameter.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));\r\n\r\n  /* Enable SYSCFG clock */\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n  /* Enable fast mode plus driving capability for selected pin */\r\n  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);\r\n}\r\n\r\n/**\r\n  * @brief Disable the I2C fast mode plus driving capability.\r\n  * @param ConfigFastModePlus Selects the pin.\r\n  *   This parameter can be one of the @ref I2CEx_FastModePlus values\r\n  * @note  For I2C1, fast mode plus driving capability can be disabled on all selected\r\n  *        I2C1 pins using I2C_FASTMODEPLUS_I2C1 parameter or independently\r\n  *        on each one of the following pins PB6, PB7, PB8 and PB9.\r\n  * @note  For remaining I2C1 pins (PA14, PA15...) fast mode plus driving capability\r\n  *        can be disabled only by using I2C_FASTMODEPLUS_I2C1 parameter.\r\n  * @note  For all I2C2 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C2 parameter.\r\n  * @note  For all I2C3 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.\r\n  * @note  For all I2C4 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.\r\n  * @note  For all I2C5 pins fast mode plus driving capability can be disabled\r\n  *        only by using I2C_FASTMODEPLUS_I2C5 parameter.\r\n  * @retval None\r\n  */\r\nvoid HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));\r\n\r\n  /* Enable SYSCFG clock */\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n  /* Disable fast mode plus driving capability for selected pin */\r\n  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_I2C_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_mdma.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_mdma.c\r\n  * @author  MCD Application Team\r\n  * @brief  This file provides firmware functions to manage the following\r\n  *         functionalities of the Master Direct Memory Access (MDMA) peripheral:\r\n  *           + Initialization/de-initialization functions\r\n  *           + I/O operation functions\r\n  *           + Peripheral State and errors functions\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) Enable and configure the peripheral to be connected to the MDMA Channel\r\n       (except for internal SRAM/FLASH memories: no initialization is\r\n       necessary) please refer to Reference manual for connection between peripherals\r\n       and MDMA requests.\r\n\r\n   (#)\r\n       For a given Channel use HAL_MDMA_Init function to program the required configuration through the following parameters:\r\n       transfer request , channel priority, data endianness, Source increment, destination increment ,\r\n       source data size, destination data size, data alignment, source Burst, destination Burst ,\r\n       buffer Transfer Length, Transfer Trigger Mode (buffer transfer, block transfer, repeated block transfer\r\n       or full transfer) source and destination block address offset, mask address and data.\r\n\r\n       If using the MDMA in linked list mode then use function HAL_MDMA_LinkedList_CreateNode to fill a transfer node.\r\n       Note that parameters given to the function HAL_MDMA_Init corresponds always to the node zero.\r\n       Use function HAL_MDMA_LinkedList_AddNode to connect the created node to the linked list at a given position.\r\n       User can make a linked list circular using function HAL_MDMA_LinkedList_EnableCircularMode , this function will automatically connect the\r\n       last node of the list to the first one in order to make the list circular.\r\n       In this case the linked list will loop on node 1 : first node connected after the initial transfer defined by the HAL_MDMA_Init\r\n\r\n      -@-   The initial transfer itself (node 0 corresponding to the Init).\r\n            User can disable the circular mode using function HAL_MDMA_LinkedList_DisableCircularMode, this function will then remove\r\n            the connection between last node and first one.\r\n\r\n       Function HAL_MDMA_LinkedList_RemoveNode can be used to remove (disconnect) a node from the transfer linked list.\r\n       When a linked list is circular (last node connected to first one), if removing node1  (node where the linked list loops),\r\n       the linked list remains circular and node 2 becomes the first one.\r\n       Note that if the linked list is made circular the transfer will loop infinitely (or until aborted by the user).\r\n\r\n    [..]\r\n       (+) User can select the transfer trigger mode (parameter TransferTriggerMode) to define the amount of data to be\r\n           transfer upon a request :\r\n             (++) MDMA_BUFFER_TRANSFER : each request triggers a transfer of BufferTransferLength data\r\n               with BufferTransferLength defined within the HAL_MDMA_Init.\r\n             (++) MDMA_BLOCK_TRANSFER : each request triggers a transfer of a block\r\n               with block size defined within the function HAL_MDMA_Start/HAL_MDMA_Start_IT\r\n               or within the current linked list node parameters.\r\n             (++) MDMA_REPEAT_BLOCK_TRANSFER : each request triggers a transfer of a number of blocks\r\n               with block size and number of blocks defined within the function HAL_MDMA_Start/HAL_MDMA_Start_IT\r\n               or within the current linked list node parameters.\r\n             (++) MDMA_FULL_TRANSFER : each request triggers a full transfer\r\n              all blocks and all nodes(if a linked list has been created using HAL_MDMA_LinkedList_CreateNode \\ HAL_MDMA_LinkedList_AddNode).\r\n\r\n     *** Polling mode IO operation ***\r\n     =================================\r\n    [..]\r\n          (+) Use HAL_MDMA_Start() to start MDMA transfer after the configuration of Source\r\n              address and destination address and the Length of data to be transferred.\r\n          (+) Use HAL_MDMA_PollForTransfer() to poll for the end of current transfer or a transfer level\r\n             In this case a fixed Timeout can be configured by User depending from his application.\r\n          (+) Use HAL_MDMA_Abort() function to abort the current transfer : blocking method this API returns\r\n              when the abort ends or timeout (should not be called from an interrupt service routine).\r\n\r\n     *** Interrupt mode IO operation ***\r\n     ===================================\r\n    [..]\r\n          (+) Configure the MDMA interrupt priority using HAL_NVIC_SetPriority()\r\n          (+) Enable the MDMA IRQ handler using HAL_NVIC_EnableIRQ()\r\n          (+) Use HAL_MDMA_Start_IT() to start MDMA transfer after the configuration of\r\n              Source address and destination address and the Length of data to be transferred. In this\r\n              case the MDMA interrupt is configured.\r\n          (+) Use HAL_MDMA_IRQHandler() called under MDMA_IRQHandler() Interrupt subroutine\r\n          (+) At the end of data transfer HAL_MDMA_IRQHandler() function is executed and user can\r\n              add his own function by customization of function pointer XferCpltCallback and\r\n              XferErrorCallback (i.e a member of MDMA handle structure).\r\n\r\n          (+) Use HAL_MDMA_Abort_IT() function to abort the current transfer : non-blocking method. This API will finish the execution immediately\r\n              then the callback XferAbortCallback (if specified  by the user) is asserted once the MDMA channel has effectively aborted.\r\n              (could be called from an interrupt service routine).\r\n\r\n          (+) Use functions HAL_MDMA_RegisterCallback and HAL_MDMA_UnRegisterCallback respectevely to register unregister user callbacks\r\n              from the following list :\r\n              (++) XferCpltCallback            : transfer complete callback.\r\n              (++) XferBufferCpltCallback      : buffer transfer complete callback.\r\n              (++) XferBlockCpltCallback       : block transfer complete callback.\r\n              (++) XferRepeatBlockCpltCallback : repeated block transfer complete callback.\r\n              (++) XferErrorCallback           : transfer error callback.\r\n              (++) XferAbortCallback           : transfer abort complete callback.\r\n\r\n    [..]\r\n         (+)  If the transfer Request corresponds to SW request (MDMA_REQUEST_SW) User can use function HAL_MDMA_GenerateSWRequest to\r\n              trigger requests manually. Function HAL_MDMA_GenerateSWRequest must be used with the following precautions:\r\n              (++) This function returns an error if used while the Transfer has ended or not started.\r\n              (++) If used while the current request has not been served yet (current request transfer on going)\r\n                this function returns an error and the new request is ignored.\r\n\r\n              Generally this function should be used in conjunctions with the MDMA callbacks:\r\n              (++) example 1:\r\n                 (+++) Configure a transfer with request set to MDMA_REQUEST_SW and trigger mode set to MDMA_BUFFER_TRANSFER\r\n                 (+++) Register a callback for buffer transfer complete (using callback ID set to HAL_MDMA_XFER_BUFFERCPLT_CB_ID)\r\n                 (+++) After calling HAL_MDMA_Start_IT the MDMA will issue the transfer of a first BufferTransferLength data.\r\n                 (+++) When the buffer transfer complete callback is asserted first buffer has been transferred and user can ask for a new buffer transfer\r\n                   request using HAL_MDMA_GenerateSWRequest.\r\n\r\n              (++) example 2:\r\n                 (+++) Configure a transfer with request set to MDMA_REQUEST_SW and trigger mode set to MDMA_BLOCK_TRANSFER\r\n                 (+++) Register a callback for block transfer complete (using callback ID HAL_MDMA_XFER_BLOCKCPLT_CB_ID)\r\n                 (+++) After calling HAL_MDMA_Start_IT the MDMA will issue the transfer of a first block of data.\r\n                 (+++) When the block transfer complete callback is asserted the first block has been transferred and user can ask\r\n                   for a new block transfer request using HAL_MDMA_GenerateSWRequest.\r\n\r\n    [..]  Use HAL_MDMA_GetState() function to return the MDMA state and HAL_MDMA_GetError() in case of error detection.\r\n\r\n     *** MDMA HAL driver macros list ***\r\n     =============================================\r\n     [..]\r\n       Below the list of most used macros in MDMA HAL driver.\r\n\r\n      (+) __HAL_MDMA_ENABLE: Enable the specified MDMA Channel.\r\n      (+) __HAL_MDMA_DISABLE: Disable the specified MDMA Channel.\r\n      (+) __HAL_MDMA_GET_FLAG: Get the MDMA Channel pending flags.\r\n      (+) __HAL_MDMA_CLEAR_FLAG: Clear the MDMA Channel pending flags.\r\n      (+) __HAL_MDMA_ENABLE_IT: Enable the specified MDMA Channel interrupts.\r\n      (+) __HAL_MDMA_DISABLE_IT: Disable the specified MDMA Channel interrupts.\r\n      (+) __HAL_MDMA_GET_IT_SOURCE: Check whether the specified MDMA Channel interrupt has occurred or not.\r\n\r\n     [..]\r\n      (@) You can refer to the header file of the MDMA HAL driver for more useful macros.\r\n\r\n    [..]\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup MDMA  MDMA\r\n  * @brief MDMA HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_MDMA_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup MDMA_Private_Constants\r\n * @{\r\n */\r\n#define HAL_TIMEOUT_MDMA_ABORT    5U    /* 5 ms */\r\n#define HAL_MDMA_CHANNEL_SIZE     0x40U /* an MDMA instance channel size is 64 byte  */\r\n/**\r\n  * @}\r\n  */\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup MDMA_Private_Functions_Prototypes\r\n  * @{\r\n  */\r\nstatic void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount);\r\nstatic void MDMA_Init(MDMA_HandleTypeDef *hmdma);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup MDMA_Exported_Functions MDMA Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup MDMA_Exported_Functions_Group1\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n             ##### Initialization and de-initialization functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This section provides functions allowing to :\r\n      Initialize and de-initialize the MDMA channel.\r\n      Register and Unregister MDMA callbacks\r\n    [..]\r\n    The HAL_MDMA_Init() function follows the MDMA channel configuration procedures as described in\r\n    reference manual.\r\n    The HAL_MDMA_DeInit function allows to deinitialize the MDMA channel.\r\n    HAL_MDMA_RegisterCallback and  HAL_MDMA_UnRegisterCallback functions allows\r\n    respectevely to register/unregister an MDMA callback function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the MDMA according to the specified\r\n  *         parameters in the MDMA_InitTypeDef and create the associated handle.\r\n  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified MDMA Channel.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  uint32_t tickstart = HAL_GetTick();\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_MDMA_STREAM_ALL_INSTANCE(hmdma->Instance));\r\n  assert_param(IS_MDMA_PRIORITY(hmdma->Init.Priority));\r\n  assert_param(IS_MDMA_ENDIANNESS_MODE(hmdma->Init.Endianness));\r\n  assert_param(IS_MDMA_REQUEST(hmdma->Init.Request));\r\n  assert_param(IS_MDMA_SOURCE_INC(hmdma->Init.SourceInc));\r\n  assert_param(IS_MDMA_DESTINATION_INC(hmdma->Init.DestinationInc));\r\n  assert_param(IS_MDMA_SOURCE_DATASIZE(hmdma->Init.SourceDataSize));\r\n  assert_param(IS_MDMA_DESTINATION_DATASIZE(hmdma->Init.DestDataSize));\r\n  assert_param(IS_MDMA_DATA_ALIGNMENT(hmdma->Init.DataAlignment));\r\n  assert_param(IS_MDMA_SOURCE_BURST(hmdma->Init.SourceBurst));\r\n  assert_param(IS_MDMA_DESTINATION_BURST(hmdma->Init.DestBurst));\r\n  assert_param(IS_MDMA_BUFFER_TRANSFER_LENGTH(hmdma->Init.BufferTransferLength));\r\n  assert_param(IS_MDMA_TRANSFER_TRIGGER_MODE(hmdma->Init.TransferTriggerMode));\r\n  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));\r\n  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));\r\n\r\n\r\n  /* Allocate lock resource */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  /* Change MDMA peripheral state */\r\n  hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n  /* Disable the MDMA channel */\r\n  __HAL_MDMA_DISABLE(hmdma);\r\n\r\n  /* Check if the MDMA channel is effectively disabled */\r\n  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)\r\n  {\r\n    /* Check for the Timeout */\r\n    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)\r\n    {\r\n      /* Update error code */\r\n      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;\r\n\r\n      /* Change the MDMA state */\r\n      hmdma->State = HAL_MDMA_STATE_ERROR;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  /* Initialize the MDMA channel registers */\r\n  MDMA_Init(hmdma);\r\n\r\n  /* Reset the MDMA first/last linkedlist node addresses and node counter */\r\n  hmdma->FirstLinkedListNodeAddress  = 0;\r\n  hmdma->LastLinkedListNodeAddress   = 0;\r\n  hmdma->LinkedListNodeCounter  = 0;\r\n\r\n  /* Initialize the error code */\r\n  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;\r\n\r\n  /* Initialize the MDMA state */\r\n  hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the MDMA peripheral\r\n  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified MDMA Channel.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)\r\n{\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Disable the selected MDMA Channelx */\r\n  __HAL_MDMA_DISABLE(hmdma);\r\n\r\n  /* Reset MDMA Channel control register */\r\n  hmdma->Instance->CCR  = 0;\r\n  hmdma->Instance->CTCR = 0;\r\n  hmdma->Instance->CBNDTR = 0;\r\n  hmdma->Instance->CSAR = 0;\r\n  hmdma->Instance->CDAR = 0;\r\n  hmdma->Instance->CBRUR = 0;\r\n  hmdma->Instance->CLAR = 0;\r\n  hmdma->Instance->CTBR = 0;\r\n  hmdma->Instance->CMAR = 0;\r\n  hmdma->Instance->CMDR = 0;\r\n\r\n  /* Clear all flags */\r\n  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));\r\n\r\n  /* Reset the  MDMA first/last linkedlist node addresses and node counter */\r\n  hmdma->FirstLinkedListNodeAddress  = 0;\r\n  hmdma->LastLinkedListNodeAddress   = 0;\r\n  hmdma->LinkedListNodeCounter  = 0;\r\n\r\n  /* Initialize the error code */\r\n  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;\r\n\r\n  /* Initialize the MDMA state */\r\n  hmdma->State = HAL_MDMA_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Config the Post request Mask address and Mask data\r\n  * @param  hmdma      : pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified MDMA Channel.\r\n  * @param  MaskAddress: specifies the address to be updated (written) with MaskData after a request is served.\r\n  * @param  MaskData:    specifies the value to be written to MaskAddress after a request is served.\r\n  *                      MaskAddress and MaskData could be used to automatically clear a peripheral flag when the request is served.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_ConfigPostRequestMask(MDMA_HandleTypeDef *hmdma, uint32_t MaskAddress, uint32_t MaskData)\r\n{\r\n  HAL_StatusTypeDef  status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* if HW request set Post Request MaskAddress and MaskData,  */\r\n    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)\r\n    {\r\n      /* Set the HW request clear Mask and Data */\r\n      hmdma->Instance->CMAR = MaskAddress;\r\n      hmdma->Instance->CMDR = MaskData;\r\n\r\n      /*\r\n      -If the request is done by SW : BWM could be set to 1 or 0.\r\n      -If the request is done by a peripheral :\r\n         If mask address not set (0) => BWM must be set to 0\r\n         If mask address set (different than 0) => BWM could be set to 1 or 0\r\n      */\r\n      if(MaskAddress == 0U)\r\n      {\r\n        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;\r\n      }\r\n      else\r\n      {\r\n        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Return error status */\r\n      status =  HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register callbacks\r\n  * @param  hmdma:                pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified MDMA Channel.\r\n  * @param  CallbackID:           User Callback identifier\r\n  * @param  pCallback:            pointer to callbacsk function.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_RegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID, void (* pCallback)(MDMA_HandleTypeDef *_hmdma))\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_MDMA_XFER_CPLT_CB_ID:\r\n      hmdma->XferCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:\r\n      hmdma->XferBufferCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:\r\n      hmdma->XferBlockCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:\r\n      hmdma->XferRepeatBlockCpltCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_ERROR_CB_ID:\r\n      hmdma->XferErrorCallback = pCallback;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_ABORT_CB_ID:\r\n      hmdma->XferAbortCallback = pCallback;\r\n      break;\r\n\r\n    default:\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister callbacks\r\n  * @param  hmdma:                 pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                               the configuration information for the specified MDMA Channel.\r\n  * @param  CallbackID:           User Callback identifier\r\n  *                               a HAL_MDMA_CallbackIDTypeDef ENUM as parameter.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_UnRegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n    case  HAL_MDMA_XFER_CPLT_CB_ID:\r\n      hmdma->XferCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:\r\n      hmdma->XferBufferCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:\r\n      hmdma->XferBlockCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:\r\n      hmdma->XferRepeatBlockCpltCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_ERROR_CB_ID:\r\n      hmdma->XferErrorCallback = NULL;\r\n      break;\r\n\r\n    case  HAL_MDMA_XFER_ABORT_CB_ID:\r\n      hmdma->XferAbortCallback = NULL;\r\n      break;\r\n\r\n    case   HAL_MDMA_XFER_ALL_CB_ID:\r\n      hmdma->XferCpltCallback = NULL;\r\n      hmdma->XferBufferCpltCallback = NULL;\r\n      hmdma->XferBlockCpltCallback = NULL;\r\n      hmdma->XferRepeatBlockCpltCallback = NULL;\r\n      hmdma->XferErrorCallback = NULL;\r\n      hmdma->XferAbortCallback = NULL;\r\n      break;\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup MDMA_Exported_Functions_Group2\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      #####  Linked list operation functions  #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Create a linked list node\r\n      (+) Add a node to the MDMA linked list\r\n      (+) Remove a node from the MDMA linked list\r\n      (+) Enable/Disable linked list circular mode\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes an MDMA Link Node according to the specified\r\n  *         parameters in the pMDMA_LinkedListNodeConfig .\r\n  * @param  pNode: Pointer to a MDMA_LinkNodeTypeDef structure that contains Linked list node\r\n  *         registers configurations.\r\n  * @param  pNodeConfig: Pointer to a MDMA_LinkNodeConfTypeDef structure that contains\r\n  *               the configuration information for the specified MDMA Linked List Node.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_LinkedList_CreateNode(MDMA_LinkNodeTypeDef *pNode, MDMA_LinkNodeConfTypeDef *pNodeConfig)\r\n{\r\n  uint32_t addressMask;\r\n  uint32_t blockoffset;\r\n\r\n  /* Check the MDMA peripheral state */\r\n  if((pNode == NULL) || (pNodeConfig == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_MDMA_PRIORITY(pNodeConfig->Init.Priority));\r\n  assert_param(IS_MDMA_ENDIANNESS_MODE(pNodeConfig->Init.Endianness));\r\n  assert_param(IS_MDMA_REQUEST(pNodeConfig->Init.Request));\r\n  assert_param(IS_MDMA_SOURCE_INC(pNodeConfig->Init.SourceInc));\r\n  assert_param(IS_MDMA_DESTINATION_INC(pNodeConfig->Init.DestinationInc));\r\n  assert_param(IS_MDMA_SOURCE_DATASIZE(pNodeConfig->Init.SourceDataSize));\r\n  assert_param(IS_MDMA_DESTINATION_DATASIZE(pNodeConfig->Init.DestDataSize));\r\n  assert_param(IS_MDMA_DATA_ALIGNMENT(pNodeConfig->Init.DataAlignment));\r\n  assert_param(IS_MDMA_SOURCE_BURST(pNodeConfig->Init.SourceBurst));\r\n  assert_param(IS_MDMA_DESTINATION_BURST(pNodeConfig->Init.DestBurst));\r\n  assert_param(IS_MDMA_BUFFER_TRANSFER_LENGTH(pNodeConfig->Init.BufferTransferLength));\r\n  assert_param(IS_MDMA_TRANSFER_TRIGGER_MODE(pNodeConfig->Init.TransferTriggerMode));\r\n  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(pNodeConfig->Init.SourceBlockAddressOffset));\r\n  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(pNodeConfig->Init.DestBlockAddressOffset));\r\n\r\n  assert_param(IS_MDMA_TRANSFER_LENGTH(pNodeConfig->BlockDataLength));\r\n  assert_param(IS_MDMA_BLOCK_COUNT(pNodeConfig->BlockCount));\r\n\r\n\r\n  /* Configure next Link node Address Register to zero */\r\n  pNode->CLAR =  0;\r\n\r\n  /* Configure the Link Node registers*/\r\n  pNode->CTBR   = 0;\r\n  pNode->CMAR   = 0;\r\n  pNode->CMDR   = 0;\r\n  pNode->Reserved = 0;\r\n\r\n  /* Write new CTCR Register value */\r\n  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \\\r\n    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \\\r\n      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \\\r\n        pNodeConfig->Init.DestBurst                                             | \\\r\n          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \\\r\n            pNodeConfig->Init.TransferTriggerMode;\r\n\r\n  /* If SW request set the CTCR register to SW Request Mode*/\r\n  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)\r\n  {\r\n    pNode->CTCR |= MDMA_CTCR_SWRM;\r\n  }\r\n\r\n  /*\r\n  -If the request is done by SW : BWM could be set to 1 or 0.\r\n  -If the request is done by a peripheral :\r\n     If mask address not set (0) => BWM must be set to 0\r\n     If mask address set (different than 0) => BWM could be set to 1 or 0\r\n  */\r\n  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))\r\n  {\r\n    pNode->CTCR |=  MDMA_CTCR_BWM;\r\n  }\r\n\r\n  /* Set the new CBNDTR Register value */\r\n  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;\r\n\r\n  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */\r\n  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)\r\n  {\r\n    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;\r\n    /*write new CBRUR Register value : source repeat block offset */\r\n    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);\r\n    pNode->CBRUR = blockoffset & 0x0000FFFFU;\r\n  }\r\n  else\r\n  {\r\n    /*write new CBRUR Register value : source repeat block offset */\r\n    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);\r\n  }\r\n\r\n  /* if block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */\r\n  if(pNodeConfig->Init.DestBlockAddressOffset < 0)\r\n  {\r\n    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;\r\n    /*write new CBRUR Register value : destination repeat block offset */\r\n    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);\r\n    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);\r\n  }\r\n  else\r\n  {\r\n    /*write new CBRUR Register value : destination repeat block offset */\r\n    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);\r\n  }\r\n\r\n  /* Configure MDMA Link Node data length */\r\n  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;\r\n\r\n  /* Configure MDMA Link Node destination address */\r\n  pNode->CDAR = pNodeConfig->DstAddress;\r\n\r\n  /* Configure MDMA Link Node Source address */\r\n  pNode->CSAR = pNodeConfig->SrcAddress;\r\n\r\n  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData,  */\r\n  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)\r\n  {\r\n    /* Set the HW request in CTBR register  */\r\n    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;\r\n    /* Set the HW request clear Mask and Data */\r\n    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;\r\n    pNode->CMDR = pNodeConfig->PostRequestMaskData;\r\n  }\r\n\r\n  addressMask = pNodeConfig->SrcAddress & 0xFF000000U;\r\n  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))\r\n  {\r\n    /*The AHBSbus is used as source (read operation) on channel x */\r\n    pNode->CTBR |= MDMA_CTBR_SBUS;\r\n  }\r\n\r\n  addressMask = pNodeConfig->DstAddress & 0xFF000000U;\r\n  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))\r\n  {\r\n    /*The AHB bus is used as destination (write operation) on channel x */\r\n    pNode->CTBR |= MDMA_CTBR_DBUS;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Connect a node to the linked list.\r\n  * @param  hmdma    : Pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                    the configuration information for the specified MDMA Channel.\r\n  * @param  pNewNode : Pointer to a MDMA_LinkNodeTypeDef structure that contains Linked list node\r\n  *                    to be add to the list.\r\n  * @param pPrevNode : Pointer to the new node position in the linked list or zero to insert the new node\r\n  *                    at the end of the list\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_LinkedList_AddNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNewNode, MDMA_LinkNodeTypeDef *pPrevNode)\r\n{\r\n  MDMA_LinkNodeTypeDef *pNode;\r\n  uint32_t counter = 0, nodeInserted = 0;\r\n  HAL_StatusTypeDef hal_status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if((hmdma == NULL) || (pNewNode == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* Change MDMA peripheral state */\r\n    hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n    /* Check if this is the first node (after the Inititlization node) */\r\n    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)\r\n    {\r\n      if(pPrevNode == NULL)\r\n      {\r\n        /* if this is the first node after the initialization\r\n        connect this node to the node 0 by updating\r\n        the MDMA channel CLAR register to this node address */\r\n        hmdma->Instance->CLAR = (uint32_t)pNewNode;\r\n        /* Set the MDMA handle First linked List node*/\r\n        hmdma->FirstLinkedListNodeAddress = pNewNode;\r\n\r\n        /*reset New node link */\r\n        pNewNode->CLAR = 0;\r\n\r\n        /* Update the Handle last node address */\r\n        hmdma->LastLinkedListNodeAddress = pNewNode;\r\n\r\n        hmdma->LinkedListNodeCounter = 1;\r\n      }\r\n      else\r\n      {\r\n        hal_status = HAL_ERROR;\r\n      }\r\n    }\r\n    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)\r\n    {\r\n      /* Check if the node to insert already exists*/\r\n      pNode = hmdma->FirstLinkedListNodeAddress;\r\n      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))\r\n      {\r\n        if(pNode->CLAR == (uint32_t)pNewNode)\r\n        {\r\n          hal_status = HAL_ERROR; /* error this node already exist in the linked list and it is not first node */\r\n        }\r\n        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;\r\n        counter++;\r\n      }\r\n\r\n      if(hal_status == HAL_OK)\r\n      {\r\n        /* Check if the previous node is the last one in the current list or zero */\r\n        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))\r\n        {\r\n          /* insert the new node at the end of the list */\r\n          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;\r\n          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;\r\n          /* Update the Handle last node address */\r\n          hmdma->LastLinkedListNodeAddress = pNewNode;\r\n          /* Increment the linked list node counter */\r\n          hmdma->LinkedListNodeCounter++;\r\n        }\r\n        else\r\n        {\r\n          /*insert the new node after the pPreviousNode node */\r\n          pNode = hmdma->FirstLinkedListNodeAddress;\r\n          counter = 0;\r\n          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))\r\n          {\r\n            counter++;\r\n            if(pNode == pPrevNode)\r\n            {\r\n              /*Insert the new node after the previous one */\r\n              pNewNode->CLAR = pNode->CLAR;\r\n              pNode->CLAR = (uint32_t)pNewNode;\r\n              /* Increment the linked list node counter */\r\n              hmdma->LinkedListNodeCounter++;\r\n              nodeInserted = 1;\r\n            }\r\n            else\r\n            {\r\n              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;\r\n            }\r\n          }\r\n\r\n          if(nodeInserted == 0U)\r\n          {\r\n            hal_status = HAL_ERROR;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      hal_status = HAL_ERROR;\r\n    }\r\n\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n    return hal_status;\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    /* Return error status */\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Disconnect/Remove a node from the transfer linked list.\r\n  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified MDMA Channel.\r\n  * @param  pNode : Pointer to a MDMA_LinkNodeTypeDef structure that contains Linked list node\r\n  *                 to be removed from the list.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_LinkedList_RemoveNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNode)\r\n{\r\n  MDMA_LinkNodeTypeDef *ptmpNode;\r\n  uint32_t counter = 0, nodeDeleted = 0;\r\n  HAL_StatusTypeDef hal_status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if((hmdma == NULL) || (pNode == NULL))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* Change MDMA peripheral state */\r\n    hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n    /* If first and last node are null (no nodes in the list) : return error*/\r\n    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))\r\n    {\r\n      hal_status = HAL_ERROR;\r\n    }\r\n    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */\r\n    {\r\n      /* Delete 1st node */\r\n      if(hmdma->LastLinkedListNodeAddress == pNode)\r\n      {\r\n        /*if the last node is at the same time the first one (1 single node after the init node 0)\r\n        then update the last node too */\r\n\r\n        hmdma->FirstLinkedListNodeAddress = 0;\r\n        hmdma->LastLinkedListNodeAddress  = 0;\r\n        hmdma->LinkedListNodeCounter = 0;\r\n\r\n        hmdma->Instance->CLAR = 0;\r\n      }\r\n      else\r\n      {\r\n        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)\r\n        {\r\n          /* if last node is looping to first (circular list) one update the last node connection */\r\n          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;\r\n        }\r\n\r\n        /* if deleting the first node after the initialization\r\n        connect the next node to the node 0 by updating\r\n        the MDMA channel CLAR register to this node address */\r\n        hmdma->Instance->CLAR = pNode->CLAR;\r\n        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;\r\n        /* Update the Handle node counter */\r\n        hmdma->LinkedListNodeCounter--;\r\n      }\r\n    }\r\n    else /* Deleting any other node */\r\n    {\r\n      /*Deleted node is not the first one : find it  */\r\n      ptmpNode = hmdma->FirstLinkedListNodeAddress;\r\n      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))\r\n      {\r\n        counter++;\r\n        if(ptmpNode->CLAR == ((uint32_t)pNode))\r\n        {\r\n          /* if deleting the last node */\r\n          if(pNode == hmdma->LastLinkedListNodeAddress)\r\n          {\r\n            /*Update the linked list last node address in the handle*/\r\n            hmdma->LastLinkedListNodeAddress = ptmpNode;\r\n          }\r\n          /* update the next node link after deleting pMDMA_LinkedListNode */\r\n          ptmpNode->CLAR = pNode->CLAR;\r\n          nodeDeleted = 1;\r\n          /* Update the Handle node counter */\r\n          hmdma->LinkedListNodeCounter--;\r\n        }\r\n        else\r\n        {\r\n          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;\r\n        }\r\n      }\r\n\r\n      if(nodeDeleted == 0U)\r\n      {\r\n        /* last node reashed without finding the node to delete : return error */\r\n        hal_status = HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n    return hal_status;\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    /* Return error status */\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Make the linked list circular by connecting the last node to the first.\r\n  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified MDMA Channel.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_LinkedList_EnableCircularMode(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  HAL_StatusTypeDef hal_status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* Change MDMA peripheral state */\r\n    hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n    /* If first and last node are null (no nodes in the list) : return error*/\r\n    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))\r\n    {\r\n      hal_status = HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      /* to enable circular mode Last Node should be connected to first node */\r\n      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;\r\n    }\r\n\r\n  }\r\n  /* Process unlocked */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n  return hal_status;\r\n}\r\n\r\n/**\r\n  * @brief  Disable the linked list circular mode by setting the last node connection to null\r\n  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified MDMA Channel.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_LinkedList_DisableCircularMode(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  HAL_StatusTypeDef hal_status = HAL_OK;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* Change MDMA peripheral state */\r\n    hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n    /* If first and last node are null (no nodes in the list) : return error*/\r\n    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))\r\n    {\r\n      hal_status = HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      /* to disable circular mode Last Node should be connected to NULL */\r\n      hmdma->LastLinkedListNodeAddress->CLAR = 0;\r\n    }\r\n\r\n  }\r\n  /* Process unlocked */\r\n  __HAL_UNLOCK(hmdma);\r\n\r\n  hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n  return hal_status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup MDMA_Exported_Functions_Group3\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      #####  IO operation functions  #####\r\n ===============================================================================\r\n    [..]  This section provides functions allowing to:\r\n      (+) Configure the source, destination address and data length and Start MDMA transfer\r\n      (+) Configure the source, destination address and data length and\r\n          Start MDMA transfer with interrupt\r\n      (+) Abort MDMA transfer\r\n      (+) Poll for transfer complete\r\n      (+) Generate a SW request (when Request is set to MDMA_REQUEST_SW)\r\n      (+) Handle MDMA interrupt request\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the MDMA Transfer.\r\n  * @param  hmdma           : pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                           the configuration information for the specified MDMA Channel.\r\n  * @param  SrcAddress      : The source memory Buffer address\r\n  * @param  DstAddress      : The destination memory Buffer address\r\n  * @param  BlockDataLength : The length of a block transfer in bytes\r\n  * @param  BlockCount      : The number of a blocks to be transfer\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_Start(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));\r\n  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* Change MDMA peripheral state */\r\n    hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n    /* Initialize the error code */\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;\r\n\r\n    /* Disable the peripheral */\r\n    __HAL_MDMA_DISABLE(hmdma);\r\n\r\n    /* Configure the source, destination address and the data length */\r\n    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);\r\n\r\n    /* Enable the Peripheral */\r\n    __HAL_MDMA_ENABLE(hmdma);\r\n\r\n    if(hmdma->Init.Request == MDMA_REQUEST_SW)\r\n    {\r\n      /* activate If SW request mode*/\r\n      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    /* Return error status */\r\n    return HAL_BUSY;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the MDMA Transfer with interrupts enabled.\r\n  * @param  hmdma           : pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                           the configuration information for the specified MDMA Channel.\r\n  * @param  SrcAddress      : The source memory Buffer address\r\n  * @param  DstAddress      : The destination memory Buffer address\r\n  * @param  BlockDataLength : The length of a block transfer in bytes\r\n  * @param  BlockCount      : The number of a blocks to be transfer\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));\r\n  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(hmdma);\r\n\r\n  if(HAL_MDMA_STATE_READY == hmdma->State)\r\n  {\r\n    /* Change MDMA peripheral state */\r\n    hmdma->State = HAL_MDMA_STATE_BUSY;\r\n\r\n    /* Initialize the error code */\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;\r\n\r\n    /* Disable the peripheral */\r\n    __HAL_MDMA_DISABLE(hmdma);\r\n\r\n    /* Configure the source, destination address and the data length */\r\n    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);\r\n\r\n    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/\r\n    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));\r\n\r\n    if(hmdma->XferBlockCpltCallback != NULL)\r\n    {\r\n      /* if Block transfer complete Callback is set enable the corresponding IT*/\r\n      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);\r\n    }\r\n\r\n    if(hmdma->XferRepeatBlockCpltCallback != NULL)\r\n    {\r\n      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/\r\n      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);\r\n    }\r\n\r\n    if(hmdma->XferBufferCpltCallback != NULL)\r\n    {\r\n      /* if buffer transfer complete Callback is set enable the corresponding IT*/\r\n      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);\r\n    }\r\n\r\n    /* Enable the Peripheral */\r\n    __HAL_MDMA_ENABLE(hmdma);\r\n\r\n    if(hmdma->Init.Request == MDMA_REQUEST_SW)\r\n    {\r\n      /* activate If SW request mode*/\r\n      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    /* Return error status */\r\n    return HAL_BUSY;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the MDMA Transfer.\r\n  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified MDMA Channel.\r\n  *\r\n  * @note  After disabling a MDMA Channel, a check for wait until the MDMA Channel is\r\n  *        effectively disabled is added. If a Channel is disabled\r\n  *        while a data transfer is ongoing, the current data will be transferred\r\n  *        and the Channel will be effectively disabled only after the transfer of\r\n  *        this single data is finished.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_Abort(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  uint32_t tickstart =  HAL_GetTick();\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(HAL_MDMA_STATE_BUSY != hmdma->State)\r\n  {\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Disable all the transfer interrupts */\r\n    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));\r\n\r\n    /* Disable the channel */\r\n    __HAL_MDMA_DISABLE(hmdma);\r\n\r\n    /* Check if the MDMA Channel is effectively disabled */\r\n    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)\r\n    {\r\n      /* Check for the Timeout */\r\n      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)\r\n      {\r\n        /* Update error code */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;\r\n\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hmdma);\r\n\r\n        /* Change the MDMA state */\r\n        hmdma->State = HAL_MDMA_STATE_ERROR;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    /* Clear all interrupt flags */\r\n    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    /* Change the MDMA state*/\r\n    hmdma->State = HAL_MDMA_STATE_READY;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Aborts the MDMA Transfer in Interrupt mode.\r\n  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                 the configuration information for the specified MDMA Channel.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_Abort_IT(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(HAL_MDMA_STATE_BUSY != hmdma->State)\r\n  {\r\n    /* No transfer ongoing */\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Set Abort State  */\r\n    hmdma->State = HAL_MDMA_STATE_ABORT;\r\n\r\n    /* Disable the stream */\r\n    __HAL_MDMA_DISABLE(hmdma);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Polling for transfer complete.\r\n  * @param  hmdma:          pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                        the configuration information for the specified MDMA Channel.\r\n  * @param  CompleteLevel: Specifies the MDMA level complete.\r\n  * @param  Timeout:       Timeout duration.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_PollForTransfer(MDMA_HandleTypeDef *hmdma, HAL_MDMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)\r\n{\r\n  uint32_t levelFlag, errorFlag;\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_MDMA_LEVEL_COMPLETE(CompleteLevel));\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if(HAL_MDMA_STATE_BUSY != hmdma->State)\r\n  {\r\n    /* No transfer ongoing */\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Get the level transfer complete flag */\r\n  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \\\r\n               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \\\r\n               (CompleteLevel == HAL_MDMA_BLOCK_TRANSFER) ? MDMA_FLAG_BT   : \\\r\n               MDMA_FLAG_BRT);\r\n\r\n\r\n  /* Get timeout */\r\n  tickstart = HAL_GetTick();\r\n\r\n  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)\r\n  {\r\n    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))\r\n    {\r\n      /* Get the transfer error source flag */\r\n      errorFlag = hmdma->Instance->CESR;\r\n\r\n      if((errorFlag & MDMA_CESR_TED) == 0U)\r\n      {\r\n        /* Update error code : Read Transfer error  */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;\r\n      }\r\n      else\r\n      {\r\n        /* Update error code : Write Transfer error */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_TEMD) != 0U)\r\n      {\r\n        /* Update error code : Error Mask Data */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_TELD) != 0U)\r\n      {\r\n        /* Update error code : Error Linked list */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_ASE) != 0U)\r\n      {\r\n        /* Update error code : Address/Size alignment error */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_BSE) != 0U)\r\n      {\r\n        /* Update error code : Block Size error */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;\r\n      }\r\n\r\n      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */\r\n\r\n      /*\r\n        Note that the Abort function will\r\n          - Clear all transfer flags\r\n          - Unlock\r\n          - Set the State\r\n      */\r\n\r\n      return HAL_ERROR;\r\n\r\n    }\r\n\r\n    /* Check for the Timeout */\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))\r\n      {\r\n        /* Update error code */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;\r\n\r\n        (void) HAL_MDMA_Abort(hmdma); /* if timeout then abort the current transfer */\r\n\r\n        /*\r\n          Note that the Abort function will\r\n            - Clear all transfer flags\r\n            - Unlock\r\n            - Set the State\r\n        */\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Clear the transfer level flag */\r\n  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)\r\n  {\r\n    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);\r\n\r\n  }\r\n  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)\r\n  {\r\n    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));\r\n\r\n  }\r\n  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)\r\n  {\r\n    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));\r\n  }\r\n  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)\r\n  {\r\n    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));\r\n\r\n    /* Process unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    hmdma->State = HAL_MDMA_STATE_READY;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Generate an MDMA SW request trigger to activate the request on the given Channel.\r\n  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified MDMA Stream.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MDMA_GenerateSWRequest(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  uint32_t request_mode;\r\n\r\n  /* Check the MDMA peripheral handle */\r\n  if(hmdma == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Get the softawre request mode */\r\n  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;\r\n\r\n  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)\r\n  {\r\n    /* if no Transfer on going (MDMA enable bit not set) return error */\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))\r\n  {\r\n    /* if an MDMA ongoing request has not yet end or if request mode is not SW request return error */\r\n    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Set the SW request bit to activate the request on the Channel */\r\n    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;\r\n\r\n    return HAL_OK;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Handles MDMA interrupt request.\r\n  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified MDMA Channel.\r\n  * @retval None\r\n  */\r\nvoid HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  __IO uint32_t count = 0;\r\n  uint32_t timeout = SystemCoreClock / 9600U;\r\n\r\n  uint32_t generalIntFlag, errorFlag;\r\n\r\n  /* General Interrupt Flag management ****************************************/\r\n  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);\r\n  if((MDMA->GISR0 & generalIntFlag) == 0U)\r\n  {\r\n    return; /* the  General interrupt flag for the current channel is down , nothing to do */\r\n  }\r\n\r\n  /* Transfer Error Interrupt management ***************************************/\r\n  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))\r\n  {\r\n    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)\r\n    {\r\n      /* Disable the transfer error interrupt */\r\n      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);\r\n\r\n      /* Get the transfer error source flag */\r\n      errorFlag = hmdma->Instance->CESR;\r\n\r\n      if((errorFlag & MDMA_CESR_TED) == 0U)\r\n      {\r\n        /* Update error code : Read Transfer error  */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;\r\n      }\r\n      else\r\n      {\r\n        /* Update error code : Write Transfer error */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_TEMD) != 0U)\r\n      {\r\n        /* Update error code : Error Mask Data */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_TELD) != 0U)\r\n      {\r\n        /* Update error code : Error Linked list */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_ASE) != 0U)\r\n      {\r\n        /* Update error code : Address/Size alignment error */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;\r\n      }\r\n\r\n      if((errorFlag & MDMA_CESR_BSE) != 0U)\r\n      {\r\n        /* Update error code : Block Size error error */\r\n        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;\r\n      }\r\n\r\n      /* Clear the transfer error flags */\r\n      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);\r\n    }\r\n  }\r\n\r\n  /* Buffer Transfer Complete Interrupt management ******************************/\r\n  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))\r\n  {\r\n    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)\r\n    {\r\n      /* Clear the buffer transfer complete flag */\r\n      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);\r\n\r\n      if(hmdma->XferBufferCpltCallback != NULL)\r\n      {\r\n        /* Buffer transfer callback */\r\n        hmdma->XferBufferCpltCallback(hmdma);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Block Transfer Complete Interrupt management ******************************/\r\n  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))\r\n  {\r\n    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)\r\n    {\r\n      /* Clear the block transfer complete flag */\r\n      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);\r\n\r\n      if(hmdma->XferBlockCpltCallback != NULL)\r\n      {\r\n        /* Block transfer callback */\r\n        hmdma->XferBlockCpltCallback(hmdma);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Repeated Block Transfer Complete Interrupt management ******************************/\r\n  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))\r\n  {\r\n    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)\r\n    {\r\n      /* Clear the repeat block transfer complete flag */\r\n      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);\r\n\r\n      if(hmdma->XferRepeatBlockCpltCallback != NULL)\r\n      {\r\n        /* Repeated Block transfer callback */\r\n        hmdma->XferRepeatBlockCpltCallback(hmdma);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Channel Transfer Complete Interrupt management ***********************************/\r\n  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))\r\n  {\r\n    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)\r\n    {\r\n      /* Disable all the transfer interrupts */\r\n      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));\r\n\r\n      if(HAL_MDMA_STATE_ABORT == hmdma->State)\r\n      {\r\n        /* Process Unlocked */\r\n        __HAL_UNLOCK(hmdma);\r\n\r\n        /* Change the DMA state */\r\n        hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n        if(hmdma->XferAbortCallback != NULL)\r\n        {\r\n          hmdma->XferAbortCallback(hmdma);\r\n        }\r\n        return;\r\n      }\r\n\r\n      /* Clear the Channel Transfer Complete flag */\r\n      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(hmdma);\r\n\r\n      /* Change MDMA peripheral state */\r\n      hmdma->State = HAL_MDMA_STATE_READY;\r\n\r\n      if(hmdma->XferCpltCallback != NULL)\r\n      {\r\n        /* Channel Transfer Complete callback */\r\n        hmdma->XferCpltCallback(hmdma);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* manage error case */\r\n  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)\r\n  {\r\n    hmdma->State = HAL_MDMA_STATE_ABORT;\r\n\r\n    /* Disable the channel */\r\n    __HAL_MDMA_DISABLE(hmdma);\r\n\r\n    do\r\n    {\r\n      if (++count > timeout)\r\n      {\r\n        break;\r\n      }\r\n    }\r\n    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);\r\n\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hmdma);\r\n\r\n    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)\r\n    {\r\n      /* Change the MDMA state to error if MDMA disable fails */\r\n      hmdma->State = HAL_MDMA_STATE_ERROR;\r\n    }\r\n    else\r\n    {\r\n      /* Change the MDMA state to Ready if MDMA disable success */\r\n      hmdma->State = HAL_MDMA_STATE_READY;\r\n    }\r\n\r\n\r\n    if (hmdma->XferErrorCallback != NULL)\r\n    {\r\n      /* Transfer error callback */\r\n      hmdma->XferErrorCallback(hmdma);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup MDMA_Exported_Functions_Group4\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                    ##### State and Errors functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides functions allowing to\r\n      (+) Check the MDMA state\r\n      (+) Get error code\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Returns the MDMA state.\r\n  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified MDMA Channel.\r\n  * @retval HAL state\r\n  */\r\nHAL_MDMA_StateTypeDef HAL_MDMA_GetState(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  return hmdma->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the MDMA error code\r\n  * @param  hmdma : pointer to a MDMA_HandleTypeDef structure that contains\r\n  *              the configuration information for the specified MDMA Channel.\r\n  * @retval MDMA Error Code\r\n  */\r\nuint32_t HAL_MDMA_GetError(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  return hmdma->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup MDMA_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Sets the MDMA Transfer parameter.\r\n  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified MDMA Channel.\r\n  * @param  SrcAddress: The source memory Buffer address\r\n  * @param  DstAddress: The destination memory Buffer address\r\n  * @param  BlockDataLength : The length of a block transfer in bytes\r\n  * @param  BlockCount: The number of blocks to be transferred\r\n  * @retval HAL status\r\n  */\r\nstatic void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)\r\n{\r\n  uint32_t addressMask;\r\n\r\n  /* Configure the MDMA Channel data length */\r\n  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));\r\n\r\n  /* Configure the MDMA block repeat count */\r\n  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);\r\n\r\n  /* Clear all interrupt flags */\r\n  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);\r\n\r\n  /* Configure MDMA Channel destination address */\r\n  hmdma->Instance->CDAR = DstAddress;\r\n\r\n  /* Configure MDMA Channel Source address */\r\n  hmdma->Instance->CSAR = SrcAddress;\r\n\r\n  addressMask = SrcAddress & 0xFF000000U;\r\n  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))\r\n  {\r\n    /*The AHBSbus is used as source (read operation) on channel x */\r\n    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;\r\n  }\r\n  else\r\n  {\r\n    /*The AXI bus is used as source (read operation) on channel x */\r\n    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);\r\n  }\r\n\r\n  addressMask = DstAddress & 0xFF000000U;\r\n  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))\r\n  {\r\n    /*The AHB bus is used as destination (write operation) on channel x */\r\n    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;\r\n  }\r\n  else\r\n  {\r\n    /*The AXI bus is used as destination (write operation) on channel x */\r\n    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);\r\n  }\r\n\r\n  /* Set the linked list register to the first node of the list */\r\n  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the MDMA handle according to the specified\r\n  *         parameters in the MDMA_InitTypeDef\r\n  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains\r\n  *                     the configuration information for the specified MDMA Channel.\r\n  * @retval None\r\n  */\r\nstatic void MDMA_Init(MDMA_HandleTypeDef *hmdma)\r\n{\r\n  uint32_t blockoffset;\r\n\r\n  /* Prepare the MDMA Channel configuration */\r\n  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;\r\n\r\n  /* Write new CTCR Register value */\r\n  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \\\r\n                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \\\r\n                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \\\r\n                           hmdma->Init.DestBurst                                   | \\\r\n                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \\\r\n                           hmdma->Init.TransferTriggerMode;\r\n\r\n  /* If SW request set the CTCR register to SW Request Mode */\r\n  if(hmdma->Init.Request == MDMA_REQUEST_SW)\r\n  {\r\n    /*\r\n    -If the request is done by SW : BWM could be set to 1 or 0.\r\n    -If the request is done by a peripheral :\r\n    If mask address not set (0) => BWM must be set to 0\r\n    If mask address set (different than 0) => BWM could be set to 1 or 0\r\n    */\r\n    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);\r\n  }\r\n\r\n  /* Reset CBNDTR Register */\r\n  hmdma->Instance->CBNDTR = 0;\r\n\r\n  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */\r\n  if(hmdma->Init.SourceBlockAddressOffset < 0)\r\n  {\r\n    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;\r\n    /* Write new CBRUR Register value : source repeat block offset */\r\n    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);\r\n    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);\r\n  }\r\n  else\r\n  {\r\n    /* Write new CBRUR Register value : source repeat block offset */\r\n    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);\r\n  }\r\n\r\n  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */\r\n  if(hmdma->Init.DestBlockAddressOffset < 0)\r\n  {\r\n    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;\r\n    /* Write new CBRUR Register value : destination repeat block offset */\r\n    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);\r\n    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);\r\n  }\r\n  else\r\n  {\r\n    /*write new CBRUR Register value : destination repeat block offset */\r\n    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);\r\n  }\r\n\r\n  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */\r\n  if(hmdma->Init.Request != MDMA_REQUEST_SW)\r\n  {\r\n    /* Set the HW request in CTRB register  */\r\n    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;\r\n  }\r\n  else /* SW request : reset the CTBR register */\r\n  {\r\n    hmdma->Instance->CTBR = 0;\r\n  }\r\n\r\n  /* Write Link Address Register */\r\n  hmdma->Instance->CLAR =  0;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_MDMA_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_msp.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file         stm32h7xx_hal_msp.c\r\n  * @brief        This file provides code for the MSP Initialization\r\n  *               and de-Initialization codes.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2026 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n/* USER CODE BEGIN Includes */\r\n\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN TD */\r\n\r\n/* USER CODE END TD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN Define */\r\n\r\n/* USER CODE END Define */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN Macro */\r\n\r\n/* USER CODE END Macro */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* External functions --------------------------------------------------------*/\r\n/* USER CODE BEGIN ExternalFunctions */\r\n\r\n/* USER CODE END ExternalFunctions */\r\n\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n/**\r\n  * Initializes the Global MSP.\r\n  */\r\nvoid HAL_MspInit(void)\r\n{\r\n  /* USER CODE BEGIN MspInit 0 */\r\n\r\n  /* USER CODE END MspInit 0 */\r\n\r\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\r\n\r\n  /* System interrupt init*/\r\n\r\n  /* USER CODE BEGIN MspInit 1 */\r\n\r\n  /* USER CODE END MspInit 1 */\r\n}\r\n\r\n/**\r\n* @brief SPI MSP Initialization\r\n* This function configures the hardware resources used in this example\r\n* @param hspi: SPI handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};\r\n  if(hspi->Instance==SPI1)\r\n  {\r\n  /* USER CODE BEGIN SPI1_MspInit 0 */\r\n\r\n  /* USER CODE END SPI1_MspInit 0 */\r\n  /** Initializes the peripherals clock\r\n  */\r\n    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI1;\r\n    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;\r\n    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)\r\n    {\r\n      Error_Handler();\r\n    }\r\n\r\n    /* Peripheral clock enable */\r\n    __HAL_RCC_SPI1_CLK_ENABLE();\r\n\r\n    __HAL_RCC_GPIOA_CLK_ENABLE();\r\n    __HAL_RCC_GPIOB_CLK_ENABLE();\r\n    /**SPI1 GPIO Configuration\r\n    PA5     ------> SPI1_SCK\r\n    PA6     ------> SPI1_MISO\r\n    PB5     ------> SPI1_MOSI\r\n    */\r\n    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\r\n    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;\r\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\r\n\r\n    GPIO_InitStruct.Pin = GPIO_PIN_5;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\r\n    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;\r\n    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\r\n\r\n  /* USER CODE BEGIN SPI1_MspInit 1 */\r\n\r\n  /* USER CODE END SPI1_MspInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief SPI MSP De-Initialization\r\n* This function freeze the hardware resources used in this example\r\n* @param hspi: SPI handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)\r\n{\r\n  if(hspi->Instance==SPI1)\r\n  {\r\n  /* USER CODE BEGIN SPI1_MspDeInit 0 */\r\n\r\n  /* USER CODE END SPI1_MspDeInit 0 */\r\n    /* Peripheral clock disable */\r\n    __HAL_RCC_SPI1_CLK_DISABLE();\r\n\r\n    /**SPI1 GPIO Configuration\r\n    PA5     ------> SPI1_SCK\r\n    PA6     ------> SPI1_MISO\r\n    PB5     ------> SPI1_MOSI\r\n    */\r\n    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_5|GPIO_PIN_6);\r\n\r\n    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_5);\r\n\r\n  /* USER CODE BEGIN SPI1_MspDeInit 1 */\r\n\r\n  /* USER CODE END SPI1_MspDeInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief TIM_Base MSP Initialization\r\n* This function configures the hardware resources used in this example\r\n* @param htim_base: TIM_Base handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)\r\n{\r\n  if(htim_base->Instance==TIM13)\r\n  {\r\n  /* USER CODE BEGIN TIM13_MspInit 0 */\r\n\r\n  /* USER CODE END TIM13_MspInit 0 */\r\n    /* Peripheral clock enable */\r\n    __HAL_RCC_TIM13_CLK_ENABLE();\r\n    /* TIM13 interrupt Init */\r\n    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 0, 0);\r\n    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);\r\n  /* USER CODE BEGIN TIM13_MspInit 1 */\r\n\r\n  /* USER CODE END TIM13_MspInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief TIM_Base MSP De-Initialization\r\n* This function freeze the hardware resources used in this example\r\n* @param htim_base: TIM_Base handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* htim_base)\r\n{\r\n  if(htim_base->Instance==TIM13)\r\n  {\r\n  /* USER CODE BEGIN TIM13_MspDeInit 0 */\r\n\r\n  /* USER CODE END TIM13_MspDeInit 0 */\r\n    /* Peripheral clock disable */\r\n    __HAL_RCC_TIM13_CLK_DISABLE();\r\n\r\n    /* TIM13 interrupt DeInit */\r\n    HAL_NVIC_DisableIRQ(TIM8_UP_TIM13_IRQn);\r\n  /* USER CODE BEGIN TIM13_MspDeInit 1 */\r\n\r\n  /* USER CODE END TIM13_MspDeInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief UART MSP Initialization\r\n* This function configures the hardware resources used in this example\r\n* @param huart: UART handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_UART_MspInit(UART_HandleTypeDef* huart)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\r\n  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};\r\n  if(huart->Instance==USART3)\r\n  {\r\n  /* USER CODE BEGIN USART3_MspInit 0 */\r\n\r\n  /* USER CODE END USART3_MspInit 0 */\r\n  /** Initializes the peripherals clock\r\n  */\r\n    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;\r\n    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;\r\n    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)\r\n    {\r\n      Error_Handler();\r\n    }\r\n\r\n    /* Peripheral clock enable */\r\n    __HAL_RCC_USART3_CLK_ENABLE();\r\n\r\n    __HAL_RCC_GPIOD_CLK_ENABLE();\r\n    /**USART3 GPIO Configuration\r\n    PD8     ------> USART3_TX\r\n    PD9     ------> USART3_RX\r\n    */\r\n    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\r\n    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;\r\n    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);\r\n\r\n  /* USER CODE BEGIN USART3_MspInit 1 */\r\n\r\n  /* USER CODE END USART3_MspInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief UART MSP De-Initialization\r\n* This function freeze the hardware resources used in this example\r\n* @param huart: UART handle pointer\r\n* @retval None\r\n*/\r\nvoid HAL_UART_MspDeInit(UART_HandleTypeDef* huart)\r\n{\r\n  if(huart->Instance==USART3)\r\n  {\r\n  /* USER CODE BEGIN USART3_MspDeInit 0 */\r\n\r\n  /* USER CODE END USART3_MspDeInit 0 */\r\n    /* Peripheral clock disable */\r\n    __HAL_RCC_USART3_CLK_DISABLE();\r\n\r\n    /**USART3 GPIO Configuration\r\n    PD8     ------> USART3_TX\r\n    PD9     ------> USART3_RX\r\n    */\r\n    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9);\r\n\r\n  /* USER CODE BEGIN USART3_MspDeInit 1 */\r\n\r\n  /* USER CODE END USART3_MspDeInit 1 */\r\n  }\r\n\r\n}\r\n\r\n/* USER CODE BEGIN 1 */\r\n\r\n/* USER CODE END 1 */\r\n\r\n"},{"name":"stm32h7xx_hal_pwr.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_pwr.c\r\n  * @author  MCD Application Team\r\n  * @brief   PWR HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Power Controller (PWR) peripheral:\r\n  *           + Initialization and de-initialization functions.\r\n  *           + Peripheral Control functions.\r\n  *           + Interrupt Handling functions.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### PWR peripheral overview #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) The Power control (PWR) provides an overview of the supply architecture\r\n       for the different power domains and of the supply configuration\r\n       controller.\r\n       In the H7 family, the number of power domains is different between\r\n       device lines. This difference is due to characteristics of each device.\r\n\r\n   (#) Domain architecture overview for the different H7 lines:\r\n      (+) Dual core lines are STM32H745, STM32H747, STM32H755 and STM32H757.\r\n          These devices have 3 power domains (D1, D2 and D3).\r\n          The domain D1 contains a CPU (Cortex-M7), a Flash memory and some\r\n          peripherals. The D2 domain contains peripherals and a CPU\r\n          (Cortex-M4). The D3 domain contains the system control, I/O logic\r\n          and low-power peripherals.\r\n      (+) STM32H72x, STM32H73x, STM32H742, STM32H743, STM32H750 and STM32H753 \r\n          devices have 3 power domains (D1, D2 and D3).\r\n          The domain D1 contains a CPU (Cortex-M7), a Flash memory and some\r\n          peripherals. The D2 domain contains peripherals. The D3 domains\r\n          contains the system control, I/O logic and low-power peripherals.\r\n      (+) STM32H7Axxx and STM32H7Bxxx devices have 2 power domains (CD and SRD).\r\n          The core domain (CD) contains a CPU (Cortex-M7), a Flash\r\n          memory and peripherals. The SmartRun domain contains the system\r\n          control, I/O logic and low-power peripherals.\r\n\r\n   (#) Every entity have low power mode as described below :\r\n   (#) The CPU low power modes are :\r\n      (+) CPU CRUN.\r\n      (+) CPU CSLEEP.\r\n      (+) CPU CSTOP.\r\n   (#) The domain low power modes are :\r\n      (+) DRUN.\r\n      (+) DSTOP.\r\n      (+) DSTANDBY.\r\n   (#) The SYSTEM low power modes are :\r\n      (+) RUN* : The Run* mode is entered after a POR reset and a wakeup from\r\n                 Standby. In Run* mode, the performance is limited and the\r\n                 system supply configuration shall be programmed. The system\r\n                 enters Run mode only when the ACTVOSRDY bit in PWR control\r\n                 status register 1 (PWR_CSR1) is set to 1.\r\n      (+) RUN.\r\n      (+) STOP.\r\n      (+) STANDBY.\r\n\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) Power management peripheral is active by default at startup level in\r\n       STM32h7xx lines.\r\n\r\n   (#) Call HAL_PWR_EnableBkUpAccess() and HAL_PWR_DisableBkUpAccess() functions\r\n       to enable/disable access to the backup domain (RTC registers, RTC backup\r\n       data registers and backup SRAM).\r\n\r\n   (#) Call HAL_PWR_ConfigPVD() after setting parameters to be configured (event\r\n       mode and voltage threshold) in order to set up the Power Voltage Detector,\r\n       then use HAL_PWR_EnablePVD() and  HAL_PWR_DisablePVD() functions to start\r\n       and stop the PVD detection.\r\n       (+) PVD level could be one of the following values :\r\n             (++) 1V95\r\n             (++) 2V1\r\n             (++) 2V25\r\n             (++) 2V4\r\n             (++) 2V55\r\n             (++) 2V7\r\n             (++) 2V85\r\n             (++) External voltage level\r\n\r\n   (#) Call HAL_PWR_EnableWakeUpPin() and HAL_PWR_DisableWakeUpPin() functions\r\n       with the right parameter to configure the wake up pin polarity (Low or\r\n       High) and to enable and disable it.\r\n\r\n   (#) Call HAL_PWR_EnterSLEEPMode() function to enter the current Core in SLEEP\r\n       mode. Wake-up from SLEEP mode could be following to an event or an\r\n       interrupt according to low power mode intrinsic request called (__WFI()\r\n       or __WFE()).\r\n       Please ensure to clear all CPU pending events by calling\r\n       HAL_PWREx_ClearPendingEvent() function when trying to enter the Cortex-Mx\r\n       in SLEEP mode with __WFE() entry.\r\n\r\n   (#) Call HAL_PWR_EnterSTOPMode() function to enter the whole system to Stop 0\r\n       mode for single core devices. For dual core devices, this API will enter\r\n       the domain (containing Cortex-Mx that executing this function) in DSTOP\r\n       mode. According to the used parameter, user could select the regulator to\r\n       be kept actif in low power mode and wake-up event type.\r\n       Please ensure to clear all CPU pending events by calling\r\n       HAL_PWREx_ClearPendingEvent() function when trying to enter the Cortex-Mx\r\n       in CSTOP mode with __WFE() entry.\r\n\r\n   (#) Call HAL_PWR_EnterSTANDBYMode() function to enter the whole system in\r\n       STANDBY mode for single core devices. For dual core devices, this API\r\n       will enter the domain (containing Cortex-Mx that executing this function)\r\n       in DSTANDBY mode.\r\n\r\n   (#) Call HAL_PWR_EnableSleepOnExit() and HAL_PWR_DisableSleepOnExit() APIs to\r\n       enable and disable the Cortex-Mx re-entring in SLEEP mode after an\r\n       interruption handling is over.\r\n\r\n   (#) Call HAL_PWR_EnableSEVOnPend() and HAL_PWR_DisableSEVOnPend() functions\r\n       to configure the Cortex-Mx to wake-up after any pending event / interrupt\r\n       even if it's disabled or has insufficient priority to cause exception\r\n       entry.\r\n\r\n   (#) Call HAL_PWR_PVD_IRQHandler() function to handle the PWR PVD interrupt\r\n       request.\r\n\r\n     *** PWR HAL driver macros list ***\r\n     =============================================\r\n     [..]\r\n       Below the list of most used macros in PWR HAL driver.\r\n\r\n      (+) __HAL_PWR_VOLTAGESCALING_CONFIG() : Configure the main internal\r\n                                              regulator output voltage.\r\n      (+) __HAL_PWR_GET_FLAG()              : Get the PWR pending flags.\r\n      (+) __HAL_PWR_CLEAR_FLAG()            : Clear the PWR pending flags.\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR PWR\r\n  * @brief PWR HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PWR_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n\r\n/** @addtogroup PWR_Private_Constants PWR Private Constants\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask\r\n  * @{\r\n  */\r\n#if !defined (DUAL_CORE)\r\n#define PVD_MODE_IT              (0x00010000U)\r\n#define PVD_MODE_EVT             (0x00020000U)\r\n#endif /* !defined (DUAL_CORE) */\r\n\r\n#define PVD_RISING_EDGE          (0x00000001U)\r\n#define PVD_FALLING_EDGE         (0x00000002U)\r\n#define PVD_RISING_FALLING_EDGE  (0x00000003U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/** @defgroup PWR_Exported_Functions PWR Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group1 Initialization and De-Initialization Functions\r\n  * @brief    Initialization and De-Initialization functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and De-Initialization Functions #####\r\n ===============================================================================\r\n    [..]\r\n      This section provides functions allowing to deinitialize power peripheral.\r\n\r\n    [..]\r\n      After system reset, the backup domain (RTC registers, RTC backup data\r\n      registers and backup SRAM) is protected against possible unwanted write\r\n      accesses.\r\n      The HAL_PWR_EnableBkUpAccess() function enables the access to the backup\r\n      domain.\r\n      The HAL_PWR_DisableBkUpAccess() function disables the access to the backup\r\n      domain.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Deinitialize the HAL PWR peripheral registers to their default reset\r\n  *         values.\r\n  * @note   This functionality is not available in this product.\r\n  *         The prototype is kept just to maintain compatibility with other\r\n  *         products.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_DeInit (void)\r\n{\r\n}\r\n\r\n/**\r\n  * @brief  Enable access to the backup domain (RTC registers, RTC backup data\r\n  *         registers and backup SRAM).\r\n  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the\r\n  *         Backup Domain Access should be kept enabled.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnableBkUpAccess (void)\r\n{\r\n  /* Enable access to RTC and backup registers */\r\n  SET_BIT (PWR->CR1, PWR_CR1_DBP);\r\n}\r\n\r\n/**\r\n  * @brief  Disable access to the backup domain (RTC registers, RTC backup data\r\n  *         registers and backup SRAM).\r\n  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the\r\n  *         Backup Domain Access should be kept enabled.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_DisableBkUpAccess (void)\r\n{\r\n  /* Disable access to RTC and backup registers */\r\n  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group2 Peripheral Control Functions\r\n  *  @brief   Power Control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                 ##### Peripheral Control Functions #####\r\n ===============================================================================\r\n    [..]\r\n      This section provides functions allowing to control power peripheral.\r\n\r\n    *** PVD configuration ***\r\n    =========================\r\n    [..]\r\n      (+) The PVD is used to monitor the VDD power supply by comparing it to a\r\n          threshold selected by the PVD Level (PLS[7:0] bits in the PWR_CR1\r\n          register).\r\n\r\n      (+) A PVDO flag is available to indicate if VDD is higher or lower\r\n          than the PVD threshold. This event is internally connected to the EXTI\r\n          line 16 to generate an interrupt if enabled.\r\n          It is configurable through __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.\r\n\r\n      (+) The PVD is stopped in STANDBY mode.\r\n\r\n    *** Wake-up pin configuration ***\r\n    =================================\r\n    [..]\r\n      (+) Wake-up pin is used to wake up the system from STANDBY mode.\r\n          The pin pull is configurable through the WKUPEPR register to be in\r\n          No-pull, Pull-up and Pull-down.\r\n          The pin polarity is configurable through the WKUPEPR register to be\r\n          active on rising or falling edges.\r\n\r\n      (+) There are up to six Wake-up pin in the STM32H7 devices family.\r\n\r\n    *** Low Power modes configuration ***\r\n    =====================================\r\n    [..]\r\n     The device present 3 principles low-power modes features:\r\n      (+) SLEEP mode   : Cortex-Mx is stopped and all PWR domains are remaining\r\n                         active (Powered and Clocked).\r\n\r\n      (+) STOP mode    : Cortex-Mx is stopped, clocks are stopped and the\r\n                         regulator is running. The Main regulator or the LP\r\n                         regulator could be selected.\r\n\r\n      (+) STANDBY mode : All PWR domains enter DSTANDBY mode and the VCORE\r\n                         supply regulator is powered off.\r\n\r\n   *** SLEEP mode ***\r\n   ==================\r\n    [..]\r\n      (+) Entry:\r\n        The SLEEP mode is entered by using the HAL_PWR_EnterSLEEPMode(Regulator,\r\n        SLEEPEntry) function.\r\n\r\n          (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction.\r\n          (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction.\r\n\r\n      -@@- The Regulator parameter is not used for the STM32H7 family\r\n              and is kept as parameter just to maintain compatibility with the\r\n              lower power families (STM32L).\r\n\r\n      (+) Exit:\r\n        Any peripheral interrupt acknowledged by the nested vectored interrupt\r\n        controller (NVIC) can wake up the device from SLEEP mode.\r\n\r\n   *** STOP mode ***\r\n   =================\r\n    [..]\r\n      In system STOP mode, all clocks in the 1.2V domain are stopped, the PLL,\r\n      the HSI, and the HSE RC oscillators are disabled. Internal SRAM and\r\n      register contents are preserved.\r\n      The voltage regulator can be configured either in normal or low-power mode.\r\n      To minimize the consumption in STOP mode, FLASH can be powered off before\r\n      entering the STOP mode using the HAL_PWREx_EnableFlashPowerDown() function.\r\n      It can be switched on again by software after exiting the STOP mode using\r\n      the HAL_PWREx_DisableFlashPowerDown() function.\r\n\r\n      (+) Entry:\r\n         The STOP mode is entered using the HAL_PWR_EnterSTOPMode(Regulator,\r\n         STOPEntry) function with:\r\n\r\n         (++) Regulator:\r\n          (+++) PWR_MAINREGULATOR_ON: Main regulator ON.\r\n          (+++) PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.\r\n\r\n         (++) STOPEntry:\r\n          (+++) PWR_STOPENTRY_WFI: enter STOP mode with WFI instruction.\r\n          (+++) PWR_STOPENTRY_WFE: enter STOP mode with WFE instruction.\r\n\r\n      (+) Exit:\r\n         Any EXTI Line (Internal or External) configured in Interrupt/Event mode.\r\n\r\n   *** STANDBY mode ***\r\n   ====================\r\n    [..]\r\n    (+)\r\n      The system STANDBY mode allows to achieve the lowest power consumption.\r\n      It is based on the Cortex-Mx deep SLEEP mode, with the voltage regulator\r\n      disabled. The system is consequently powered off. The PLL, the HSI\r\n      oscillator and the HSE oscillator are also switched off. SRAM and register\r\n      contents are lost except for the RTC registers, RTC backup registers,\r\n      backup SRAM and standby circuitry.\r\n\r\n    [..]\r\n      The voltage regulator is OFF.\r\n\r\n      (++) Entry:\r\n        (+++) The STANDBY mode is entered using the HAL_PWR_EnterSTANDBYMode()\r\n              function.\r\n\r\n      (++) Exit:\r\n        (+++) WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B),\r\n              RTC wakeup, tamper event, time stamp event, external reset in NRST\r\n              pin, IWDG reset.\r\n\r\n   *** Auto-wakeup (AWU) from low-power mode ***\r\n   =============================================\r\n    [..]\r\n     (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an\r\n         RTC Wakeup event, a tamper event or a time-stamp event, without\r\n         depending on an external interrupt (Auto-wakeup mode).\r\n\r\n     (+) RTC auto-wakeup (AWU) from the STOP and STANDBY modes\r\n\r\n       (++) To wake up from the STOP mode with an RTC alarm event, it is\r\n            necessary to configure the RTC to generate the RTC alarm using the\r\n            HAL_RTC_SetAlarm_IT() function.\r\n\r\n       (++) To wake up from the STOP mode with an RTC Tamper or time stamp event,\r\n            it is necessary to configure the RTC to detect the tamper or time\r\n            stamp event using the HAL_RTCEx_SetTimeStamp_IT() or\r\n            HAL_RTCEx_SetTamper_IT() functions.\r\n\r\n       (++) To wake up from the STOP mode with an RTC WakeUp event, it is\r\n            necessary to configure the RTC to generate the RTC WakeUp event\r\n            using the HAL_RTCEx_SetWakeUpTimer_IT() function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configure the event mode and the voltage threshold detected by the\r\n  *         Programmable Voltage Detector(PVD).\r\n  * @param  sConfigPVD : Pointer to an PWR_PVDTypeDef structure that contains\r\n  *                      the configuration information for the PVD.\r\n  * @note   Refer to the electrical characteristics of your device datasheet for\r\n  *         more details about the voltage threshold corresponding to each\r\n  *         detection level.\r\n  * @note   For dual core devices, please ensure to configure the EXTI lines for\r\n  *         the different Cortex-Mx through PWR_Exported_Macro provided by this\r\n  *         driver. All combination are allowed: wake up only Cortex-M7, wake up\r\n  *         only Cortex-M4 or wake up Cortex-M7 and Cortex-M4.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)\r\n{\r\n  /* Check the PVD configuration parameter */\r\n  if (sConfigPVD == NULL)\r\n  {\r\n    return;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));\r\n  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));\r\n\r\n  /* Set PLS[7:5] bits according to PVDLevel value */\r\n  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);\r\n\r\n  /* Clear previous config */\r\n#if !defined (DUAL_CORE)\r\n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_IT ();\r\n#endif /* !defined (DUAL_CORE) */\r\n\r\n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();\r\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();\r\n\r\n#if !defined (DUAL_CORE)\r\n  /* Interrupt mode configuration */\r\n  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_IT ();\r\n  }\r\n\r\n  /* Event mode configuration */\r\n  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();\r\n  }\r\n#endif /* !defined (DUAL_CORE) */\r\n\r\n  /* Rising edge configuration */\r\n  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();\r\n  }\r\n\r\n  /* Falling edge configuration */\r\n  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\r\n  {\r\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Enable the Programmable Voltage Detector (PVD).\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnablePVD (void)\r\n{\r\n  /* Enable the power voltage detector */\r\n  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);\r\n}\r\n\r\n/**\r\n  * @brief Disable the Programmable Voltage Detector (PVD).\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_DisablePVD (void)\r\n{\r\n  /* Disable the power voltage detector */\r\n  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the WakeUp PINx functionality.\r\n  * @param  WakeUpPinPolarity : Specifies which Wake-Up pin to enable.\r\n  *          This parameter can be one of the following legacy values, which\r\n  *          sets the default (rising edge):\r\n  *            @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3,\r\n  *                 PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6.\r\n  *          or one of the following values where the user can explicitly states\r\n  *          the enabled pin and the chosen polarity:\r\n  *            @arg PWR_WAKEUP_PIN1_HIGH, PWR_WAKEUP_PIN1_LOW,\r\n  *                 PWR_WAKEUP_PIN2_HIGH, PWR_WAKEUP_PIN2_LOW,\r\n  *                 PWR_WAKEUP_PIN3_HIGH, PWR_WAKEUP_PIN3_LOW,\r\n  *                 PWR_WAKEUP_PIN4_HIGH, PWR_WAKEUP_PIN4_LOW,\r\n  *                 PWR_WAKEUP_PIN5_HIGH, PWR_WAKEUP_PIN5_LOW,\r\n  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.\r\n  * @note   PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.\r\n  * @note   The PWR_WAKEUP_PIN3_HIGH, PWR_WAKEUP_PIN3_LOW, PWR_WAKEUP_PIN5_HIGH\r\n  *         and PWR_WAKEUP_PIN5_LOW are available only for devices that includes\r\n  *         GPIOI port.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnableWakeUpPin (uint32_t WakeUpPinPolarity)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinPolarity));\r\n\r\n  /*\r\n     Enable and Specify the Wake-Up pin polarity and the pull configuration\r\n     for the event detection (rising or falling edge).\r\n  */\r\n  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);\r\n}\r\n\r\n/**\r\n  * @brief  Disable the WakeUp PINx functionality.\r\n  * @param  WakeUpPinx : Specifies the Power Wake-Up pin to disable.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3,\r\n  *                 PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6,\r\n  *                 PWR_WAKEUP_PIN1_HIGH, PWR_WAKEUP_PIN1_LOW,\r\n  *                 PWR_WAKEUP_PIN2_HIGH, PWR_WAKEUP_PIN2_LOW,\r\n  *                 PWR_WAKEUP_PIN3_HIGH, PWR_WAKEUP_PIN3_LOW,\r\n  *                 PWR_WAKEUP_PIN4_HIGH, PWR_WAKEUP_PIN4_LOW,\r\n  *                 PWR_WAKEUP_PIN5_HIGH, PWR_WAKEUP_PIN5_LOW,\r\n  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.\r\n  * @note   The PWR_WAKEUP_PIN3_HIGH, PWR_WAKEUP_PIN3_LOW, PWR_WAKEUP_PIN5_HIGH\r\n  *         and PWR_WAKEUP_PIN5_LOW are available only for devices that includes\r\n  *         GPIOI port.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_DisableWakeUpPin (uint32_t WakeUpPinx)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));\r\n\r\n  /* Disable the wake up pin selected */\r\n  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));\r\n}\r\n\r\n/**\r\n  * @brief  Enter the current core in SLEEP mode (CSLEEP).\r\n  * @param  Regulator : Specifies the regulator state in SLEEP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON     : SLEEP mode with regulator ON.\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON : SLEEP mode with low power\r\n  *                                           regulator ON.\r\n  * @note   This parameter is not used for the STM32H7 family and is kept as\r\n  *         parameter just to maintain compatibility with the lower power\r\n  *         families.\r\n  * @param  SLEEPEntry : Specifies if SLEEP mode is entered with WFI or WFE\r\n  *                      intrinsic instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SLEEPENTRY_WFI : enter SLEEP mode with WFI instruction.\r\n  *            @arg PWR_SLEEPENTRY_WFE : enter SLEEP mode with WFE instruction.\r\n  * @note   Ensure to clear pending events before calling this API through\r\n  *         HAL_PWREx_ClearPendingEvent() when the SLEEP entry is WFE.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnterSLEEPMode (uint32_t Regulator, uint8_t SLEEPEntry)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_REGULATOR (Regulator));\r\n  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));\r\n\r\n  /* Clear SLEEPDEEP bit of Cortex System Control Register */\r\n  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n  /* Select SLEEP mode entry */\r\n  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)\r\n  {\r\n    /* Request Wait For Interrupt */\r\n    __WFI ();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __WFE ();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enter STOP mode.\r\n  * @note   For single core devices, this API will enter the system in STOP mode\r\n  *         with all domains in DSTOP, if RUN_D3/RUN_SRD bit in CPUCR register is\r\n  *         cleared.\r\n  *         For dual core devices, this API will enter the domain (containing\r\n  *         Cortex-Mx that executing this function) in DSTOP mode. If all\r\n  *         Cortex-Mx domains are in DSTOP and RUN_D3 bit in CPUCR register is\r\n  *         cleared, all the system will enter in STOP mode.\r\n  * @param  Regulator : Specifies the regulator state in STOP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON     : STOP mode with regulator ON.\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON : STOP mode with low power\r\n  *                                            regulator ON.\r\n  * @param  STOPEntry : Specifies if STOP mode in entered with WFI or WFE\r\n  *                     intrinsic instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_STOPENTRY_WFI : Enter STOP mode with WFI instruction.\r\n  *            @arg PWR_STOPENTRY_WFE : Enter STOP mode with WFE instruction.\r\n  * @note   In System STOP mode, all I/O pins keep the same state as in Run mode.\r\n  * @note   When exiting System STOP mode by issuing an interrupt or a wakeup\r\n  *         event, the HSI RC oscillator is selected as default system wakeup\r\n  *         clock.\r\n  * @note   In System STOP mode, when the voltage regulator operates in low\r\n  *         power mode, an additional startup delay is incurred when the system\r\n  *         is waking up. By keeping the internal regulator ON during STOP mode,\r\n  *         the consumption is higher although the startup time is reduced.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_REGULATOR (Regulator));\r\n  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));\r\n\r\n  /* Select the regulator state in STOP mode */\r\n  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);\r\n\r\n  /* Configure the PWR mode for the different Domains */\r\n#if defined (DUAL_CORE)\r\n  /* Check CPU ID */\r\n  if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n  {\r\n    /* Keep DSTOP mode when Cortex-M7 enters DEEP-SLEEP */\r\n    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));\r\n  }\r\n  else\r\n  {\r\n    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */\r\n    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));\r\n  }\r\n#else /* Single core devices */\r\n  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */\r\n  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));\r\n\r\n#if defined (PWR_CPUCR_PDDS_D2)\r\n  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */\r\n  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);\r\n#endif /* PWR_CPUCR_PDDS_D2 */\r\n#endif /* defined (DUAL_CORE) */\r\n\r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n  /* Ensure that all instructions are done before entering STOP mode */\r\n  __DSB ();\r\n  __ISB ();\r\n\r\n  /* Select STOP mode entry */\r\n  if (STOPEntry == PWR_STOPENTRY_WFI)\r\n  {\r\n    /* Request Wait For Interrupt */\r\n    __WFI ();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __WFE ();\r\n  }\r\n\r\n  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */\r\n  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n}\r\n\r\n/**\r\n  * @brief  Enter STANDBY mode.\r\n  * @note   For single core devices, this API will enter the system in STANDBY\r\n  *         mode with all domains in DSTANDBY, if RUN_D3/RUN_SRD bit in CPUCR\r\n  *         register is cleared.\r\n  *         For dual core devices, this API will enter the domain (containing\r\n  *         Cortex-Mx that executing this function) in DSTANDBY mode. If all\r\n  *         Cortex-Mx domains are in DSTANDBY and RUN_D3 bit in CPUCR register\r\n  *         is cleared, all the system will enter in STANDBY mode.\r\n  * @note   The system enters Standby mode only when all domains are in DSTANDBY.\r\n  * @note   When the System exit STANDBY mode by issuing an interrupt or a\r\n  *         wakeup event, the HSI RC oscillator is selected as system clock.\r\n  * @note   It is recommended to disable all regulators before entring STANDBY\r\n  *         mode for power consumption saving purpose.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnterSTANDBYMode (void)\r\n{\r\n  /* Configure the PWR mode for the different Domains */\r\n#if defined (DUAL_CORE)\r\n  /* Check CPU ID */\r\n  if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n  {\r\n    /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */\r\n    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));\r\n    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D1 | PWR_CPU2CR_PDDS_D3));\r\n  }\r\n  else\r\n  {\r\n    /* Enter DSTANDBY mode when Cortex-M4 enters DEEP-SLEEP */\r\n    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));\r\n    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));\r\n  }\r\n#else /* Single core devices */\r\n  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */\r\n  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));\r\n\r\n#if defined (PWR_CPUCR_PDDS_D2)\r\n  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */\r\n  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);\r\n#endif /* PWR_CPUCR_PDDS_D2 */\r\n#endif /* defined (DUAL_CORE) */\r\n\r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n  /* Ensure that all instructions are done before entering STOP mode */\r\n  __DSB ();\r\n  __ISB ();\r\n\r\n  /* This option is used to ensure that store operations are completed */\r\n#if defined (__CC_ARM)\r\n  __force_stores();\r\n#endif /* defined (__CC_ARM) */\r\n\r\n  /* Request Wait For Interrupt */\r\n  __WFI ();\r\n}\r\n\r\n/**\r\n  * @brief  Indicate Sleep-On-Exit feature when returning from Handler mode to\r\n  *         Thread mode.\r\n  * @note   Set SLEEPONEXIT bit of SCR register. When this bit is set, the\r\n  *         processor re-enters SLEEP mode when an interruption handling is over.\r\n  *         Setting this bit is useful when the processor is expected to run\r\n  *         only on interruptions handling.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnableSleepOnExit (void)\r\n{\r\n  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */\r\n  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);\r\n}\r\n\r\n/**\r\n  * @brief  Disable Sleep-On-Exit feature when returning from Handler mode to\r\n  *         Thread mode.\r\n  * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the\r\n  *         processor re-enters SLEEP mode when an interruption handling is over.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWR_DisableSleepOnExit (void)\r\n{\r\n  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */\r\n  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);\r\n}\r\n\r\n/**\r\n  * @brief  Enable CORTEX SEVONPEND feature.\r\n  * @note   Sets SEVONPEND bit of SCR register. When this bit is set, any\r\n  *         pending event / interrupt even if it's disabled or has insufficient\r\n  *         priority to cause exception entry wakes up the Cortex-Mx.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_EnableSEVOnPend (void)\r\n{\r\n  /* Set SEVONPEND bit of Cortex-Mx System Control Register */\r\n  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);\r\n}\r\n\r\n/**\r\n  * @brief  Disable CORTEX SEVONPEND feature.\r\n  * @note   Resets SEVONPEND bit of SCR register. When this bit is reset, only\r\n  *         enabled pending causes exception entry wakes up the Cortex-Mx.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_DisableSEVOnPend (void)\r\n{\r\n  /* Clear SEVONPEND bit of Cortex System Control Register */\r\n  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWR_Exported_Functions_Group3 Interrupt Handling Functions\r\n  *  @brief   Interrupt Handling functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                    ##### Interrupt Handling Functions #####\r\n ===============================================================================\r\n    [..]\r\n    This section provides functions allowing to handle the PVD pending\r\n    interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  This function handles the PWR PVD interrupt request.\r\n  * @note   This API should be called under the PVD_AVD_IRQHandler().\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWR_PVD_IRQHandler (void)\r\n{\r\n#if defined (DUAL_CORE)\r\n  /* Check Cortex-Mx ID */\r\n  if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n  {\r\n    /* Check PWR EXTI D1 flag */\r\n    if(__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)\r\n    {\r\n      /* Clear PWR EXTI D1 pending bit */\r\n      __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();\r\n\r\n      /* PWR PVD interrupt user callback */\r\n      HAL_PWR_PVDCallback ();\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Check PWR EXTI D2 flag */\r\n    if (__HAL_PWR_PVD_EXTID2_GET_FLAG () != 0U)\r\n    {\r\n      /* Clear PWR EXTI D2 pending bit */\r\n      __HAL_PWR_PVD_EXTID2_CLEAR_FLAG ();\r\n\r\n      /* PWR PVD interrupt user callback */\r\n      HAL_PWR_PVDCallback ();\r\n    }\r\n  }\r\n#else /* Single core devices */\r\n  /* PVD EXTI line interrupt detected */\r\n  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)\r\n  {\r\n    /* Clear PWR EXTI pending bit */\r\n    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();\r\n\r\n    /* PWR PVD interrupt user callback */\r\n    HAL_PWR_PVDCallback ();\r\n  }\r\n#endif /* defined (DUAL_CORE) */\r\n}\r\n\r\n/**\r\n  * @brief  PWR PVD interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWR_PVDCallback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWR_PVDCallback can be implemented in the user file\r\n  */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_PWR_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_pwr_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_pwr_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended PWR HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of PWR extension peripheral:\r\n  *           + Peripheral Extended features functions\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n  [..]\r\n   (#) Call HAL_PWREx_ConfigSupply() function to configure the regulator supply\r\n       with the following different setups according to hardware (support SMPS):\r\n       (+) PWR_DIRECT_SMPS_SUPPLY\r\n       (+) PWR_SMPS_1V8_SUPPLIES_LDO\r\n       (+) PWR_SMPS_2V5_SUPPLIES_LDO\r\n       (+) PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO\r\n       (+) PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO\r\n       (+) PWR_SMPS_1V8_SUPPLIES_EXT\r\n       (+) PWR_SMPS_2V5_SUPPLIES_EXT\r\n       (+) PWR_LDO_SUPPLY\r\n       (+) PWR_EXTERNAL_SOURCE_SUPPLY\r\n\r\n   (#) Call HAL_PWREx_GetSupplyConfig() function to get the current supply setup.\r\n\r\n   (#) Call HAL_PWREx_ControlVoltageScaling() function to configure the main\r\n       internal regulator output voltage. The voltage scaling could be one of\r\n       the following scales :\r\n       (+) PWR_REGULATOR_VOLTAGE_SCALE0\r\n       (+) PWR_REGULATOR_VOLTAGE_SCALE1\r\n       (+) PWR_REGULATOR_VOLTAGE_SCALE2\r\n       (+) PWR_REGULATOR_VOLTAGE_SCALE3\r\n\r\n   (#) Call HAL_PWREx_GetVoltageRange() function to get the current output\r\n       voltage applied to the main regulator.\r\n\r\n   (#) Call HAL_PWREx_ControlStopModeVoltageScaling() function to configure the\r\n       main internal regulator output voltage in STOP mode. The voltage scaling\r\n       in STOP mode could be one of the following scales :\r\n       (+) PWR_REGULATOR_SVOS_SCALE3\r\n       (+) PWR_REGULATOR_SVOS_SCALE4\r\n       (+) PWR_REGULATOR_SVOS_SCALE5\r\n\r\n   (#) Call HAL_PWREx_GetStopModeVoltageRange() function to get the current\r\n       output voltage applied to the main regulator in STOP mode.\r\n\r\n   (#) Call HAL_PWREx_EnterSTOP2Mode() function to enter the system in STOP mode\r\n       with core domain in D2STOP mode. This API is used only for STM32H7Axxx\r\n       and STM32H7Bxxx devices.\r\n       Please ensure to clear all CPU pending events by calling\r\n       HAL_PWREx_ClearPendingEvent() function when trying to enter the Cortex-Mx\r\n       in DEEP-SLEEP mode with __WFE() entry.\r\n\r\n   (#) Call HAL_PWREx_EnterSTOPMode() function to enter the selected domain in\r\n       DSTOP mode. Call this API with all available power domains to enter the\r\n       system in STOP mode.\r\n       Please ensure to clear all CPU pending events by calling\r\n       HAL_PWREx_ClearPendingEvent() function when trying to enter the Cortex-Mx\r\n       in DEEP-SLEEP mode with __WFE() entry.\r\n\r\n   (#) Call HAL_PWREx_ClearPendingEvent() function always before entring the\r\n       Cortex-Mx in any low power mode (SLEEP/DEEP-SLEEP) using WFE entry.\r\n\r\n   (#) Call HAL_PWREx_EnterSTANDBYMode() function to enter the selected domain\r\n       in DSTANDBY mode. Call this API with all available power domains to enter\r\n       the system in STANDBY mode.\r\n\r\n   (#) Call HAL_PWREx_ConfigD3Domain() function to setup the D3/SRD domain state\r\n       (RUN/STOP) when the system enter to low power mode.\r\n\r\n   (#) Call HAL_PWREx_ClearDomainFlags() function to clear the CPU flags for the\r\n       selected power domain. This API is used only for dual core devices.\r\n\r\n   (#) Call HAL_PWREx_HoldCore() and HAL_PWREx_ReleaseCore() functions to hold\r\n       and release the selected CPU and and their domain peripherals when\r\n       exiting STOP mode. These APIs are used only for dual core devices.\r\n\r\n   (#) Call HAL_PWREx_EnableFlashPowerDown() and\r\n       HAL_PWREx_DisableFlashPowerDown() functions to enable and disable the\r\n       Flash Power Down in STOP mode.\r\n\r\n   (#) Call HAL_PWREx_EnableMemoryShutOff() and\r\n       HAL_PWREx_DisableMemoryShutOff() functions to enable and disable the\r\n       memory block shut-off in DStop or DStop2. These APIs are used only for\r\n       STM32H7Axxx and STM32H7Bxxx lines.\r\n\r\n   (#) Call HAL_PWREx_EnableWakeUpPin() and HAL_PWREx_DisableWakeUpPin()\r\n       functions to enable and disable the Wake-up pin functionality for\r\n       the selected pin.\r\n\r\n   (#) Call HAL_PWREx_GetWakeupFlag() and HAL_PWREx_ClearWakeupFlag()\r\n       functions to manage wake-up flag for the selected pin.\r\n\r\n   (#) Call HAL_PWREx_WAKEUP_PIN_IRQHandler() function to handle all wake-up\r\n       pins interrupts.\r\n\r\n   (#) Call HAL_PWREx_EnableBkUpReg() and HAL_PWREx_DisableBkUpReg() functions\r\n       to enable and disable the backup domain regulator.\r\n\r\n   (#) Call HAL_PWREx_EnableUSBReg(), HAL_PWREx_DisableUSBReg(),\r\n       HAL_PWREx_EnableUSBVoltageDetector() and\r\n       HAL_PWREx_DisableUSBVoltageDetector() functions to manage USB power\r\n       regulation functionalities.\r\n\r\n   (#) Call HAL_PWREx_EnableBatteryCharging() and\r\n       HAL_PWREx_DisableBatteryCharging() functions to enable and disable the\r\n       battery charging feature with the selected resistor.\r\n\r\n   (#) Call HAL_PWREx_EnableAnalogBooster() and\r\n       HAL_PWREx_DisableAnalogBooster() functions to enable and disable the\r\n       AVD boost feature when the VDD supply voltage is below 2V7.\r\n\r\n   (#) Call HAL_PWREx_EnableMonitoring() and HAL_PWREx_DisableMonitoring()\r\n       functions to enable and disable the VBAT and Temperature monitoring.\r\n       When VBAT and Temperature monitoring feature is enables, use\r\n       HAL_PWREx_GetTemperatureLevel() and HAL_PWREx_GetVBATLevel() to get\r\n       respectively the Temperature level and VBAT level.\r\n\r\n   (#) Call HAL_PWREx_GetMMCVoltage() and HAL_PWREx_DisableMonitoring()\r\n       function to get VDDMMC voltage level. This API is used only for\r\n       STM32H7Axxx and STM32H7Bxxx lines\r\n\r\n   (#) Call HAL_PWREx_ConfigAVD() after setting parameter to be configured\r\n       (event mode and voltage threshold) in order to set up the Analog Voltage\r\n       Detector then use HAL_PWREx_EnableAVD() and  HAL_PWREx_DisableAVD()\r\n       functions to start and stop the AVD detection.\r\n       (+) AVD level could be one of the following values :\r\n             (++) 1V7\r\n             (++) 2V1\r\n             (++) 2V5\r\n             (++) 2V8\r\n\r\n   (#) Call HAL_PWREx_PVD_AVD_IRQHandler() function to handle the PWR PVD and\r\n       AVD interrupt request.\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWREx PWREx\r\n  * @brief PWR Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_PWR_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n\r\n/** @addtogroup PWREx_Private_Constants\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWREx_AVD_Mode_Mask PWR Extended AVD Mode Mask\r\n  * @{\r\n  */\r\n#define AVD_MODE_IT              (0x00010000U)\r\n#define AVD_MODE_EVT             (0x00020000U)\r\n#define AVD_RISING_EDGE          (0x00000001U)\r\n#define AVD_FALLING_EDGE         (0x00000002U)\r\n#define AVD_RISING_FALLING_EDGE  (0x00000003U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWREx_REG_SET_TIMEOUT PWR Extended Flag Setting Time Out Value\r\n  * @{\r\n  */\r\n#define PWR_FLAG_SETTING_DELAY   (1000U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWREx_WakeUp_Pins_Offsets PWREx Wake-Up Pins masks and offsets\r\n  * @{\r\n  */\r\n/* Wake-Up Pins EXTI register mask */\r\n#if defined (EXTI_IMR2_IM57)\r\n#define PWR_EXTI_WAKEUP_PINS_MASK  (EXTI_IMR2_IM55 | EXTI_IMR2_IM56 |\\\r\n                                    EXTI_IMR2_IM57 | EXTI_IMR2_IM58 |\\\r\n                                    EXTI_IMR2_IM59 | EXTI_IMR2_IM60)\r\n#else\r\n#define PWR_EXTI_WAKEUP_PINS_MASK  (EXTI_IMR2_IM55 | EXTI_IMR2_IM56 |\\\r\n                                    EXTI_IMR2_IM58 | EXTI_IMR2_IM60)\r\n#endif /* defined (EXTI_IMR2_IM57) */\r\n\r\n/* Wake-Up Pins PWR Pin Pull shift offsets */\r\n#define PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET (2U)\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n/* Exported types ------------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup PWREx_Exported_Functions PWREx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup PWREx_Exported_Functions_Group1 Power Supply Control Functions\r\n  * @brief    Power supply control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                  ##### Power supply control functions #####\r\n ===============================================================================\r\n    [..]\r\n   (#) When the system is powered on, the POR monitors VDD supply. Once VDD is\r\n       above the POR threshold level, the voltage regulator is enabled in the\r\n       default supply configuration:\r\n      (+) The Voltage converter output level is set at 1V0 in accordance with\r\n          the VOS3 level configured in PWR (D3/SRD) domain control register\r\n          (PWR_D3CR/PWR_SRDCR).\r\n      (+) The system is kept in reset mode as long as VCORE is not ok.\r\n      (+) Once VCORE is ok, the system is taken out of reset and the HSI\r\n          oscillator is enabled.\r\n      (+) Once the oscillator is stable, the system is initialized: Flash memory\r\n          and option bytes are loaded and the CPU starts in Run* mode.\r\n      (+) The software shall then initialize the system including supply\r\n          configuration programming using the HAL_PWREx_ConfigSupply().\r\n      (+) Once the supply configuration has been configured, the\r\n          HAL_PWREx_ConfigSupply() function checks the ACTVOSRDY bit in PWR\r\n          control status register 1 (PWR_CSR1) to guarantee a valid voltage\r\n          levels:\r\n       (++) As long as ACTVOSRDY indicates that voltage levels are invalid, the\r\n            system is in limited Run* mode, write accesses to the RAMs are not\r\n            permitted and VOS shall not be changed.\r\n       (++) Once ACTVOSRDY indicates that voltage levels are valid, the system\r\n            is in normal Run mode, write accesses to RAMs are allowed and VOS\r\n            can be changed.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Configure the system Power Supply.\r\n  * @param  SupplySource : Specifies the Power Supply source to set after a\r\n  *                        system startup.\r\n  *         This parameter can be one of the following values :\r\n  *            @arg PWR_DIRECT_SMPS_SUPPLY : The SMPS supplies the Vcore Power\r\n  *                                          Domains. The LDO is Bypassed.\r\n  *            @arg PWR_SMPS_1V8_SUPPLIES_LDO : The SMPS 1.8V output supplies\r\n  *                                             the LDO. The Vcore Power Domains\r\n  *                                             are supplied from the LDO.\r\n  *            @arg PWR_SMPS_2V5_SUPPLIES_LDO : The SMPS 2.5V output supplies\r\n  *                                             the LDO. The Vcore Power Domains\r\n  *                                             are supplied from the LDO.\r\n  *            @arg PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO : The SMPS 1.8V output\r\n  *                                                     supplies external\r\n  *                                                     circuits and the LDO.\r\n  *                                                     The Vcore Power Domains\r\n  *                                                     are supplied from the\r\n  *                                                     LDO.\r\n  *            @arg PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO : The SMPS 2.5V output\r\n  *                                                     supplies external\r\n  *                                                     circuits and the LDO.\r\n  *                                                     The Vcore Power Domains\r\n  *                                                     are supplied from the\r\n  *                                                     LDO.\r\n  *            @arg PWR_SMPS_1V8_SUPPLIES_EXT : The SMPS 1.8V output supplies\r\n  *                                             external circuits. The LDO is\r\n  *                                             Bypassed. The Vcore Power\r\n  *                                             Domains are supplied from\r\n  *                                             external source.\r\n  *            @arg PWR_SMPS_2V5_SUPPLIES_EXT : The SMPS 2.5V output supplies\r\n  *                                             external circuits. The LDO is\r\n  *                                             Bypassed. The Vcore Power\r\n  *                                             Domains are supplied from\r\n  *                                             external source.\r\n  *            @arg PWR_LDO_SUPPLY : The LDO regulator supplies the Vcore Power\r\n  *                                  Domains. The SMPS regulator is Bypassed.\r\n  *            @arg PWR_EXTERNAL_SOURCE_SUPPLY : The SMPS and the LDO are\r\n  *                                              Bypassed. The Vcore Power\r\n  *                                              Domains are supplied from\r\n  *                                              external source.\r\n  * @note   The PWR_LDO_SUPPLY and PWR_EXTERNAL_SOURCE_SUPPLY are used by all\r\n  *         H7 lines.\r\n  *         The PWR_DIRECT_SMPS_SUPPLY, PWR_SMPS_1V8_SUPPLIES_LDO,\r\n  *         PWR_SMPS_2V5_SUPPLIES_LDO, PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO,\r\n  *         PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO, PWR_SMPS_1V8_SUPPLIES_EXT and\r\n  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS\r\n  *         regulator.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_SUPPLY (SupplySource));\r\n\r\n  /* Check if supply source was configured */\r\n#if defined (PWR_FLAG_SCUEN)\r\n  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)\r\n#else\r\n  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))\r\n#endif /* defined (PWR_FLAG_SCUEN) */\r\n  {\r\n    /* Check supply configuration */\r\n    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)\r\n    {\r\n      /* Supply configuration update locked, can't apply a new supply config */\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      /* Supply configuration update locked, but new supply configuration\r\n         matches with old supply configuration : nothing to do\r\n      */\r\n      return HAL_OK;\r\n    }\r\n  }\r\n\r\n  /* Set the power supply configuration */\r\n  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick ();\r\n\r\n  /* Wait till voltage level flag is set */\r\n  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)\r\n  {\r\n    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n#if defined (SMPS)\r\n  /* When the SMPS supplies external circuits verify that SDEXTRDY flag is set */\r\n  if ((SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO) ||\r\n      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO) ||\r\n      (SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT)         ||\r\n      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT))\r\n  {\r\n    /* Get the current tick number */\r\n    tickstart = HAL_GetTick ();\r\n\r\n    /* Wait till SMPS external supply ready flag is set */\r\n    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)\r\n    {\r\n      if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n#endif /* defined (SMPS) */\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Get the power supply configuration.\r\n  * @retval The supply configuration.\r\n  */\r\nuint32_t HAL_PWREx_GetSupplyConfig (void)\r\n{\r\n  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);\r\n}\r\n\r\n/**\r\n  * @brief Configure the main internal regulator output voltage.\r\n  * @param  VoltageScaling : Specifies the regulator output voltage to achieve\r\n  *                          a tradeoff between performance and power\r\n  *                          consumption.\r\n  *          This parameter can be one of the following values :\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE0 : Regulator voltage output\r\n  *                                                Scale 0 mode.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1 : Regulator voltage output\r\n  *                                                range 1 mode.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2 : Regulator voltage output\r\n  *                                                range 2 mode.\r\n  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3 : Regulator voltage output\r\n  *                                                range 3 mode.\r\n  * @note   For STM32H74x and STM32H75x lines, configuring Voltage Scale 0 is\r\n  *         only possible when Vcore is supplied from LDO (Low DropOut). The\r\n  *         SYSCFG Clock must be enabled through __HAL_RCC_SYSCFG_CLK_ENABLE()\r\n  *         macro before configuring Voltage Scale 0.\r\n  *         To enter low power mode , and if current regulator voltage is\r\n  *         Voltage Scale 0 then first switch to Voltage Scale 1 before entering\r\n  *         low power mode.\r\n  * @retval HAL Status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));\r\n\r\n  /* Get the voltage scaling  */\r\n  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)\r\n  {\r\n    /* Old and new voltage scaling configuration match : nothing to do */\r\n    return HAL_OK;\r\n  }\r\n\r\n#if defined (PWR_SRDCR_VOS)\r\n  /* Set the voltage range */\r\n  MODIFY_REG (PWR->SRDCR, PWR_SRDCR_VOS, VoltageScaling);\r\n#else\r\n#if defined(SYSCFG_PWRCR_ODEN) /* STM32H74xxx and STM32H75xxx lines */\r\n  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)\r\n  {\r\n    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)\r\n    {\r\n      /* Set the voltage range */\r\n      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);\r\n\r\n      /* Get tick */\r\n      tickstart = HAL_GetTick ();\r\n\r\n      /* Wait till voltage level flag is set */\r\n      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)\r\n      {\r\n        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n\r\n      /* Enable the PWR overdrive */\r\n      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);\r\n    }\r\n    else\r\n    {\r\n      /* The voltage scale 0 is only possible when LDO regulator is enabled */\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)\r\n    {\r\n      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)\r\n      {\r\n        /* Disable the PWR overdrive */\r\n        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);\r\n\r\n        /* Get tick */\r\n        tickstart = HAL_GetTick ();\r\n\r\n        /* Wait till voltage level flag is set */\r\n        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)\r\n        {\r\n          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)\r\n          {\r\n            return HAL_ERROR;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Set the voltage range */\r\n    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);\r\n  }\r\n#else  /* STM32H72xxx and STM32H73xxx lines */\r\n  /* Set the voltage range */\r\n  MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);\r\n#endif /* defined (SYSCFG_PWRCR_ODEN) */\r\n#endif /* defined (PWR_SRDCR_VOS) */\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick ();\r\n\r\n  /* Wait till voltage level flag is set */\r\n  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Get the main internal regulator output voltage. Reflecting the last\r\n  *        VOS value applied to the PMU.\r\n  * @retval The current applied VOS selection.\r\n  */\r\nuint32_t HAL_PWREx_GetVoltageRange (void)\r\n{\r\n  /* Get the active voltage scaling */\r\n  return (PWR->CSR1 & PWR_CSR1_ACTVOS);\r\n}\r\n\r\n/**\r\n  * @brief Configure the main internal regulator output voltage in STOP mode.\r\n  * @param  VoltageScaling : Specifies the regulator output voltage when the\r\n  *         system enters Stop mode to achieve a tradeoff between performance\r\n  *         and power consumption.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_REGULATOR_SVOS_SCALE3 : Regulator voltage output range\r\n  *                                             3 mode.\r\n  *            @arg PWR_REGULATOR_SVOS_SCALE4 : Regulator voltage output range\r\n  *                                             4 mode.\r\n  *            @arg PWR_REGULATOR_SVOS_SCALE5 : Regulator voltage output range\r\n  *                                             5 mode.\r\n  * @note   The Stop mode voltage scaling for SVOS4 and SVOS5 sets the voltage\r\n  *         regulator in Low-power (LP) mode to further reduce power consumption.\r\n  *         When preselecting SVOS3, the use of the voltage regulator low-power\r\n  *         mode (LP) can be selected by LPDS register bit.\r\n  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay\r\n  *         when exiting from system Stop mode.\r\n  * @retval HAL Status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ControlStopModeVoltageScaling (uint32_t VoltageScaling)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));\r\n\r\n  /* Return the stop mode voltage range */\r\n  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Get the main internal regulator output voltage in STOP mode.\r\n  * @retval The actual applied VOS selection.\r\n  */\r\nuint32_t HAL_PWREx_GetStopModeVoltageRange (void)\r\n{\r\n  /* Return the stop voltage scaling */\r\n  return (PWR->CR1 & PWR_CR1_SVOS);\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWREx_Exported_Functions_Group2 Low Power Control Functions\r\n  * @brief    Low power control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                     ##### Low power control functions #####\r\n ===============================================================================\r\n\r\n    *** Domains Low Power modes configuration ***\r\n    =============================================\r\n    [..]\r\n      This section provides the extended low power mode control APIs.\r\n      The system presents 3 principles domains (D1, D2 and D3) that can be\r\n      operated in low-power modes (DSTOP or DSTANDBY mode):\r\n\r\n      (+) DSTOP mode to enters a domain to STOP mode:\r\n       (++) D1 domain and/or D2 domain enters DSTOP mode only when the CPU\r\n            subsystem is in CSTOP mode and has allocated peripheral in the\r\n            domain.\r\n            In DSTOP mode the domain bus matrix clock is stopped.\r\n       (++) The system enters STOP mode using one of the following scenarios:\r\n        (+++) D1 domain enters DSTANDBY mode (powered off) and D2, D3 domains\r\n              enter DSTOP mode.\r\n        (+++) D2 domain enters DSTANDBY mode (powered off) and D1, D3 domains\r\n              enter DSTOP mode.\r\n        (+++) D3 domain enters DSTANDBY mode (powered off) and D1, D2 domains\r\n              enter DSTOP mode.\r\n        (+++) D1 and D2 domains enter DSTANDBY mode (powered off) and D3 domain\r\n              enters DSTOP mode.\r\n        (+++) D1 and D3 domains enter DSTANDBY mode (powered off) and D2 domain\r\n              enters DSTOP mode.\r\n        (+++) D2 and D3 domains enter DSTANDBY mode (powered off) and D1 domain\r\n              enters DSTOP mode.\r\n        (+++) D1, D2 and D3 domains enter DSTOP mode.\r\n       (++) When the system enters STOP mode, the clocks are stopped and the\r\n            regulator is running in main or low power mode.\r\n       (++) D3 domain can be kept in Run mode regardless of the CPU status when\r\n            enter STOP mode by using HAL_PWREx_ConfigD3Domain(D3State) function.\r\n\r\n      (+) DSTANDBY mode to enters a domain to STANDBY mode:\r\n       (++) The DSTANDBY mode is entered when the PDDS_Dn bit in PWR CPU control\r\n            register (PWR_CPUCR) for the Dn domain selects Standby mode.\r\n       (++) The system enters STANDBY mode only when D1, D2 and D3 domains enter\r\n            DSTANDBY mode. Consequently the VCORE supply regulator is powered\r\n            off.\r\n\r\n   *** DSTOP mode ***\r\n   ==================\r\n    [..]\r\n      In DStop mode the domain bus matrix clock is stopped.\r\n      The Flash memory can enter low-power Stop mode when it is enabled through\r\n      FLPS in PWR_CR1 register. This allows a trade-off between domain DStop\r\n      restart time and low power consumption.\r\n    [..]\r\n      In DStop mode domain peripherals using the LSI or LSE clock and\r\n      peripherals having a kernel clock request are still able to operate.\r\n    [..]\r\n      Before entering DSTOP mode it is recommended to call SCB_CleanDCache\r\n      function in order to clean the D-Cache and guarantee the data integrity\r\n      for the SRAM memories.\r\n\r\n      (+) Entry:\r\n         The DSTOP mode is entered using the HAL_PWREx_EnterSTOPMode(Regulator,\r\n         STOPEntry, Domain) function with:\r\n         (++) Regulator:\r\n          (+++) PWR_MAINREGULATOR_ON     : Main regulator ON.\r\n          (+++) PWR_LOWPOWERREGULATOR_ON : Low Power regulator ON.\r\n         (++) STOPEntry:\r\n          (+++) PWR_STOPENTRY_WFI : enter STOP mode with WFI instruction\r\n          (+++) PWR_STOPENTRY_WFE : enter STOP mode with WFE instruction\r\n         (++) Domain:\r\n          (+++) PWR_D1_DOMAIN : Enters D1/CD domain to DSTOP mode.\r\n          (+++) PWR_D2_DOMAIN : Enters D2 domain to DSTOP mode.\r\n          (+++) PWR_D3_DOMAIN : Enters D3/SRD domain to DSTOP mode.\r\n\r\n      (+) Exit:\r\n        Any EXTI Line (Internal or External) configured in Interrupt/Event mode.\r\n\r\n   *** DSTANDBY mode ***\r\n   =====================\r\n    [..]\r\n      In DStandby mode:\r\n        (+) The domain bus matrix clock is stopped.\r\n        (+) The domain is powered down and the domain RAM and register contents\r\n            are lost.\r\n    [..]\r\n      Before entering DSTANDBY mode it is recommended to call SCB_CleanDCache\r\n      function in order to clean the D-Cache and guarantee the data integrity\r\n      for the SRAM memories.\r\n\r\n      (+) Entry:\r\n         The DSTANDBY mode is entered using the HAL_PWREx_EnterSTANDBYMode\r\n         (Domain) function with:\r\n       (++) Domain:\r\n        (+++) PWR_D1_DOMAIN : Enters D1/CD domain to DSTANDBY mode.\r\n        (+++) PWR_D2_DOMAIN : Enters D2 domain to DSTANDBY mode.\r\n        (+++) PWR_D3_DOMAIN : Enters D3/SRD domain to DSTANDBY mode.\r\n\r\n      (+) Exit:\r\n        WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B), RTC\r\n        wakeup, tamper event, time stamp event, external reset in NRST pin,\r\n        IWDG reset.\r\n\r\n   *** Keep D3/SRD in RUN mode ***\r\n   ===============================\r\n    [..]\r\n      D3/SRD domain can be kept in Run mode regardless of the CPU status when\r\n      entering STOP mode by using HAL_PWREx_ConfigD3Domain(D3State) function\r\n      with :\r\n       (+) D3State:\r\n        (++) PWR_D3_DOMAIN_STOP : D3/SDR domain follows the CPU sub-system\r\n                                  mode.\r\n        (++) PWR_D3_DOMAIN_RUN : D3/SRD domain remains in Run mode regardless\r\n                                 of CPU subsystem mode.\r\n\r\n    *** FLASH Power Down configuration ****\r\n    =======================================\r\n    [..]\r\n      By setting the FLPS bit in the PWR_CR1 register using the\r\n      HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters\r\n      power down mode when the device enters STOP mode. When the Flash memory is\r\n      in power down mode, an additional startup delay is incurred when waking up\r\n      from STOP mode.\r\n\r\n    *** Wakeup Pins configuration ****\r\n    ===================================\r\n    [..]\r\n      Wakeup pins allow the system to exit from Standby mode. The configuration\r\n      of wakeup pins is done with the HAL_PWREx_EnableWakeUpPin(sPinParams)\r\n      function with:\r\n       (+) sPinParams: structure to enable and configure a wakeup pin:\r\n        (++) WakeUpPin: Wakeup pin to be enabled.\r\n        (++) PinPolarity: Wakeup pin polarity (rising or falling edge).\r\n        (++) PinPull: Wakeup pin pull (no pull, pull-up or pull-down).\r\n    [..]\r\n      The wakeup pins are internally connected to the EXTI lines [55-60] to\r\n      generate an interrupt if enabled. The EXTI lines configuration is done by\r\n      the HAL_EXTI_Dx_EventInputConfig() functions defined in the stm32h7xxhal.c\r\n      file.\r\n    [..]\r\n      When a wakeup pin event is received the HAL_PWREx_WAKEUP_PIN_IRQHandler is\r\n      called and the appropriate flag is set in the PWR_WKUPFR register. Then in\r\n      the HAL_PWREx_WAKEUP_PIN_IRQHandler function the wakeup pin flag will be\r\n      cleared and the appropriate user callback will be called. The user can add\r\n      his own code by customization of function pointer HAL_PWREx_WKUPx_Callback.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n#if defined (PWR_CPUCR_RETDS_CD)\r\n/**\r\n  * @brief Enter the system to STOP mode with main domain in DSTOP2.\r\n  * @note   In STOP mode, the domain bus matrix clock is stalled.\r\n  * @note   In STOP mode, memories and registers are maintained and peripherals\r\n  *         in CPU domain are no longer operational.\r\n  * @note   All clocks in the VCORE domain are stopped, the PLL, the HSI and the\r\n  *         HSE oscillators are disabled. Only Peripherals that have wakeup\r\n  *         capability can switch on the HSI to receive a frame, and switch off\r\n  *         the HSI after receiving the frame if it is not a wakeup frame. In\r\n  *         this case the HSI clock is propagated only to the peripheral\r\n  *         requesting it.\r\n  * @note   When exiting STOP mode by issuing an interrupt or a wakeup event,\r\n  *         the HSI RC oscillator is selected as system clock if STOPWUCK bit in\r\n  *         RCC_CFGR register is set.\r\n  * @param  Regulator : Specifies the regulator state in STOP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON     : STOP mode with regulator ON.\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON : STOP mode with low power\r\n  *                                            regulator ON.\r\n  * @param  STOPEntry : Specifies if STOP mode in entered with WFI or WFE\r\n  *                     intrinsic instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_STOPENTRY_WFI : Enter STOP mode with WFI instruction.\r\n  *            @arg PWR_STOPENTRY_WFE : Enter STOP mode with WFE instruction.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnterSTOP2Mode (uint32_t Regulator, uint8_t STOPEntry)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_REGULATOR (Regulator));\r\n  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));\r\n\r\n  /* Select the regulator state in Stop mode */\r\n  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);\r\n\r\n  /* Go to DStop2 mode (deep retention) when CPU domain enters Deepsleep */\r\n  SET_BIT (PWR->CPUCR, PWR_CPUCR_RETDS_CD);\r\n\r\n  /* Keep DSTOP mode when SmartRun domain enters Deepsleep */\r\n  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_SRD);\r\n\r\n  /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n  /* Ensure that all instructions are done before entering STOP mode */\r\n  __ISB ();\r\n  __DSB ();\r\n\r\n  /* Select Stop mode entry */\r\n  if (STOPEntry == PWR_STOPENTRY_WFI)\r\n  {\r\n    /* Request Wait For Interrupt */\r\n    __WFI ();\r\n  }\r\n  else\r\n  {\r\n    /* Request Wait For Event */\r\n    __WFE ();\r\n  }\r\n\r\n  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */\r\n  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n}\r\n#endif /* defined (PWR_CPUCR_RETDS_CD) */\r\n\r\n/**\r\n  * @brief Enter a Domain to DSTOP mode.\r\n  * @note   This API gives flexibility to manage independently each domain STOP\r\n  *         mode. For dual core lines, this API should be executed with the\r\n  *         corresponding Cortex-Mx to enter domain to DSTOP mode. When it is\r\n  *         executed by all available Cortex-Mx, the system enter to STOP mode.\r\n  *         For single core lines, calling this API with domain parameter set to\r\n  *         PWR_D1_DOMAIN (D1/CD), the whole system will enter in STOP mode\r\n  *         independently of PWR_CPUCR_PDDS_Dx bits values if RUN_D3 bit in the\r\n  *         CPUCR_RUN_D3 is cleared.\r\n  * @note   In DStop mode the domain bus matrix clock is stopped.\r\n  * @note   The system D3/SRD domain enter Stop mode only when the CPU subsystem\r\n  *         is in CStop mode, the EXTI wakeup sources are inactive and at least\r\n  *         one PDDS_Dn bit in PWR CPU control register (PWR_CPUCR) for\r\n  *         any domain request Stop.\r\n  * @note   Before entering DSTOP mode it is recommended to call SCB_CleanDCache\r\n  *         function in order to clean the D-Cache and guarantee the data\r\n  *         integrity for the SRAM memories.\r\n  * @note   In System Stop mode, the domain peripherals that use the LSI or LSE\r\n  *         clock, and the peripherals that have a kernel clock request to\r\n  *         select HSI or CSI as source, are still able to operate.\r\n  * @param  Regulator : Specifies the regulator state in STOP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_MAINREGULATOR_ON     : STOP mode with regulator ON.\r\n  *            @arg PWR_LOWPOWERREGULATOR_ON : STOP mode with low power\r\n  *                                            regulator ON.\r\n  * @param  STOPEntry : Specifies if STOP mode in entered with WFI or WFE\r\n  *                     intrinsic instruction.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_STOPENTRY_WFI : Enter STOP mode with WFI instruction.\r\n  *            @arg PWR_STOPENTRY_WFE : Enter STOP mode with WFE instruction.\r\n  * @param  Domain : Specifies the Domain to enter in DSTOP mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_D1_DOMAIN : Enter D1/CD Domain to DSTOP mode.\r\n  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.\r\n  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_REGULATOR (Regulator));\r\n  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));\r\n  assert_param (IS_PWR_DOMAIN (Domain));\r\n\r\n  /* Select the regulator state in Stop mode */\r\n  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);\r\n\r\n  /* Select the domain Power Down DeepSleep */\r\n  if (Domain == PWR_D1_DOMAIN)\r\n  {\r\n#if defined (DUAL_CORE)\r\n    /* Check current core */\r\n    if (HAL_GetCurrentCPUID () != CM7_CPUID)\r\n    {\r\n      /*\r\n         When the domain selected and the cortex-mx don't match, entering stop\r\n         mode will not be performed\r\n      */\r\n      return;\r\n    }\r\n#endif /* defined (DUAL_CORE) */\r\n\r\n    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */\r\n    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);\r\n\r\n    /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n    /* Ensure that all instructions are done before entering STOP mode */\r\n    __DSB ();\r\n    __ISB ();\r\n\r\n    /* Select Stop mode entry */\r\n    if (STOPEntry == PWR_STOPENTRY_WFI)\r\n    {\r\n      /* Request Wait For Interrupt */\r\n      __WFI ();\r\n    }\r\n    else\r\n    {\r\n      /* Request Wait For Event */\r\n      __WFE ();\r\n    }\r\n\r\n    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */\r\n    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n  }\r\n#if defined (PWR_CPUCR_PDDS_D2)\r\n  else if (Domain == PWR_D2_DOMAIN)\r\n  {\r\n#if defined (DUAL_CORE)\r\n    /* Check current core */\r\n    if (HAL_GetCurrentCPUID () != CM4_CPUID)\r\n    {\r\n      /*\r\n         When the domain selected and the cortex-mx don't match, entering stop\r\n         mode will not be performed\r\n      */\r\n      return;\r\n    }\r\n\r\n    /* Keep DSTOP mode when D2 domain enters Deepsleep */\r\n    CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D2);\r\n\r\n    /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n    /* Ensure that all instructions are done before entering STOP mode */\r\n    __DSB ();\r\n    __ISB ();\r\n\r\n    /* Select Stop mode entry */\r\n    if (STOPEntry == PWR_STOPENTRY_WFI)\r\n    {\r\n      /* Request Wait For Interrupt */\r\n      __WFI ();\r\n    }\r\n    else\r\n    {\r\n      /* Request Wait For Event */\r\n      __WFE ();\r\n    }\r\n\r\n    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */\r\n    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n#else\r\n    /* Keep DSTOP mode when D2 domain enters Deepsleep */\r\n    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);\r\n#endif  /* defined (DUAL_CORE) */\r\n  }\r\n#endif /* defined (PWR_CPUCR_PDDS_D2) */\r\n  else\r\n  {\r\n#if defined (DUAL_CORE)\r\n    /* Check current core */\r\n    if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n    {\r\n      /* Keep DSTOP mode when D3 domain enters Deepsleep */\r\n      CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);\r\n    }\r\n    else\r\n    {\r\n      /* Keep DSTOP mode when D3 domain enters Deepsleep */\r\n      CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);\r\n    }\r\n#else\r\n    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */\r\n    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);\r\n#endif  /* defined (DUAL_CORE) */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Clear pending event.\r\n  * @note   This API clears the pending event in order to enter a given CPU\r\n  *         to CSLEEP or CSTOP. It should be called just before APIs performing\r\n  *         enter low power mode using Wait For Event request.\r\n  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_ClearPendingEvent (void)\r\n{\r\n#if defined (DUAL_CORE)\r\n  /* Check the current Core */\r\n  if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n  {\r\n    __WFE ();\r\n  }\r\n  else\r\n  {\r\n    __SEV ();\r\n    __WFE ();\r\n  }\r\n#else\r\n  __WFE ();\r\n#endif /* defined (DUAL_CORE) */\r\n}\r\n\r\n/**\r\n  * @brief Enter a Domain to DSTANDBY mode.\r\n  * @note   This API gives flexibility to manage independently each domain\r\n  *         STANDBY mode. For dual core lines, this API should be executed with\r\n  *         the corresponding Cortex-Mx to enter domain to DSTANDBY mode. When\r\n  *         it is executed by all available Cortex-Mx, the system enter STANDBY\r\n  *         mode.\r\n  *         For single core lines, calling this API with D1/SRD the selected\r\n  *         domain will enter the whole system in STOP if PWR_CPUCR_PDDS_D3 = 0\r\n  *         and enter the whole system in STANDBY if PWR_CPUCR_PDDS_D3 = 1.\r\n  * @note   The DStandby mode is entered when all PDDS_Dn bits in PWR_CPUCR for\r\n  *         the Dn domain select Standby mode. When the system enters Standby\r\n  *         mode, the voltage regulator is disabled.\r\n  * @note   When D2 or D3 domain is in DStandby mode and the CPU sets the\r\n  *         domain PDDS_Dn bit to select Stop mode, the domain remains in\r\n  *         DStandby mode. The domain will only exit DStandby when the CPU\r\n  *         allocates a peripheral in the domain.\r\n  * @note   The system D3/SRD domain enters Standby mode only when the D1 and D2\r\n  *         domain are in DStandby.\r\n  * @note   Before entering DSTANDBY mode it is recommended to call\r\n  *         SCB_CleanDCache function in order to clean the D-Cache and guarantee\r\n  *         the data integrity for the SRAM memories.\r\n  * @param  Domain : Specifies the Domain to enter to STANDBY mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_D1_DOMAIN: Enter D1/CD Domain to DSTANDBY mode.\r\n  *            @arg PWR_D2_DOMAIN: Enter D2 Domain to DSTANDBY mode.\r\n  *            @arg PWR_D3_DOMAIN: Enter D3/SRD Domain to DSTANDBY mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_EnterSTANDBYMode (uint32_t Domain)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_DOMAIN (Domain));\r\n\r\n  /* Select the domain Power Down DeepSleep */\r\n  if (Domain == PWR_D1_DOMAIN)\r\n  {\r\n#if defined (DUAL_CORE)\r\n    /* Check current core */\r\n    if (HAL_GetCurrentCPUID () != CM7_CPUID)\r\n    {\r\n      /*\r\n         When the domain selected and the cortex-mx don't match, entering\r\n         standby mode will not be performed\r\n      */\r\n      return;\r\n    }\r\n#endif /* defined (DUAL_CORE) */\r\n\r\n    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */\r\n    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);\r\n\r\n#if defined (DUAL_CORE)\r\n    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */\r\n    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);\r\n#endif /*DUAL_CORE*/\r\n\r\n    /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n    /* This option is used to ensure that store operations are completed */\r\n#if defined (__CC_ARM)\r\n    __force_stores ();\r\n#endif /* defined (__CC_ARM) */\r\n\r\n    /* Request Wait For Interrupt */\r\n    __WFI ();\r\n  }\r\n#if defined (PWR_CPUCR_PDDS_D2)\r\n  else if (Domain == PWR_D2_DOMAIN)\r\n  {\r\n    /* Allow DSTANDBY mode when D2 domain enters Deepsleep */\r\n    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);\r\n\r\n#if defined (DUAL_CORE)\r\n    /* Check current core */\r\n    if (HAL_GetCurrentCPUID () != CM4_CPUID)\r\n    {\r\n      /*\r\n         When the domain selected and the cortex-mx don't match, entering\r\n         standby mode will not be performed\r\n      */\r\n      return;\r\n    }\r\n\r\n    /* Allow DSTANDBY mode when D2 domain enters Deepsleep */\r\n    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D2);\r\n\r\n    /* Set SLEEPDEEP bit of Cortex System Control Register */\r\n    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);\r\n\r\n    /* This option is used to ensure that store operations are completed */\r\n#if defined (__CC_ARM)\r\n    __force_stores ();\r\n#endif /* defined (__CC_ARM) */\r\n\r\n    /* Request Wait For Interrupt */\r\n    __WFI ();\r\n#endif /* defined (DUAL_CORE) */\r\n  }\r\n#endif /* defined (PWR_CPUCR_PDDS_D2) */\r\n  else\r\n  {\r\n    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */\r\n    SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);\r\n\r\n#if defined (DUAL_CORE)\r\n    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */\r\n    SET_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);\r\n#endif /* defined (DUAL_CORE) */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Configure the D3/SRD Domain state when the System in low power mode.\r\n  * @param  D3State : Specifies the D3/SRD state.\r\n  *          This parameter can be one of the following values :\r\n  *            @arg PWR_D3_DOMAIN_STOP : D3/SRD domain will follow the most deep\r\n  *                                      CPU sub-system low power mode.\r\n  *            @arg PWR_D3_DOMAIN_RUN : D3/SRD domain will stay in RUN mode\r\n  *                                     regardless of the CPU sub-system low\r\n  *                                     power mode.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_ConfigD3Domain (uint32_t D3State)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_D3_STATE (D3State));\r\n\r\n  /* Keep D3/SRD in run mode */\r\n  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);\r\n}\r\n\r\n#if defined (DUAL_CORE)\r\n/**\r\n  * @brief Clear HOLD2F, HOLD1F, STOPF, SBF, SBF_D1, and SBF_D2 flags for a\r\n  *        given domain.\r\n  * @param  DomainFlags : Specifies the Domain flags to be cleared.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_D1_DOMAIN_FLAGS : Clear D1 Domain flags.\r\n  *            @arg PWR_D2_DOMAIN_FLAGS : Clear D2 Domain flags.\r\n  *            @arg PWR_ALL_DOMAIN_FLAGS : Clear D1 and D2 Domain flags.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_ClearDomainFlags (uint32_t DomainFlags)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_PWR_DOMAIN_FLAG (DomainFlags));\r\n\r\n  /* D1 CPU flags */\r\n  if (DomainFlags == PWR_D1_DOMAIN_FLAGS)\r\n  {\r\n    /* Clear D1 domain flags (HOLD2F, STOPF, SBF, SBF_D1, and SBF_D2) */\r\n    SET_BIT (PWR->CPUCR, PWR_CPUCR_CSSF);\r\n  }\r\n  /* D2 CPU flags */\r\n  else if (DomainFlags == PWR_D2_DOMAIN_FLAGS)\r\n  {\r\n    /* Clear D2 domain flags (HOLD1F, STOPF, SBF, SBF_D1, and SBF_D2) */\r\n    SET_BIT (PWR->CPU2CR, PWR_CPU2CR_CSSF);\r\n  }\r\n  else\r\n  {\r\n    /* Clear D1 domain flags (HOLD2F, STOPF, SBF, SBF_D1, and SBF_D2) */\r\n    SET_BIT (PWR->CPUCR, PWR_CPUCR_CSSF);\r\n    /* Clear D2 domain flags (HOLD1F, STOPF, SBF, SBF_D1, and SBF_D2) */\r\n    SET_BIT (PWR->CPU2CR, PWR_CPU2CR_CSSF);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Hold the CPU and their domain peripherals when exiting STOP mode.\r\n  * @param  CPU : Specifies the core to be held.\r\n  *         This parameter can be one of the following values:\r\n  *             @arg PWR_CORE_CPU1: Hold CPU1 and set CPU2 as master.\r\n  *             @arg PWR_CORE_CPU2: Hold CPU2 and set CPU1 as master.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_HoldCore (uint32_t CPU)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_CORE (CPU));\r\n\r\n  /* Check CPU index */\r\n  if (CPU == PWR_CORE_CPU2)\r\n  {\r\n    /* If CPU1 is not held */\r\n    if ((PWR->CPU2CR & PWR_CPU2CR_HOLD1) != PWR_CPU2CR_HOLD1)\r\n    {\r\n      /* Set HOLD2 bit */\r\n      SET_BIT (PWR->CPUCR, PWR_CPUCR_HOLD2);\r\n    }\r\n    else\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* If CPU2 is not held */\r\n    if ((PWR->CPUCR & PWR_CPUCR_HOLD2) != PWR_CPUCR_HOLD2)\r\n    {\r\n      /* Set HOLD1 bit */\r\n      SET_BIT (PWR->CPU2CR, PWR_CPU2CR_HOLD1);\r\n    }\r\n    else\r\n    {\r\n      status = HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Release the CPU and their domain peripherals after a wake-up from\r\n  *        STOP mode.\r\n  * @param  CPU: Specifies the core to be released.\r\n  *         This parameter can be one of the following values:\r\n  *             @arg  PWR_CORE_CPU1: Release the CPU1 and their domain\r\n  *                   peripherals from holding.\r\n  *             @arg  PWR_CORE_CPU2: Release the CPU2 and their domain\r\n  *                   peripherals from holding.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_ReleaseCore (uint32_t CPU)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_CORE (CPU));\r\n\r\n  /* Check CPU index */\r\n  if (CPU == PWR_CORE_CPU2)\r\n  {\r\n    /* Reset HOLD2 bit */\r\n    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_HOLD2);\r\n  }\r\n  else\r\n  {\r\n    /* Reset HOLD1 bit */\r\n    CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_HOLD1);\r\n  }\r\n}\r\n#endif /* defined (DUAL_CORE) */\r\n\r\n\r\n/**\r\n  * @brief Enable the Flash Power Down in Stop mode.\r\n  * @note   When Flash Power Down is enabled  the Flash memory enters low-power\r\n  *         mode when D1/SRD domain is in DStop mode. This feature allows to\r\n  *         obtain the best trade-off between low-power consumption and restart\r\n  *         time when exiting from DStop mode.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableFlashPowerDown (void)\r\n{\r\n  /* Enable the Flash Power Down */\r\n  SET_BIT (PWR->CR1, PWR_CR1_FLPS);\r\n}\r\n\r\n/**\r\n  * @brief Disable the Flash Power Down in Stop mode.\r\n  * @note   When Flash Power Down is disabled  the Flash memory is kept on\r\n  *         normal mode when D1/SRD domain is in DStop mode. This feature allows\r\n  *         to obtain the best trade-off between low-power consumption and\r\n  *         restart time when exiting from DStop mode.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_DisableFlashPowerDown (void)\r\n{\r\n  /* Disable the Flash Power Down */\r\n  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);\r\n}\r\n\r\n#if defined (PWR_CR1_SRDRAMSO)\r\n/**\r\n  * @brief Enable memory block shut-off in DStop or DStop2 modes\r\n  * @note   In DStop or DStop2 mode, the content of the memory blocks is\r\n  *         maintained. Further power optimization can be obtained by switching\r\n  *         off some memory blocks. This optimization implies loss of the memory\r\n  *         content. The user can select which memory is discarded during STOP\r\n  *         mode by means of xxSO bits.\r\n  * @param  MemoryBlock : Specifies the memory block to shut-off during DStop or\r\n  *                       DStop2 mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SRD_AHB_MEMORY_BLOCK : SmartRun domain AHB memory.\r\n  *            @arg PWR_USB_FDCAN_MEMORY_BLOCK : High-speed interfaces USB and\r\n  *                                              FDCAN memories.\r\n  *            @arg PWR_GFXMMU_JPEG_MEMORY_BLOCK : GFXMMU and JPEG memories.\r\n  *            @arg PWR_TCM_ECM_MEMORY_BLOCK : Instruction TCM and ETM memories.\r\n  *            @arg PWR_RAM1_AHB_MEMORY_BLOCK : AHB RAM1 memory.\r\n  *            @arg PWR_RAM2_AHB_MEMORY_BLOCK : AHB RAM2 memory.\r\n  *            @arg PWR_RAM1_AXI_MEMORY_BLOCK : AXI RAM1 memory.\r\n  *            @arg PWR_RAM2_AXI_MEMORY_BLOCK : AXI RAM2 memory.\r\n  *            @arg PWR_RAM3_AXI_MEMORY_BLOCK : AXI RAM3 memory.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableMemoryShutOff (uint32_t MemoryBlock)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_PWR_MEMORY_BLOCK (MemoryBlock));\r\n\r\n  /* Enable memory block shut-off */\r\n  SET_BIT (PWR->CR1, MemoryBlock);\r\n}\r\n\r\n/**\r\n  * @brief Disable memory block shut-off in DStop or DStop2 modes\r\n  * @param  MemoryBlock : Specifies the memory block to keep content during\r\n  *                       DStop or DStop2 mode.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_SRD_AHB_MEMORY_BLOCK : SmartRun domain AHB memory.\r\n  *            @arg PWR_USB_FDCAN_MEMORY_BLOCK : High-speed interfaces USB and\r\n  *                                              FDCAN memories.\r\n  *            @arg PWR_GFXMMU_JPEG_MEMORY_BLOCK : GFXMMU and JPEG memories.\r\n  *            @arg PWR_TCM_ECM_MEMORY_BLOCK : Instruction TCM and ETM memories.\r\n  *            @arg PWR_RAM1_AHB_MEMORY_BLOCK : AHB RAM1 memory.\r\n  *            @arg PWR_RAM2_AHB_MEMORY_BLOCK : AHB RAM2 memory.\r\n  *            @arg PWR_RAM1_AXI_MEMORY_BLOCK : AXI RAM1 memory.\r\n  *            @arg PWR_RAM2_AXI_MEMORY_BLOCK : AXI RAM2 memory.\r\n  *            @arg PWR_RAM3_AXI_MEMORY_BLOCK : AXI RAM3 memory.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_DisableMemoryShutOff (uint32_t MemoryBlock)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_PWR_MEMORY_BLOCK (MemoryBlock));\r\n\r\n  /* Disable memory block shut-off */\r\n  CLEAR_BIT (PWR->CR1, MemoryBlock);\r\n}\r\n#endif /* defined (PWR_CR1_SRDRAMSO) */\r\n\r\n/**\r\n  * @brief Enable the Wake-up PINx functionality.\r\n  * @param  sPinParams : Pointer to a PWREx_WakeupPinTypeDef structure that\r\n  *                      contains the configuration information for the wake-up\r\n  *                      Pin.\r\n  * @note   For dual core devices, please ensure to configure the EXTI lines for\r\n  *         the different Cortex-Mx. All combination are allowed: wake up only\r\n  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and\r\n  *         Cortex-M4.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)\r\n{\r\n  uint32_t pinConfig;\r\n  uint32_t regMask;\r\n  const uint32_t pullMask = PWR_WKUPEPR_WKUPPUPD1;\r\n\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));\r\n  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));\r\n  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));\r\n\r\n  pinConfig = sPinParams->WakeUpPin | \\\r\n              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \\\r\n              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));\r\n\r\n  regMask   = sPinParams->WakeUpPin | \\\r\n              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \\\r\n              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));\r\n\r\n  /* Enable and Specify the Wake-Up pin polarity and the pull configuration\r\n     for the event detection (rising or falling edge) */\r\n  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);\r\n#ifndef DUAL_CORE\r\n  /* Configure the Wakeup Pin EXTI Line */\r\n  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));\r\n#endif /* !DUAL_CORE */\r\n}\r\n\r\n/**\r\n  * @brief Disable the Wake-up PINx functionality.\r\n  * @param  WakeUpPin : Specifies the Wake-Up pin to be disabled.\r\n  *          This parameter can be one of the following values:\r\n  *           @arg PWR_WAKEUP_PIN1 : Disable PA0  wake-up PIN.\r\n  *           @arg PWR_WAKEUP_PIN2 : Disable PA2  wake-up PIN.\r\n  *           @arg PWR_WAKEUP_PIN3 : Disable PI8  wake-up PIN.\r\n  *           @arg PWR_WAKEUP_PIN4 : Disable PC13 wake-up PIN.\r\n  *           @arg PWR_WAKEUP_PIN5 : Disable PI11 wake-up PIN.\r\n  *           @arg PWR_WAKEUP_PIN6 : Disable PC1  wake-up PIN.\r\n  * @note   The PWR_WAKEUP_PIN3 and PWR_WAKEUP_PIN5 are available only for\r\n  *         devices that support GPIOI port.\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_DisableWakeUpPin (uint32_t WakeUpPin)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));\r\n\r\n  /* Disable the WakeUpPin */\r\n  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);\r\n}\r\n\r\n/**\r\n  * @brief Get the Wake-Up Pin pending flags.\r\n  * @param  WakeUpFlag : Specifies the Wake-Up PIN flag to be checked.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_WAKEUP_FLAG1    : Get wakeup event received from PA0.\r\n  *            @arg PWR_WAKEUP_FLAG2    : Get wakeup event received from PA2.\r\n  *            @arg PWR_WAKEUP_FLAG3    : Get wakeup event received from PI8.\r\n  *            @arg PWR_WAKEUP_FLAG4    : Get wakeup event received from PC13.\r\n  *            @arg PWR_WAKEUP_FLAG5    : Get wakeup event received from PI11.\r\n  *            @arg PWR_WAKEUP_FLAG6    : Get wakeup event received from PC1.\r\n  *            @arg PWR_WAKEUP_FLAG_ALL : Get Wakeup event received from all\r\n  *                                      wake up pins.\r\n  * @note   The PWR_WAKEUP_FLAG3 and PWR_WAKEUP_FLAG5 are available only for\r\n  *         devices that support GPIOI port.\r\n  * @retval The Wake-Up pin flag.\r\n  */\r\nuint32_t HAL_PWREx_GetWakeupFlag (uint32_t WakeUpFlag)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));\r\n\r\n  /* Return the wake up pin flag */\r\n  return (PWR->WKUPFR & WakeUpFlag);\r\n}\r\n\r\n/**\r\n  * @brief Clear the Wake-Up pin pending flag.\r\n  * @param  WakeUpFlag: Specifies the Wake-Up PIN flag to clear.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg PWR_WAKEUP_FLAG1 : Clear the wakeup event received from PA0.\r\n  *            @arg PWR_WAKEUP_FLAG2 : Clear the wakeup event received from PA2.\r\n  *            @arg PWR_WAKEUP_FLAG3 : Clear the wakeup event received from PI8.\r\n  *            @arg PWR_WAKEUP_FLAG4 : Clear the wakeup event received from PC13.\r\n  *            @arg PWR_WAKEUP_FLAG5 : Clear the wakeup event received from PI11.\r\n  *            @arg PWR_WAKEUP_FLAG6 : Clear the wakeup event received from PC1.\r\n  *            @arg PWR_WAKEUP_FLAG_ALL : Clear the wakeup events received from\r\n  *                                      all wake up pins.\r\n  * @note   The PWR_WAKEUP_FLAG3 and PWR_WAKEUP_FLAG5 are available only for\r\n  *         devices that support GPIOI port.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_ClearWakeupFlag (uint32_t WakeUpFlag)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));\r\n\r\n  /* Clear the wake up event received from wake up pin x */\r\n  SET_BIT (PWR->WKUPCR, WakeUpFlag);\r\n\r\n  /* Check if the wake up event is well cleared */\r\n  if ((PWR->WKUPFR & WakeUpFlag) != 0U)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief This function handles the PWR WAKEUP PIN interrupt request.\r\n  * @note   This API should be called under the WAKEUP_PIN_IRQHandler().\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_WAKEUP_PIN_IRQHandler (void)\r\n{\r\n  /* Wakeup pin EXTI line interrupt detected */\r\n  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)\r\n  {\r\n    /* Clear PWR WKUPF1 flag */\r\n    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);\r\n\r\n    /* PWR WKUP1 interrupt user callback */\r\n    HAL_PWREx_WKUP1_Callback ();\r\n  }\r\n  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)\r\n  {\r\n    /* Clear PWR WKUPF2 flag */\r\n    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);\r\n\r\n    /* PWR WKUP2 interrupt user callback */\r\n    HAL_PWREx_WKUP2_Callback ();\r\n  }\r\n#if defined (PWR_WKUPFR_WKUPF3)\r\n  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)\r\n  {\r\n    /* Clear PWR WKUPF3 flag */\r\n    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);\r\n\r\n    /* PWR WKUP3 interrupt user callback */\r\n    HAL_PWREx_WKUP3_Callback ();\r\n  }\r\n#endif /* defined (PWR_WKUPFR_WKUPF3) */\r\n  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)\r\n  {\r\n    /* Clear PWR WKUPF4 flag */\r\n    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);\r\n\r\n    /* PWR WKUP4 interrupt user callback */\r\n    HAL_PWREx_WKUP4_Callback ();\r\n  }\r\n#if defined (PWR_WKUPFR_WKUPF5)\r\n  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)\r\n  {\r\n    /* Clear PWR WKUPF5 flag */\r\n    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);\r\n\r\n    /* PWR WKUP5 interrupt user callback */\r\n    HAL_PWREx_WKUP5_Callback ();\r\n  }\r\n#endif /* defined (PWR_WKUPFR_WKUPF5) */\r\n  else\r\n  {\r\n    /* Clear PWR WKUPF6 flag */\r\n    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);\r\n\r\n    /* PWR WKUP6 interrupt user callback */\r\n    HAL_PWREx_WKUP6_Callback ();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief PWR WKUP1 interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_WKUP1_Callback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWREx_WKUP1Callback can be implemented in the user file\r\n  */\r\n}\r\n\r\n/**\r\n  * @brief PWR WKUP2 interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_WKUP2_Callback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWREx_WKUP2Callback can be implemented in the user file\r\n  */\r\n}\r\n\r\n#if defined (PWR_WKUPFR_WKUPF3)\r\n/**\r\n  * @brief PWR WKUP3 interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_WKUP3_Callback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWREx_WKUP3Callback can be implemented in the user file\r\n  */\r\n}\r\n#endif /* defined (PWR_WKUPFR_WKUPF3) */\r\n\r\n/**\r\n  * @brief PWR WKUP4 interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_WKUP4_Callback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWREx_WKUP4Callback can be implemented in the user file\r\n  */\r\n}\r\n\r\n#if defined (PWR_WKUPFR_WKUPF5)\r\n/**\r\n  * @brief PWR WKUP5 interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_WKUP5_Callback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWREx_WKUP5Callback can be implemented in the user file\r\n  */\r\n}\r\n#endif /* defined (PWR_WKUPFR_WKUPF5) */\r\n\r\n/**\r\n  * @brief PWR WKUP6 interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_WKUP6_Callback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWREx_WKUP6Callback can be implemented in the user file\r\n  */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWREx_Exported_Functions_Group3 Peripherals control functions\r\n  * @brief    Peripherals control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                 ##### Peripherals control functions #####\r\n ===============================================================================\r\n\r\n    *** Main and Backup Regulators configuration ***\r\n    ================================================\r\n    [..]\r\n      (+) The backup domain includes 4 Kbytes of backup SRAM accessible only\r\n          from the CPU, and addressed in 32-bit, 16-bit or 8-bit mode. Its\r\n          content is retained even in Standby or VBAT mode when the low power\r\n          backup regulator is enabled. It can be considered as an internal\r\n          EEPROM when VBAT is always present. You can use the\r\n          HAL_PWREx_EnableBkUpReg() function to enable the low power backup\r\n          regulator.\r\n      (+) When the backup domain is supplied by VDD (analog switch connected to\r\n          VDD) the backup SRAM is powered from VDD which replaces the VBAT power\r\n          supply to save battery life.\r\n      (+) The backup SRAM is not mass erased by a tamper event. It is read\r\n          protected to prevent confidential data, such as cryptographic private\r\n          key, from being accessed. The backup SRAM can be erased only through\r\n          the Flash interface when a protection level change from level 1 to\r\n          level 0 is requested.\r\n      -@- Refer to the description of Read protection (RDP) in the Flash\r\n          programming manual.\r\n      (+) The main internal regulator can be configured to have a tradeoff\r\n          between performance and power consumption when the device does not\r\n          operate at the maximum frequency. This is done through\r\n          HAL_PWREx_ControlVoltageScaling(VOS) function which configure the VOS\r\n          bit in PWR_D3CR register.\r\n      (+) The main internal regulator can be configured to operate in Low Power\r\n          mode when the system enters STOP mode to further reduce power\r\n          consumption.\r\n          This is done through HAL_PWREx_ControlStopModeVoltageScaling(SVOS)\r\n          function which configure the SVOS bit in PWR_CR1 register.\r\n          The selected SVOS4 and SVOS5 levels add an additional startup delay\r\n          when exiting from system Stop mode.\r\n    -@- Refer to the product datasheets for more details.\r\n\r\n    *** USB Regulator configuration ***\r\n    ===================================\r\n    [..]\r\n      (+) The USB transceivers are supplied from a dedicated VDD33USB supply\r\n          that can be provided either by the integrated USB regulator, or by an\r\n          external USB supply.\r\n      (+) The USB regulator is enabled by HAL_PWREx_EnableUSBReg() function, the\r\n          VDD33USB is then provided from the USB regulator.\r\n      (+) When the USB regulator is enabled, the VDD33USB supply level detector\r\n          shall be enabled through  HAL_PWREx_EnableUSBVoltageDetector()\r\n          function.\r\n      (+) The USB regulator is disabled through HAL_PWREx_DisableUSBReg()\r\n          function and VDD33USB can be provided from an external supply. In this\r\n          case VDD33USB and VDD50USB shall be connected together.\r\n\r\n    *** VBAT battery charging ***\r\n    =============================\r\n    [..]\r\n      (+) When VDD is present, the external battery connected to VBAT can be\r\n          charged through an internal resistance. VBAT charging can be performed\r\n          either through a 5 KOhm resistor or through a 1.5 KOhm resistor.\r\n      (+) VBAT charging is enabled by HAL_PWREx_EnableBatteryCharging\r\n          (ResistorValue) function with:\r\n       (++) ResistorValue:\r\n        (+++) PWR_BATTERY_CHARGING_RESISTOR_5: 5 KOhm resistor.\r\n        (+++) PWR_BATTERY_CHARGING_RESISTOR_1_5: 1.5 KOhm resistor.\r\n      (+) VBAT charging is disabled by HAL_PWREx_DisableBatteryCharging()\r\n          function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Enable the Backup Regulator.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Enable the Backup regulator */\r\n  SET_BIT (PWR->CR2, PWR_CR2_BREN);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick ();\r\n\r\n  /* Wait till Backup regulator ready flag is set */\r\n  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Disable the Backup Regulator.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Disable the Backup regulator */\r\n  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick ();\r\n\r\n  /* Wait till Backup regulator ready flag is reset */\r\n  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Enable the USB Regulator.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Enable the USB regulator */\r\n  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick ();\r\n\r\n  /* Wait till the USB regulator ready flag is set */\r\n  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Disable the USB Regulator.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Disable the USB regulator */\r\n  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);\r\n\r\n  /* Get tick */\r\n  tickstart = HAL_GetTick ();\r\n\r\n  /* Wait till the USB regulator ready flag is reset */\r\n  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Enable the USB voltage level detector.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableUSBVoltageDetector (void)\r\n{\r\n  /* Enable the USB voltage detector */\r\n  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);\r\n}\r\n\r\n/**\r\n  * @brief Disable the USB voltage level detector.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_DisableUSBVoltageDetector (void)\r\n{\r\n  /* Disable the USB voltage detector */\r\n  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);\r\n}\r\n\r\n/**\r\n  * @brief Enable the Battery charging.\r\n  * @note   When VDD is present, charge the external battery through an internal\r\n  *         resistor.\r\n  * @param  ResistorValue : Specifies the charging resistor.\r\n  *          This parameter can be one of the following values :\r\n  *            @arg PWR_BATTERY_CHARGING_RESISTOR_5 : 5 KOhm resistor.\r\n  *            @arg PWR_BATTERY_CHARGING_RESISTOR_1_5 : 1.5 KOhm resistor.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableBatteryCharging (uint32_t ResistorValue)\r\n{\r\n  /* Check the parameter */\r\n  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));\r\n\r\n  /* Specify the charging resistor */\r\n  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);\r\n\r\n  /* Enable the Battery charging */\r\n  SET_BIT (PWR->CR3, PWR_CR3_VBE);\r\n}\r\n\r\n/**\r\n  * @brief Disable the Battery charging.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_DisableBatteryCharging (void)\r\n{\r\n  /* Disable the Battery charging */\r\n  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);\r\n}\r\n\r\n#if defined (PWR_CR1_BOOSTE)\r\n/**\r\n  * @brief Enable the booster to guarantee the analog switch AC performance when\r\n  *        the VDD supply voltage is below 2V7.\r\n  * @note   The VDD supply voltage can be monitored through the PVD and the PLS\r\n  *         field bits.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableAnalogBooster (void)\r\n{\r\n  /* Enable the Analog voltage */\r\n  SET_BIT (PWR->CR1, PWR_CR1_AVD_READY);\r\n\r\n  /* Enable VDDA booster */\r\n  SET_BIT (PWR->CR1, PWR_CR1_BOOSTE);\r\n}\r\n\r\n/**\r\n  * @brief Disable the analog booster.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_DisableAnalogBooster (void)\r\n{\r\n  /* Disable VDDA booster */\r\n  CLEAR_BIT (PWR->CR1, PWR_CR1_BOOSTE);\r\n\r\n  /* Disable the Analog voltage */\r\n  CLEAR_BIT (PWR->CR1, PWR_CR1_AVD_READY);\r\n}\r\n#endif /* defined (PWR_CR1_BOOSTE) */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup PWREx_Exported_Functions_Group4 Power Monitoring functions\r\n  * @brief    Power Monitoring functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                 ##### Power Monitoring functions #####\r\n ===============================================================================\r\n\r\n    *** VBAT and Temperature supervision ***\r\n    ========================================\r\n    [..]\r\n      (+) The VBAT battery voltage supply can be monitored by comparing it with\r\n          two threshold levels: VBAThigh and VBATlow. VBATH flag and VBATL flags\r\n          in the PWR control register 2 (PWR_CR2), indicate if VBAT is higher or\r\n          lower than the threshold.\r\n      (+) The temperature can be monitored by comparing it with two threshold\r\n          levels, TEMPhigh and TEMPlow. TEMPH and TEMPL flags, in the PWR\r\n          control register 2 (PWR_CR2), indicate whether the device temperature\r\n          is higher or lower than the threshold.\r\n      (+) The VBAT and the temperature monitoring is enabled by\r\n          HAL_PWREx_EnableMonitoring() function and disabled by\r\n          HAL_PWREx_DisableMonitoring() function.\r\n      (+) The HAL_PWREx_GetVBATLevel() function returns the VBAT level which can\r\n          be : PWR_VBAT_BELOW_LOW_THRESHOLD or PWR_VBAT_ABOVE_HIGH_THRESHOLD or\r\n          PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD.\r\n      (+) The HAL_PWREx_GetTemperatureLevel() function returns the Temperature\r\n          level which can be :\r\n          PWR_TEMP_BELOW_LOW_THRESHOLD or PWR_TEMP_ABOVE_HIGH_THRESHOLD or\r\n          PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD.\r\n\r\n    *** AVD configuration ***\r\n    =========================\r\n    [..]\r\n      (+) The AVD is used to monitor the VDDA power supply by comparing it to a\r\n          threshold selected by the AVD Level (ALS[3:0] bits in the PWR_CR1\r\n          register).\r\n      (+) A AVDO flag is available to indicate if VDDA is higher or lower\r\n          than the AVD threshold. This event is internally connected to the EXTI\r\n          line 16 to generate an interrupt if enabled.\r\n          It is configurable through __HAL_PWR_AVD_EXTI_ENABLE_IT() macro.\r\n      (+) The AVD is stopped in System Standby mode.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Enable the VBAT and temperature monitoring.\r\n  * @retval HAL status.\r\n  */\r\nvoid HAL_PWREx_EnableMonitoring (void)\r\n{\r\n  /* Enable the VBAT and Temperature monitoring */\r\n  SET_BIT (PWR->CR2, PWR_CR2_MONEN);\r\n}\r\n\r\n/**\r\n  * @brief Disable the VBAT and temperature monitoring.\r\n  * @retval HAL status.\r\n  */\r\nvoid HAL_PWREx_DisableMonitoring (void)\r\n{\r\n  /* Disable the VBAT and Temperature monitoring */\r\n  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);\r\n}\r\n\r\n/**\r\n  * @brief Indicate whether the junction temperature is between, above or below\r\n  *        the thresholds.\r\n  * @retval Temperature level.\r\n  */\r\nuint32_t HAL_PWREx_GetTemperatureLevel (void)\r\n{\r\n  uint32_t tempLevel, regValue;\r\n\r\n  /* Read the temperature flags */\r\n  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));\r\n\r\n  /* Check if the temperature is below the threshold */\r\n  if (regValue == PWR_CR2_TEMPL)\r\n  {\r\n    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;\r\n  }\r\n  /* Check if the temperature is above the threshold */\r\n  else if (regValue == PWR_CR2_TEMPH)\r\n  {\r\n    tempLevel = PWR_TEMP_ABOVE_HIGH_THRESHOLD;\r\n  }\r\n  /* The temperature is between the thresholds */\r\n  else\r\n  {\r\n    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;\r\n  }\r\n\r\n  return tempLevel;\r\n}\r\n\r\n/**\r\n  * @brief Indicate whether the Battery voltage level is between, above or below\r\n  *        the thresholds.\r\n  * @retval VBAT level.\r\n  */\r\nuint32_t HAL_PWREx_GetVBATLevel (void)\r\n{\r\n  uint32_t VBATLevel, regValue;\r\n\r\n  /* Read the VBAT flags */\r\n  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));\r\n\r\n  /* Check if the VBAT is below the threshold */\r\n  if (regValue == PWR_CR2_VBATL)\r\n  {\r\n    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;\r\n  }\r\n  /* Check if the VBAT is above the threshold */\r\n  else if (regValue == PWR_CR2_VBATH)\r\n  {\r\n    VBATLevel = PWR_VBAT_ABOVE_HIGH_THRESHOLD;\r\n  }\r\n  /* The VBAT is between the thresholds */\r\n  else\r\n  {\r\n    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;\r\n  }\r\n\r\n  return VBATLevel;\r\n}\r\n\r\n#if defined (PWR_CSR1_MMCVDO)\r\n/**\r\n  * @brief Get the VDDMMC voltage level.\r\n  * @retval The VDDMMC voltage level.\r\n  */\r\nPWREx_MMC_VoltageLevel HAL_PWREx_GetMMCVoltage (void)\r\n{\r\n  PWREx_MMC_VoltageLevel mmc_voltage;\r\n\r\n  /* Check voltage detector output on VDDMMC value */\r\n  if ((PWR->CSR1 & PWR_CSR1_MMCVDO_Msk) == 0U)\r\n  {\r\n    mmc_voltage = PWR_MMC_VOLTAGE_BELOW_1V2;\r\n  }\r\n  else\r\n  {\r\n    mmc_voltage = PWR_MMC_VOLTAGE_EQUAL_ABOVE_1V2;\r\n  }\r\n\r\n  return mmc_voltage;\r\n}\r\n#endif /* defined (PWR_CSR1_MMCVDO) */\r\n\r\n/**\r\n  * @brief  Configure the event mode and the voltage threshold detected by the\r\n  *         Analog Voltage Detector (AVD).\r\n  * @param  sConfigAVD : Pointer to an PWREx_AVDTypeDef structure that contains\r\n  *                      the configuration information for the AVD.\r\n  * @note   Refer to the electrical characteristics of your device datasheet for\r\n  *         more details about the voltage threshold corresponding to each\r\n  *         detection level.\r\n  * @note   For dual core devices, please ensure to configure the EXTI lines for\r\n  *         the different Cortex-Mx through PWR_Exported_Macro provided by this\r\n  *         driver. All combination are allowed: wake up only Cortex-M7, wake up\r\n  *         only Cortex-M4 and wake up Cortex-M7 and Cortex-M4.\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_ConfigAVD (PWREx_AVDTypeDef *sConfigAVD)\r\n{\r\n  /* Check the parameters */\r\n  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));\r\n  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));\r\n\r\n  /* Set the ALS[18:17] bits according to AVDLevel value */\r\n  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);\r\n\r\n  /* Clear any previous config */\r\n#if !defined (DUAL_CORE)\r\n  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();\r\n  __HAL_PWR_AVD_EXTI_DISABLE_IT ();\r\n#endif /* !defined (DUAL_CORE) */\r\n\r\n  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();\r\n  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();\r\n\r\n#if !defined (DUAL_CORE)\r\n  /* Configure the interrupt mode */\r\n  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)\r\n  {\r\n    __HAL_PWR_AVD_EXTI_ENABLE_IT ();\r\n  }\r\n\r\n  /* Configure the event mode */\r\n  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)\r\n  {\r\n    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();\r\n  }\r\n#endif /* !defined (DUAL_CORE) */\r\n\r\n  /* Rising edge configuration */\r\n  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)\r\n  {\r\n    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();\r\n  }\r\n\r\n  /* Falling edge configuration */\r\n  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)\r\n  {\r\n    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Enable the Analog Voltage Detector (AVD).\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_EnableAVD (void)\r\n{\r\n  /* Enable the Analog Voltage Detector */\r\n  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);\r\n}\r\n\r\n/**\r\n  * @brief Disable the Analog Voltage Detector(AVD).\r\n  * @retval None.\r\n  */\r\nvoid HAL_PWREx_DisableAVD (void)\r\n{\r\n  /* Disable the Analog Voltage Detector */\r\n  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);\r\n}\r\n\r\n/**\r\n  * @brief  This function handles the PWR PVD/AVD interrupt request.\r\n  * @note   This API should be called under the PVD_AVD_IRQHandler().\r\n  * @retval None\r\n  */\r\nvoid HAL_PWREx_PVD_AVD_IRQHandler (void)\r\n{\r\n  /* Check if the Programmable Voltage Detector is enabled (PVD) */\r\n  if (READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)\r\n  {\r\n#if defined (DUAL_CORE)\r\n    if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n#endif /* defined (DUAL_CORE) */\r\n    {\r\n      /* Check PWR D1/CD EXTI flag */\r\n      if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)\r\n      {\r\n        /* PWR PVD interrupt user callback */\r\n        HAL_PWR_PVDCallback ();\r\n\r\n        /* Clear PWR EXTI D1/CD pending bit */\r\n        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();\r\n      }\r\n    }\r\n#if defined (DUAL_CORE)\r\n    else\r\n    {\r\n      /* Check PWR EXTI D2 flag */\r\n      if (__HAL_PWR_PVD_EXTID2_GET_FLAG () != 0U)\r\n      {\r\n        /* PWR PVD interrupt user callback */\r\n        HAL_PWR_PVDCallback ();\r\n\r\n        /* Clear PWR EXTI D2 pending bit */\r\n        __HAL_PWR_PVD_EXTID2_CLEAR_FLAG();\r\n      }\r\n    }\r\n#endif /* defined (DUAL_CORE) */\r\n  }\r\n\r\n  /* Check if the Analog Voltage Detector is enabled (AVD) */\r\n  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)\r\n  {\r\n#if defined (DUAL_CORE)\r\n    if (HAL_GetCurrentCPUID () == CM7_CPUID)\r\n#endif /* defined (DUAL_CORE) */\r\n    {\r\n      /* Check PWR EXTI D1/CD flag */\r\n      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)\r\n      {\r\n        /* PWR AVD interrupt user callback */\r\n        HAL_PWREx_AVDCallback ();\r\n\r\n        /* Clear PWR EXTI D1/CD pending bit */\r\n        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();\r\n      }\r\n    }\r\n#if defined (DUAL_CORE)\r\n    else\r\n    {\r\n      /* Check PWR EXTI D2 flag */\r\n      if (__HAL_PWR_AVD_EXTID2_GET_FLAG () != 0U)\r\n      {\r\n        /* PWR AVD interrupt user callback */\r\n        HAL_PWREx_AVDCallback ();\r\n\r\n        /* Clear PWR EXTI D2 pending bit */\r\n        __HAL_PWR_AVD_EXTID2_CLEAR_FLAG ();\r\n      }\r\n    }\r\n#endif /* defined (DUAL_CORE) */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief PWR AVD interrupt callback.\r\n  * @retval None.\r\n  */\r\n__weak void HAL_PWREx_AVDCallback (void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_PWR_AVDCallback can be implemented in the user file\r\n  */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_PWR_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_rcc.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_rcc.c\r\n  * @author  MCD Application Team\r\n  * @brief   RCC HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Reset and Clock Control (RCC) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### RCC specific features #####\r\n  ==============================================================================\r\n    [..]\r\n      After reset the device is running from Internal High Speed oscillator\r\n      (HSI 64MHz) with Flash 0 wait state,and all peripherals are off except\r\n      internal SRAM, Flash, JTAG and PWR\r\n      (+) There is no pre-scaler on High speed (AHB) and Low speed (APB) buses;\r\n          all peripherals mapped on these buses are running at HSI speed.\r\n      (+) The clock for all peripherals is switched off, except the SRAM and FLASH.\r\n      (+) All GPIOs are in analogue mode , except the JTAG pins which\r\n          are assigned to be used for debug purpose.\r\n\r\n    [..]\r\n      Once the device started from reset, the user application has to:\r\n      (+) Configure the clock source to be used to drive the System clock\r\n          (if the application needs higher frequency/performance)\r\n      (+) Configure the System clock frequency and Flash settings\r\n      (+) Configure the AHB and APB buses pre-scalers\r\n      (+) Enable the clock for the peripheral(s) to be used\r\n      (+) Configure the clock kernel source(s) for peripherals which clocks are not\r\n          derived from the System clock through :RCC_D1CCIPR,RCC_D2CCIP1R,RCC_D2CCIP2R\r\n          and RCC_D3CCIPR registers\r\n\r\n                      ##### RCC Limitations #####\r\n  ==============================================================================\r\n    [..]\r\n      A delay between an RCC peripheral clock enable and the effective peripheral\r\n      enabling should be taken into account in order to manage the peripheral read/write\r\n      from/to registers.\r\n      (+) This delay depends on the peripheral mapping.\r\n      (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle\r\n          after the clock enable bit is set on the hardware register\r\n      (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle\r\n          after the clock enable bit is set on the hardware register\r\n\r\n    [..]\r\n      Implemented Workaround:\r\n      (+) For AHB & APB peripherals, a dummy read to the peripheral register has been\r\n          inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.\r\n\r\n  @endverbatim\r\n ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCC  RCC\r\n  * @brief RCC HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_RCC_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/** @defgroup RCC_Private_Macros RCC Private Macros\r\n  * @{\r\n  */\r\n#define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()\r\n#define MCO1_GPIO_PORT        GPIOA\r\n#define MCO1_PIN              GPIO_PIN_8\r\n\r\n#define MCO2_CLK_ENABLE()      __HAL_RCC_GPIOC_CLK_ENABLE()\r\n#define MCO2_GPIO_PORT         GPIOC\r\n#define MCO2_PIN               GPIO_PIN_9\r\n\r\n/**\r\n  * @}\r\n  */\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @defgroup RCC_Private_Variables RCC Private Variables\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup RCC_Exported_Functions RCC Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions\r\n *  @brief    Initialization and Configuration functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n           ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]\r\n      This section provides functions allowing to configure the internal/external oscillators\r\n      (HSE, HSI, LSE,CSI, LSI,HSI48, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB3, AHB1\r\n       AHB2,AHB4,APB3, APB1L, APB1H, APB2, and APB4).\r\n\r\n    [..] Internal/external clock and PLL configuration\r\n         (#) HSI (high-speed internal), 64 MHz factory-trimmed RC used directly or through\r\n             the PLL as System clock source.\r\n         (#) CSI is a low-power RC oscillator which can be used directly as system clock, peripheral\r\n             clock, or PLL input.But even with frequency calibration, is less accurate than an\r\n             external crystal oscillator or ceramic resonator.\r\n         (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC\r\n             clock source.\r\n\r\n         (#) HSE (high-speed external), 4 to 48 MHz crystal oscillator used directly or\r\n             through the PLL as System clock source. Can be used also as RTC clock source.\r\n\r\n         (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.\r\n\r\n         (#) PLL , The RCC features three independent PLLs (clocked by HSI , HSE or CSI),\r\n             featuring three different output clocks and able  to work either in integer or Fractional mode.\r\n           (++) A main PLL, PLL1, which is generally used to provide clocks to the CPU\r\n                and to some peripherals.\r\n           (++) Two dedicated PLLs, PLL2 and PLL3, which are used to generate the kernel clock for peripherals.\r\n\r\n\r\n         (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs\r\n            (HSE used directly or through PLL as System clock source), the System clock\r\n             is automatically switched to HSI and an interrupt is generated if enabled.\r\n             The interrupt is linked to the Cortex-M NMI (Non-Mask-able Interrupt)\r\n             exception vector.\r\n\r\n         (#) MCO1 (micro controller clock output), used to output HSI, LSE, HSE, PLL1(PLL1_Q)\r\n             or HSI48 clock (through a configurable pre-scaler) on PA8 pin.\r\n\r\n         (#) MCO2 (micro controller clock output), used to output HSE, PLL2(PLL2_P), SYSCLK,\r\n             LSI, CSI, or PLL1(PLL1_P) clock (through a configurable pre-scaler) on PC9 pin.\r\n\r\n    [..] System, AHB and APB buses clocks configuration\r\n         (#) Several clock sources can be used to drive the System clock (SYSCLK): CSI,HSI,\r\n             HSE and PLL.\r\n             The AHB clock (HCLK) is derived from System core clock through configurable\r\n             pre-scaler and used to clock the CPU, memory and peripherals mapped\r\n             on AHB and APB bus of the 3 Domains (D1, D2, D3)* through configurable pre-scalers\r\n             and used to clock the peripherals mapped on these buses. You can use\r\n             \"HAL_RCC_GetSysClockFreq()\" function to retrieve system clock frequency.\r\n\r\n         -@- All the peripheral clocks are derived from the System clock (SYSCLK) except those\r\n             with dual clock domain where kernel source clock could be selected through\r\n             RCC_D1CCIPR,RCC_D2CCIP1R,RCC_D2CCIP2R and RCC_D3CCIPR registers.\r\n\r\n     (*) : 2 Domains (CD and SRD) for stm32h7a3xx and stm32h7b3xx family lines.\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Resets the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *            - HSI ON and used as system clock source\r\n  *            - HSE, PLL1, PLL2 and PLL3 OFF\r\n  *            - AHB, APB Bus pre-scaler set to 1.\r\n  *            - CSS, MCO1 and MCO2 OFF\r\n  *            - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *            - Peripheral clocks\r\n  *            - LSI, LSE and RTC clocks\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_DeInit(void)\r\n{\r\n  uint32_t tickstart;\r\n\r\n        /* Increasing the CPU frequency */\r\n  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Set HSION bit */\r\n  SET_BIT(RCC->CR, RCC_CR_HSION);\r\n\r\n  /* Wait till HSI is ready */\r\n  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Set HSITRIM[6:0] bits to the reset value */\r\n  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);\r\n\r\n  /* Reset CFGR register */\r\n  CLEAR_REG(RCC->CFGR);\r\n\r\n  /* Update the SystemCoreClock and SystemD2Clock global variables */\r\n  SystemCoreClock = HSI_VALUE;\r\n  SystemD2Clock = HSI_VALUE;\r\n\r\n  /* Adapt Systick interrupt period */\r\n  if(HAL_InitTick(uwTickPrio) != HAL_OK)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait till clock switch is ready */\r\n  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \\\r\n  | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);\r\n\r\n  /* Wait till HSE is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Clear PLLON bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);\r\n\r\n  /* Wait till PLL is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset PLL2ON bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);\r\n\r\n  /* Wait till PLL2 is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Get Start Tick */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Reset PLL3 bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);\r\n\r\n  /* Wait till PLL3 is disabled */\r\n  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)\r\n  {\r\n    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n#if defined(RCC_D1CFGR_HPRE)\r\n  /* Reset D1CFGR register */\r\n  CLEAR_REG(RCC->D1CFGR);\r\n\r\n  /* Reset D2CFGR register */\r\n  CLEAR_REG(RCC->D2CFGR);\r\n\r\n  /* Reset D3CFGR register */\r\n  CLEAR_REG(RCC->D3CFGR);\r\n#else\r\n  /* Reset CDCFGR1 register */\r\n  CLEAR_REG(RCC->CDCFGR1);\r\n\r\n  /* Reset CDCFGR2 register */\r\n  CLEAR_REG(RCC->CDCFGR2);\r\n\r\n  /* Reset SRDCFGR register */\r\n  CLEAR_REG(RCC->SRDCFGR);\r\n#endif\r\n\r\n  /* Reset PLLCKSELR register to default value */\r\n  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;\r\n\r\n  /* Reset PLLCFGR register to default value */\r\n  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);\r\n\r\n  /* Reset PLL1DIVR register to default value */\r\n  WRITE_REG(RCC->PLL1DIVR,0x01010280U);\r\n\r\n  /* Reset PLL1FRACR register */\r\n  CLEAR_REG(RCC->PLL1FRACR);\r\n\r\n  /* Reset PLL2DIVR register to default value */\r\n  WRITE_REG(RCC->PLL2DIVR,0x01010280U);\r\n\r\n  /* Reset PLL2FRACR register */\r\n  CLEAR_REG(RCC->PLL2FRACR);\r\n\r\n  /* Reset PLL3DIVR register to default value */\r\n  WRITE_REG(RCC->PLL3DIVR,0x01010280U);\r\n\r\n  /* Reset PLL3FRACR register */\r\n  CLEAR_REG(RCC->PLL3FRACR);\r\n\r\n#if defined(RCC_CR_HSEEXT)\r\n  /* Reset HSEEXT  */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);\r\n#endif /* RCC_CR_HSEEXT */\r\n\r\n  /* Reset HSEBYP bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);\r\n\r\n  /* Disable all interrupts */\r\n  CLEAR_REG(RCC->CIER);\r\n\r\n  /* Clear all interrupts flags */\r\n  WRITE_REG(RCC->CICR,0xFFFFFFFFU);\r\n\r\n  /* Reset all RSR flags */\r\n  SET_BIT(RCC->RSR, RCC_RSR_RMVF);\r\n\r\n      /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n}\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the RCC Oscillators according to the specified parameters in the\r\n  *         RCC_OscInitTypeDef.\r\n  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC Oscillators.\r\n  * @note   The PLL is not disabled when used as system clock.\r\n  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not\r\n  *         supported by this function. User should request a transition to LSE Off\r\n  *         first and then LSE On or LSE Bypass.\r\n  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not\r\n  *         supported by this function. User should request a transition to HSE Off\r\n  *         first and then HSE On or HSE Bypass.\r\n  * @retval HAL status\r\n  */\r\n__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  uint32_t tickstart;\r\n  uint32_t temp1_pllckcfg, temp2_pllckcfg;\r\n\r\n    /* Check Null pointer */\r\n  if(RCC_OscInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));\r\n  /*------------------------------- HSE Configuration ------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));\r\n\r\n    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();\r\n    const uint32_t temp_pllckselr = RCC->PLLCKSELR;\r\n    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */\r\n    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))\r\n    {\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Set the new HSE configuration ---------------------------------------*/\r\n      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);\r\n\r\n      /* Check the HSE State */\r\n      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)\r\n        {\r\n          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSE is disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)\r\n        {\r\n          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*----------------------------- HSI Configuration --------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));\r\n    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));\r\n\r\n    /* When the HSI is used as system clock it will not be disabled */\r\n    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();\r\n    const uint32_t temp_pllckselr = RCC->PLLCKSELR;\r\n    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))\r\n    {\r\n      /* When HSI is used as system clock it will not be disabled */\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Otherwise, only HSI division and calibration are allowed */\r\n      else\r\n      {\r\n          /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */\r\n          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);\r\n\r\n          /* Get Start Tick*/\r\n          tickstart = HAL_GetTick();\r\n\r\n          /* Wait till HSI is ready */\r\n          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\r\n          {\r\n            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n            {\r\n              return HAL_TIMEOUT;\r\n            }\r\n          }\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n    }\r\n\r\n    else\r\n    {\r\n      /* Check the HSI State */\r\n      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)\r\n      {\r\n     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */\r\n        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\r\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\r\n      }\r\n      else\r\n      {\r\n        /* Disable the Internal High Speed oscillator (HSI). */\r\n        __HAL_RCC_HSI_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till HSI is disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*----------------------------- CSI Configuration --------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));\r\n    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));\r\n\r\n    /* When the CSI is used as system clock it will not disabled */\r\n    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();\r\n    const uint32_t temp_pllckselr = RCC->PLLCKSELR;\r\n    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))\r\n    {\r\n      /* When CSI is used as system clock it will not disabled */\r\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      /* Otherwise, just the calibration is allowed */\r\n      else\r\n      {\r\n        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/\r\n        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Check the CSI State */\r\n      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)\r\n      {\r\n        /* Enable the Internal High Speed oscillator (CSI). */\r\n        __HAL_RCC_CSI_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till CSI is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/\r\n        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);\r\n      }\r\n      else\r\n      {\r\n        /* Disable the Internal High Speed oscillator (CSI). */\r\n        __HAL_RCC_CSI_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till CSI is disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSI Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));\r\n\r\n    /* Check the LSI State */\r\n    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)\r\n    {\r\n      /* Enable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_ENABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Disable the Internal Low Speed oscillator (LSI). */\r\n      __HAL_RCC_LSI_DISABLE();\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSI is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*------------------------------ HSI48 Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));\r\n\r\n    /* Check the HSI48 State */\r\n    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)\r\n    {\r\n      /* Enable the Internal Low Speed oscillator (HSI48). */\r\n      __HAL_RCC_HSI48_ENABLE();\r\n\r\n      /* Get time-out */\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till HSI48 is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Disable the Internal Low Speed oscillator (HSI48). */\r\n      __HAL_RCC_HSI48_DISABLE();\r\n\r\n      /* Get time-out */\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till HSI48 is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*------------------------------ LSE Configuration -------------------------*/\r\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));\r\n\r\n    /* Enable write access to Backup domain */\r\n    PWR->CR1 |= PWR_CR1_DBP;\r\n\r\n    /* Wait for Backup domain Write protection disable */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR1 & PWR_CR1_DBP) == 0U)\r\n    {\r\n      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Set the new LSE configuration -----------------------------------------*/\r\n    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);\r\n    /* Check the LSE State */\r\n    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is ready */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n      /* Wait till LSE is disabled */\r\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)\r\n      {\r\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\r\n        {\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /*-------------------------------- PLL Configuration -----------------------*/\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));\r\n  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)\r\n  {\r\n    /* Check if the PLL is used as system clock or not */\r\n    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)\r\n    {\r\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)\r\n      {\r\n        /* Check the parameters */\r\n        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));\r\n        assert_param(IS_RCC_PLLRGE_VALUE(RCC_OscInitStruct->PLL.PLLRGE));\r\n        assert_param(IS_RCC_PLLVCO_VALUE(RCC_OscInitStruct->PLL.PLLVCOSEL));\r\n        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));\r\n        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));\r\n        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));\r\n        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));\r\n        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));\r\n        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));\r\n\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n        /* Configure the main PLL clock source, multiplication and division factors. */\r\n        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,\r\n                             RCC_OscInitStruct->PLL.PLLM,\r\n                             RCC_OscInitStruct->PLL.PLLN,\r\n                             RCC_OscInitStruct->PLL.PLLP,\r\n                             RCC_OscInitStruct->PLL.PLLQ,\r\n                             RCC_OscInitStruct->PLL.PLLR);\r\n\r\n         /* Disable PLLFRACN . */\r\n         __HAL_RCC_PLLFRACN_DISABLE();\r\n\r\n         /* Configure PLL PLL1FRACN */\r\n         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);\r\n\r\n        /* Select PLL1 input reference frequency range: VCI */\r\n        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;\r\n\r\n        /* Select PLL1 output frequency range : VCO */\r\n        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;\r\n\r\n        /* Enable PLL System Clock output. */\r\n         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);\r\n\r\n        /* Enable PLL1Q Clock output. */\r\n         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n        /* Enable PLL1R  Clock output. */\r\n         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);\r\n\r\n        /* Enable PLL1FRACN . */\r\n         __HAL_RCC_PLLFRACN_ENABLE();\r\n\r\n        /* Enable the main PLL. */\r\n        __HAL_RCC_PLL_ENABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Disable the main PLL. */\r\n        __HAL_RCC_PLL_DISABLE();\r\n\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till PLL is disabled */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Do not return HAL_ERROR if request repeats the current configuration */\r\n      temp1_pllckcfg = RCC->PLLCKSELR;\r\n      temp2_pllckcfg = RCC->PLL1DIVR;\r\n      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||\r\n\t (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\r\n         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||\r\n         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||\r\n         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||\r\n         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||\r\n         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified\r\n  *         parameters in the RCC_ClkInitStruct.\r\n  * @param  RCC_ClkInitStruct: pointer to an RCC_OscInitTypeDef structure that\r\n  *         contains the configuration information for the RCC peripheral.\r\n  * @param  FLatency: FLASH Latency, this parameter depend on device selected\r\n  *\r\n  * @note   The SystemCoreClock CMSIS variable is used to store System Core Clock Frequency\r\n  *         and updated by HAL_InitTick() function called within this function\r\n  *\r\n  * @note   The HSI is used (enabled by hardware) as system clock source after\r\n  *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case\r\n  *         of failure of the HSE used directly or indirectly as system clock\r\n  *         (if the Clock Security System CSS is enabled).\r\n  *\r\n  * @note   A switch from one clock source to another occurs only if the target\r\n  *         clock source is ready (clock stable after start-up delay or PLL locked).\r\n  *         If a clock source which is not yet ready is selected, the switch will\r\n  *         occur when the clock source will be ready.\r\n  *         You can use HAL_RCC_GetClockConfig() function to know which clock is\r\n  *         currently used as system clock source.\r\n  * @note   Depending on the device voltage range, the software has to set correctly\r\n  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency\r\n  *         (for more details refer to section above \"Initialization/de-initialization functions\")\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)\r\n{\r\n  HAL_StatusTypeDef halstatus;\r\n  uint32_t tickstart;\r\n  uint32_t common_system_clock;\r\n\r\n   /* Check Null pointer */\r\n  if(RCC_ClkInitStruct == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));\r\n  assert_param(IS_FLASH_LATENCY(FLatency));\r\n\r\n  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)\r\n    must be correctly programmed according to the frequency of the CPU clock\r\n    (HCLK) and the supply voltage of the device. */\r\n\r\n  /* Increasing the CPU frequency */\r\n  if(FLatency > __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLatency);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if(__HAL_FLASH_GET_LATENCY() != FLatency)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n  }\r\n\r\n  /* Increasing the BUS frequency divider */\r\n  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)\r\n  {\r\n#if defined (RCC_D1CFGR_D1PPRE)\r\n    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))\r\n    {\r\n      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));\r\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);\r\n    }\r\n#else\r\n    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))\r\n    {\r\n      assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));\r\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);\r\n    }\r\n#endif\r\n  }\r\n\r\n  /*-------------------------- PCLK1 Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\r\n  {\r\n#if defined (RCC_D2CFGR_D2PPRE1)\r\n    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))\r\n    {\r\n      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\r\n      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\r\n    }\r\n#else\r\n    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))\r\n    {\r\n      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\r\n      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\r\n  }\r\n#endif\r\n    }\r\n  /*-------------------------- PCLK2 Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\r\n  {\r\n#if defined(RCC_D2CFGR_D2PPRE2)\r\n    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))\r\n    {\r\n      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\r\n      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\r\n    }\r\n#else\r\n     if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))\r\n    {\r\n      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\r\n      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\r\n    }\r\n#endif\r\n  }\r\n\r\n  /*-------------------------- D3PCLK1 Configuration ---------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)\r\n  {\r\n#if defined(RCC_D3CFGR_D3PPRE)\r\n    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))\r\n    {\r\n      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));\r\n      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );\r\n    }\r\n#else\r\n    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))\r\n    {\r\n      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));\r\n      MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider) );\r\n    }\r\n#endif\r\n  }\r\n\r\n   /*-------------------------- HCLK Configuration --------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\r\n  {\r\n#if defined (RCC_D1CFGR_HPRE)\r\n    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))\r\n    {\r\n      /* Set the new HCLK clock divider */\r\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\r\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\r\n    }\r\n#else\r\n        if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))\r\n    {\r\n      /* Set the new HCLK clock divider */\r\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\r\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\r\n    }\r\n#endif\r\n  }\r\n\r\n    /*------------------------- SYSCLK Configuration -------------------------*/\r\n    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)\r\n    {\r\n      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));\r\n      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));\r\n#if defined(RCC_D1CFGR_D1CPRE)\r\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);\r\n#else\r\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);\r\n#endif\r\n      /* HSE is selected as System Clock Source */\r\n      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)\r\n      {\r\n        /* Check the HSE ready flag */\r\n        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n      /* PLL is selected as System Clock Source */\r\n      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)\r\n      {\r\n        /* Check the PLL ready flag */\r\n        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n      /* CSI is selected as System Clock Source */\r\n      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)\r\n      {\r\n        /* Check the PLL ready flag */\r\n        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n      /* HSI is selected as System Clock Source */\r\n      else\r\n      {\r\n        /* Check the HSI ready flag */\r\n        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\r\n        {\r\n          return HAL_ERROR;\r\n        }\r\n      }\r\n      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);\r\n\r\n      /* Get Start Tick*/\r\n      tickstart = HAL_GetTick();\r\n\r\n        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))\r\n        {\r\n          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)\r\n          {\r\n            return HAL_TIMEOUT;\r\n          }\r\n        }\r\n\r\n    }\r\n\r\n    /* Decreasing the BUS frequency divider */\r\n   /*-------------------------- HCLK Configuration --------------------------*/\r\n  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)\r\n  {\r\n#if defined(RCC_D1CFGR_HPRE)\r\n    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))\r\n    {\r\n      /* Set the new HCLK clock divider */\r\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\r\n      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\r\n    }\r\n#else\r\n    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))\r\n    {\r\n      /* Set the new HCLK clock divider */\r\n      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));\r\n      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);\r\n    }\r\n#endif\r\n  }\r\n\r\n  /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(FLatency < __HAL_FLASH_GET_LATENCY())\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    __HAL_FLASH_SET_LATENCY(FLatency);\r\n\r\n    /* Check that the new number of wait states is taken into account to access the Flash\r\n    memory by reading the FLASH_ACR register */\r\n    if(__HAL_FLASH_GET_LATENCY() != FLatency)\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n }\r\n\r\n  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/\r\n if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)\r\n {\r\n#if defined(RCC_D1CFGR_D1PPRE)\r\n   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))\r\n   {\r\n     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));\r\n     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);\r\n   }\r\n#else\r\n   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))\r\n   {\r\n     assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));\r\n     MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);\r\n   }\r\n#endif\r\n }\r\n\r\n  /*-------------------------- PCLK1 Configuration ---------------------------*/\r\n if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)\r\n {\r\n#if defined(RCC_D2CFGR_D2PPRE1)\r\n   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))\r\n   {\r\n     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\r\n     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\r\n   }\r\n#else\r\n   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))\r\n   {\r\n     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));\r\n     MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));\r\n   }\r\n#endif\r\n }\r\n\r\n  /*-------------------------- PCLK2 Configuration ---------------------------*/\r\n if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)\r\n {\r\n#if defined (RCC_D2CFGR_D2PPRE2)\r\n   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))\r\n   {\r\n     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\r\n     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\r\n   }\r\n#else\r\n   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))\r\n   {\r\n     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));\r\n     MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));\r\n   }\r\n#endif\r\n }\r\n\r\n  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/\r\n if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)\r\n {\r\n#if defined(RCC_D3CFGR_D3PPRE)\r\n   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))\r\n   {\r\n     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));\r\n     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );\r\n   }\r\n#else\r\n   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))\r\n   {\r\n     assert_param(IS_RCC_SRDPCLK1(RCC_ClkInitStruct->APB4CLKDivider));\r\n     MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider) );\r\n   }\r\n#endif\r\n }\r\n\r\n  /* Update the SystemCoreClock global variable */\r\n#if defined(RCC_D1CFGR_D1CPRE)\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);\r\n#else\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);\r\n#endif\r\n\r\n#if defined(RCC_D1CFGR_HPRE)\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\r\n#else\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\r\n#endif\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  SystemCoreClock = SystemD2Clock;\r\n#else\r\n  SystemCoreClock = common_system_clock;\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n\r\n  /* Configure the source of time base considering new system clocks settings*/\r\n  halstatus = HAL_InitTick (uwTickPrio);\r\n\r\n  return halstatus;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCC_Group2 Peripheral Control functions\r\n *  @brief   RCC clocks control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the RCC Clocks\r\n    frequencies.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).\r\n  * @note   PA8/PC9 should be configured in alternate function mode.\r\n  * @param  RCC_MCOx: specifies the output direction for the clock source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).\r\n  *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).\r\n  * @param  RCC_MCOSource: specifies the clock source to output.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_PLL1QCLK:  PLL1Q clock selected as MCO1 source\r\n  *            @arg RCC_MCO1SOURCE_HSI48: HSI48 (48MHZ) selected as MCO1 source\r\n  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_PLL2PCLK: PLL2P clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_PLLCLK:  PLL1P clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_CSICLK:  CSI clock selected as MCO2 source\r\n  *            @arg RCC_MCO2SOURCE_LSICLK:  LSI clock selected as MCO2 source\r\n  * @param  RCC_MCODiv: specifies the MCOx pre-scaler.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)\r\n{\r\n  GPIO_InitTypeDef GPIO_InitStruct;\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_MCO(RCC_MCOx));\r\n  assert_param(IS_RCC_MCODIV(RCC_MCODiv));\r\n  /* RCC_MCO1 */\r\n  if(RCC_MCOx == RCC_MCO1)\r\n  {\r\n    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));\r\n\r\n    /* MCO1 Clock Enable */\r\n    MCO1_CLK_ENABLE();\r\n\r\n    /* Configure the MCO1 pin in alternate function mode */\r\n    GPIO_InitStruct.Pin = MCO1_PIN;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\r\n    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);\r\n\r\n    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */\r\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));\r\n  }\r\n  else\r\n  {\r\n    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));\r\n\r\n    /* MCO2 Clock Enable */\r\n    MCO2_CLK_ENABLE();\r\n\r\n    /* Configure the MCO2 pin in alternate function mode */\r\n    GPIO_InitStruct.Pin = MCO2_PIN;\r\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\r\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\r\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\r\n    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;\r\n    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);\r\n\r\n    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */\r\n    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enables the Clock Security System.\r\n  * @note   If a failure is detected on the HSE oscillator clock, this oscillator\r\n  *         is automatically disabled and an interrupt is generated to inform the\r\n  *         software about the failure (Clock Security System Interrupt, CSSI),\r\n  *         allowing the MCU to perform rescue operations. The CSSI is linked to\r\n  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_EnableCSS(void)\r\n{\r\n  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Clock Security System.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_DisableCSS(void)\r\n{\r\n  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);\r\n}\r\n\r\n/**\r\n  * @brief  Returns the SYSCLK frequency\r\n  *\r\n  * @note   The system frequency computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     If SYSCLK source is CSI, function returns values based on CSI_VALUE(*)\r\n  * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(**)\r\n  * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)\r\n  * @note     If SYSCLK source is PLL, function returns values based on CSI_VALUE(*),\r\n  *           HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.\r\n  * @note     (*) CSI_VALUE is a constant defined in stm32h7xx_hal_conf.h file (default value\r\n  *               4 MHz) but the real value may vary depending on the variations\r\n  *               in voltage and temperature.\r\n  * @note     (**) HSI_VALUE is a constant defined in stm32h7xx_hal_conf.h file (default value\r\n  *               64 MHz) but the real value may vary depending on the variations\r\n  *               in voltage and temperature.\r\n  * @note     (***) HSE_VALUE is a constant defined in stm32h7xx_hal_conf.h file (default value\r\n  *                25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *                frequency of the crystal used. Otherwise, this function may\r\n  *                have wrong result.\r\n  *\r\n  * @note   The result of this function could be not correct when using fractional\r\n  *         value for HSE crystal.\r\n  *\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud rate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time SYSCLK changes, this function must be called to update the\r\n  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  *\r\n  *\r\n  * @retval SYSCLK frequency\r\n  */\r\nuint32_t HAL_RCC_GetSysClockFreq(void)\r\n{\r\n  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue;\r\n  float_t fracn1, pllvco;\r\n  uint32_t sysclockfreq;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n\r\n  switch (RCC->CFGR & RCC_CFGR_SWS)\r\n  {\r\n  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */\r\n\r\n   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n      {\r\n        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n      }\r\n      else\r\n      {\r\n        sysclockfreq = (uint32_t) HSI_VALUE;\r\n      }\r\n\r\n    break;\r\n\r\n  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */\r\n    sysclockfreq = CSI_VALUE;\r\n    break;\r\n\r\n  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */\r\n    sysclockfreq = HSE_VALUE;\r\n    break;\r\n\r\n  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */\r\n\r\n    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN\r\n    SYSCLK = PLL_VCO / PLLR\r\n    */\r\n    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\r\n    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;\r\n    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);\r\n    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));\r\n\r\n    if (pllm != 0U)\r\n    {\r\n      switch (pllsource)\r\n      {\r\n      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n\r\n       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n        {\r\n          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        }\r\n        else\r\n        {\r\n          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        }\r\n        break;\r\n\r\n      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */\r\n        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        break;\r\n\r\n      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        break;\r\n\r\n      default:\r\n        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        break;\r\n      }\r\n      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;\r\n      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);\r\n    }\r\n    else\r\n    {\r\n      sysclockfreq = 0U;\r\n    }\r\n    break;\r\n\r\n  default:\r\n    sysclockfreq = CSI_VALUE;\r\n    break;\r\n  }\r\n\r\n  return sysclockfreq;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Returns the HCLK frequency\r\n  * @note   Each time HCLK changes, this function must be called to update the\r\n  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  *\r\n  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency\r\n  *         and updated within this function\r\n  * @retval HCLK frequency\r\n  */\r\nuint32_t HAL_RCC_GetHCLKFreq(void)\r\n{\r\nuint32_t common_system_clock;\r\n\r\n#if defined(RCC_D1CFGR_D1CPRE)\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);\r\n#else\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);\r\n#endif\r\n\r\n#if defined(RCC_D1CFGR_HPRE)\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\r\n#else\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\r\n#endif\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  SystemCoreClock = SystemD2Clock;\r\n#else\r\n  SystemCoreClock = common_system_clock;\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n\r\n  return SystemD2Clock;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Returns the PCLK1 frequency\r\n  * @note   Each time PCLK1 changes, this function must be called to update the\r\n  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval PCLK1 frequency\r\n  */\r\nuint32_t HAL_RCC_GetPCLK1Freq(void)\r\n{\r\n#if defined (RCC_D2CFGR_D2PPRE1)\r\n  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));\r\n#else\r\n /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));\r\n#endif\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Returns the PCLK2 frequency\r\n  * @note   Each time PCLK2 changes, this function must be called to update the\r\n  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval PCLK1 frequency\r\n  */\r\nuint32_t HAL_RCC_GetPCLK2Freq(void)\r\n{\r\n  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/\r\n#if defined(RCC_D2CFGR_D2PPRE2)\r\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));\r\n#else\r\n  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));\r\n#endif\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_OscInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that\r\n  * will be configured.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)\r\n{\r\n  /* Set all possible values for the Oscillator type parameter ---------------*/\r\n  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \\\r\n                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI| RCC_OSCILLATORTYPE_HSI48;\r\n\r\n  /* Get the HSE configuration -----------------------------------------------*/\r\n#if defined(RCC_CR_HSEEXT)\r\n  if((RCC->CR &(RCC_CR_HSEBYP | RCC_CR_HSEEXT)) == RCC_CR_HSEBYP)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\r\n  }\r\n  else if((RCC->CR &(RCC_CR_HSEBYP | RCC_CR_HSEEXT)) == (RCC_CR_HSEBYP | RCC_CR_HSEEXT))\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS_DIGITAL;\r\n  }\r\n  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\r\n  }\r\n#else\r\n  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\r\n  }\r\n  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\r\n  }\r\n#endif /* RCC_CR_HSEEXT */\r\n\r\n   /* Get the CSI configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)\r\n  {\r\n    RCC_OscInitStruct->CSIState = RCC_CSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;\r\n  }\r\n\r\n#if defined(RCC_VER_X)\r\n  if(HAL_GetREVID() <= REV_ID_Y)\r\n  {\r\n    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);\r\n  }\r\n#else\r\n RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);\r\n#endif /*RCC_VER_X*/\r\n\r\n  /* Get the HSI configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\r\n  }\r\n\r\n#if defined(RCC_VER_X)\r\n  if(HAL_GetREVID() <= REV_ID_Y)\r\n  {\r\n    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);\r\n  }\r\n#else\r\n    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);\r\n#endif /*RCC_VER_X*/\r\n\r\n  /* Get the LSE configuration -----------------------------------------------*/\r\n#if defined(RCC_BDCR_LSEEXT)\r\n  if((RCC->BDCR &(RCC_BDCR_LSEBYP|RCC_BDCR_LSEEXT)) == RCC_BDCR_LSEBYP)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\r\n  }\r\n  else if((RCC->BDCR &(RCC_BDCR_LSEBYP|RCC_BDCR_LSEEXT)) == (RCC_BDCR_LSEBYP|RCC_BDCR_LSEEXT))\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_DIGITAL;\r\n  }\r\n  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\r\n  }\r\n#else\r\n  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\r\n  }\r\n  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\r\n  }\r\n#endif /* RCC_BDCR_LSEEXT */\r\n\r\n  /* Get the LSI configuration -----------------------------------------------*/\r\n  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\r\n  }\r\n\r\n  /* Get the HSI48 configuration ---------------------------------------------*/\r\n  if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)\r\n  {\r\n    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;\r\n  }\r\n\r\n  /* Get the PLL configuration -----------------------------------------------*/\r\n  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\r\n  }\r\n  else\r\n  {\r\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\r\n  }\r\n  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\r\n  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);\r\n  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;\r\n  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;\r\n  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;\r\n  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;\r\n  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));\r\n  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);\r\n  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));\r\n}\r\n\r\n/**\r\n  * @brief  Configures the RCC_ClkInitStruct according to the internal\r\n  * RCC configuration registers.\r\n  * @param  RCC_ClkInitStruct: pointer to an RCC_ClkInitTypeDef structure that\r\n  * will be configured.\r\n  * @param  pFLatency: Pointer on the Flash Latency.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)\r\n{\r\n  /* Set all possible values for the Clock type parameter --------------------*/\r\n  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |\r\n                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;\r\n\r\n  /* Get the SYSCLK configuration --------------------------------------------*/\r\n  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);\r\n\r\n#if defined(RCC_D1CFGR_D1CPRE)\r\n  /* Get the SYSCLK configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);\r\n\r\n  /* Get the D1HCLK configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);\r\n\r\n  /* Get the APB3 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);\r\n\r\n  /* Get the APB1 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);\r\n\r\n  /* Get the APB2 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);\r\n\r\n  /* Get the APB4 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);\r\n#else\r\n  /* Get the SYSCLK configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE);\r\n\r\n  /* Get the D1HCLK configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE);\r\n\r\n  /* Get the APB3 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE);\r\n\r\n  /* Get the APB1 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1);\r\n\r\n  /* Get the APB2 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2);\r\n\r\n  /* Get the APB4 configuration ----------------------------------------------*/\r\n  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);\r\n#endif\r\n\r\n  /* Get the Flash Wait State (Latency) configuration ------------------------*/\r\n  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);\r\n}\r\n\r\n/**\r\n  * @brief This function handles the RCC CSS interrupt request.\r\n  * @note This API should be called under the NMI_Handler().\r\n  * @retval None\r\n  */\r\nvoid HAL_RCC_NMI_IRQHandler(void)\r\n{\r\n  /* Check RCC CSSF flag  */\r\n  if(__HAL_RCC_GET_IT(RCC_IT_CSS))\r\n  {\r\n    /* RCC Clock Security System interrupt user callback */\r\n    HAL_RCC_CCSCallback();\r\n\r\n    /* Clear RCC CSS pending bit */\r\n    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  RCC Clock Security System interrupt callback\r\n  * @retval none\r\n  */\r\n__weak void HAL_RCC_CCSCallback(void)\r\n{\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_RCC_CCSCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_RCC_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_rcc_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_rcc_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended RCC HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities RCC extension peripheral:\r\n  *           + Extended Peripheral Control functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCCEx  RCCEx\r\n  * @brief RCC HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_RCC_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines -----------------------------------------------------------*/\r\n/** @defgroup RCCEx_Private_defines RCCEx Private Defines\r\n * @{\r\n */\r\n#define PLL2_TIMEOUT_VALUE         PLL_TIMEOUT_VALUE    /* 2 ms */\r\n#define PLL3_TIMEOUT_VALUE         PLL_TIMEOUT_VALUE    /* 2 ms */\r\n\r\n#define DIVIDER_P_UPDATE          0U\r\n#define DIVIDER_Q_UPDATE          1U\r\n#define DIVIDER_R_UPDATE          2U\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @defgroup RCCEx_Private_Macros RCCEx Private Macros\r\n * @{\r\n */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\nstatic HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider);\r\nstatic HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider);\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions\r\n *  @brief  Extended Peripheral Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended Peripheral Control functions  #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the RCC Clocks\r\n    frequencies.\r\n    [..]\r\n    (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to\r\n        select the RTC clock source; in this case the Backup domain will be reset in\r\n        order to modify the RTC Clock source, as consequence RTC registers (including\r\n        the backup registers) and RCC_BDCR register are set to their reset values.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the RCC extended peripherals clocks according to the specified\r\n  *         parameters in the RCC_PeriphCLKInitTypeDef.\r\n  * @param  PeriphClkInit: pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         contains the configuration information for the Extended Peripherals\r\n  *         clocks (SDMMC, CKPER, FMC, QSPI*, OSPI*, DSI, SPI45, SPDIF, DFSDM1, DFSDM2*, FDCAN, SWPMI, SAI23*,SAI2A*, SAI2B*, SAI1, SPI123,\r\n  *         USART234578, USART16 (USART16910*), RNG, HRTIM1*, I2C123 (I2C1235*), USB, CEC, LPTIM1, LPUART1, I2C4, LPTIM2, LPTIM345, ADC,\r\n  *         SAI4A*, SAI4B*, SPI6, RTC).\r\n  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select\r\n  *         the RTC clock source; in this case the Backup domain will be reset in\r\n  *         order to modify the RTC Clock source, as consequence RTC registers (including\r\n  *         the backup registers) are set to their reset values.\r\n  *\r\n  * (*) : Available on some STM32H7 lines only.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  uint32_t tmpreg;\r\n  uint32_t tickstart;\r\n  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */\r\n  HAL_StatusTypeDef status = HAL_OK;   /* Final status */\r\n\r\n  /*---------------------------- SPDIFRX configuration -------------------------------*/\r\n\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)\r\n  {\r\n\r\n    switch(PeriphClkInit->SpdifrxClockSelection)\r\n    {\r\n    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/\r\n      /* Enable PLL1Q Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SPDIFRX clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);\r\n\r\n      /* SPDIFRX clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);\r\n\r\n      /* SPDIFRX clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPDIFRXCLKSOURCE_HSI:\r\n      /* Internal OSC clock is used as source of SPDIFRX clock*/\r\n      /* SPDIFRX clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SPDIFRX clock*/\r\n      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- SAI1 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)\r\n  {\r\n    switch(PeriphClkInit->Sai1ClockSelection)\r\n    {\r\n    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/\r\n      /* Enable SAI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI1CLKSOURCE_PIN:\r\n      /* External clock is used as source of SAI1 clock*/\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI1CLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SAI1 clock*/\r\n      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n#if defined(SAI3)\r\n  /*---------------------------- SAI2/3 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)\r\n  {\r\n    switch(PeriphClkInit->Sai23ClockSelection)\r\n    {\r\n    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */\r\n      /* Enable SAI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SAI2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI23CLKSOURCE_PIN:\r\n      /* External clock is used as source of SAI2/3 clock*/\r\n      /* SAI2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI23CLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */\r\n      /* SAI2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SAI2/3 clock*/\r\n      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n#endif /* SAI3 */\r\n\r\n#if defined(RCC_CDCCIP1R_SAI2ASEL)\r\n  /*---------------------------- SAI2A configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2A) == RCC_PERIPHCLK_SAI2A)\r\n  {\r\n    switch(PeriphClkInit->Sai2AClockSelection)\r\n    {\r\n    case RCC_SAI2ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2A */\r\n      /* Enable SAI2A Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SAI2A clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2A */\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2A clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2A */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2A clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2ACLKSOURCE_PIN:\r\n      /* External clock is used as source of SAI2A clock*/\r\n      /* SAI2A clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2ACLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SAI2A clock */\r\n      /* SAI2A clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2ACLKSOURCE_SPDIF:\r\n      /* SPDIF clock is used as source of SAI2A clock */\r\n      /* SAI2A clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SAI2A clock*/\r\n      __HAL_RCC_SAI2A_CONFIG(PeriphClkInit->Sai2AClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif  /*SAI2A*/\r\n\r\n#if defined(RCC_CDCCIP1R_SAI2BSEL)\r\n\r\n  /*---------------------------- SAI2B configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2B) == RCC_PERIPHCLK_SAI2B)\r\n  {\r\n    switch(PeriphClkInit->Sai2BClockSelection)\r\n    {\r\n    case RCC_SAI2BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2B */\r\n      /* Enable SAI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SAI2B clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2B */\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2B clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2B */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2B clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2BCLKSOURCE_PIN:\r\n      /* External clock is used as source of SAI2B clock*/\r\n      /* SAI2B clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2BCLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SAI2B clock */\r\n      /* SAI2B clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI2BCLKSOURCE_SPDIF:\r\n      /* SPDIF clock is used as source of SAI2B clock */\r\n      /* SAI2B clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SAI2B clock*/\r\n      __HAL_RCC_SAI2B_CONFIG(PeriphClkInit->Sai2BClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif  /*SAI2B*/\r\n\r\n#if defined(SAI4)\r\n  /*---------------------------- SAI4A configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)\r\n  {\r\n    switch(PeriphClkInit->Sai4AClockSelection)\r\n    {\r\n    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/\r\n      /* Enable SAI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4ACLKSOURCE_PIN:\r\n      /* External clock is used as source of SAI2 clock*/\r\n      /* SAI2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4ACLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n \r\n#if defined(RCC_VER_3_0)\r\n    case RCC_SAI4ACLKSOURCE_SPDIF:\r\n      /* SPDIF clock is used as source of SAI4A clock */\r\n      /* SAI4A clock source configuration done later after clock selection check */\r\n      break;\r\n#endif /* RCC_VER_3_0 */\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SAI4A clock*/\r\n      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n  /*---------------------------- SAI4B configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)\r\n  {\r\n    switch(PeriphClkInit->Sai4BClockSelection)\r\n    {\r\n    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/\r\n      /* Enable SAI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SAI2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);\r\n\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4BCLKSOURCE_PIN:\r\n      /* External clock is used as source of SAI2 clock*/\r\n      /* SAI2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SAI4BCLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */\r\n      /* SAI1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n#if defined(RCC_VER_3_0)\r\n    case RCC_SAI4BCLKSOURCE_SPDIF:\r\n      /* SPDIF clock is used as source of SAI4B clock */\r\n      /* SAI4B clock source configuration done later after clock selection check */\r\n      break;\r\n#endif /* RCC_VER_3_0 */\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SAI4B clock*/\r\n      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif  /*SAI4*/\r\n\r\n#if defined(QUADSPI)\r\n  /*---------------------------- QSPI configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)\r\n  {\r\n    switch(PeriphClkInit->QspiClockSelection)\r\n    {\r\n    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/\r\n      /* Enable QSPI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* QSPI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);\r\n\r\n      /* QSPI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n\r\n    case RCC_QSPICLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of QSPI clock */\r\n      /* QSPI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_QSPICLKSOURCE_D1HCLK:\r\n      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of QSPI clock*/\r\n      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif  /*QUADSPI*/\r\n\r\n#if defined(OCTOSPI1) || defined(OCTOSPI2)\r\n  /*---------------------------- OCTOSPI configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)\r\n  {\r\n    switch(PeriphClkInit->OspiClockSelection)\r\n    {\r\n    case RCC_OSPICLKSOURCE_PLL:      /* PLL is used as clock source for OSPI*/\r\n      /* Enable OSPI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* OSPI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_OSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for OSPI*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);\r\n\r\n      /* OSPI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n\r\n    case RCC_OSPICLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of OSPI clock */\r\n      /* OSPI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_OSPICLKSOURCE_HCLK:\r\n      /* HCLK clock selected as OSPI kernel peripheral clock */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of OSPI clock*/\r\n      __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif  /*OCTOSPI*/\r\n\r\n  /*---------------------------- SPI1/2/3 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)\r\n  {\r\n    switch(PeriphClkInit->Spi123ClockSelection)\r\n    {\r\n    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */\r\n      /* Enable SPI Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SPI1/2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* SPI1/2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);\r\n\r\n      /* SPI1/2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI123CLKSOURCE_PIN:\r\n      /* External clock is used as source of SPI1/2/3 clock*/\r\n      /* SPI1/2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI123CLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */\r\n      /* SPI1/2/3 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SPI1/2/3 clock*/\r\n      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- SPI4/5 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)\r\n  {\r\n    switch(PeriphClkInit->Spi45ClockSelection)\r\n    {\r\n    case RCC_SPI45CLKSOURCE_PCLK1:      /* CD/D2 PCLK1 as clock source for SPI4/5 */\r\n      /* SPI4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n\r\n      /* SPI4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);\r\n      /* SPI4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI45CLKSOURCE_HSI:\r\n      /* HSI oscillator clock is used as source of SPI4/5 clock*/\r\n      /* SPI4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI45CLKSOURCE_CSI:\r\n      /*  CSI oscillator clock is used as source of SPI4/5 clock */\r\n      /* SPI4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI45CLKSOURCE_HSE:\r\n      /* HSE,  oscillator is used as source of SPI4/5 clock */\r\n      /* SPI4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SPI4/5 clock*/\r\n      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- SPI6 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)\r\n  {\r\n    switch(PeriphClkInit->Spi6ClockSelection)\r\n    {\r\n    case RCC_SPI6CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for SPI6*/\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI6CLKSOURCE_HSI:\r\n      /* HSI oscillator clock is used as source of SPI6 clock*/\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI6CLKSOURCE_CSI:\r\n      /*  CSI oscillator clock is used as source of SPI6 clock */\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SPI6CLKSOURCE_HSE:\r\n      /* HSE,  oscillator is used as source of SPI6 clock */\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n#if defined(RCC_SPI6CLKSOURCE_PIN)\r\n    case RCC_SPI6CLKSOURCE_PIN:\r\n      /* 2S_CKIN is used as source of SPI6 clock */\r\n      /* SPI6 clock source configuration done later after clock selection check */\r\n      break;\r\n#endif\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SPI6 clock*/\r\n      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n#if defined(DSI)\r\n  /*---------------------------- DSI configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)\r\n  {\r\n    switch(PeriphClkInit->DsiClockSelection)\r\n    {\r\n\r\n    case RCC_DSICLKSOURCE_PLL2: /* PLL2 is used as clock source for DSI*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n\r\n      /* DSI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_DSICLKSOURCE_PHY:\r\n      /* PHY is used as clock source for DSI*/\r\n      /* DSI clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of DSI clock*/\r\n      __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif /*DSI*/\r\n\r\n#if defined(FDCAN1) || defined(FDCAN2)\r\n  /*---------------------------- FDCAN configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)\r\n  {\r\n    switch(PeriphClkInit->FdcanClockSelection)\r\n    {\r\n    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/\r\n      /* Enable FDCAN Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* FDCAN clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n\r\n      /* FDCAN clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_FDCANCLKSOURCE_HSE:\r\n      /* HSE is used as clock source for FDCAN*/\r\n      /* FDCAN clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of FDCAN clock*/\r\n      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n#endif /*FDCAN1 || FDCAN2*/\r\n\r\n  /*---------------------------- FMC configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)\r\n  {\r\n    switch(PeriphClkInit->FmcClockSelection)\r\n    {\r\n    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/\r\n      /* Enable FMC Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* FMC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);\r\n\r\n      /* FMC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n\r\n    case RCC_FMCCLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of FMC clock */\r\n      /* FMC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_FMCCLKSOURCE_HCLK:\r\n      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of FMC clock*/\r\n      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- RTC configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)\r\n  {\r\n    /* check for RTC Parameters used to output RTCCLK */\r\n    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));\r\n\r\n    /* Enable write access to Backup domain */\r\n    SET_BIT(PWR->CR1, PWR_CR1_DBP);\r\n\r\n    /* Wait for Backup domain Write protection disable */\r\n    tickstart = HAL_GetTick();\r\n\r\n    while((PWR->CR1 & PWR_CR1_DBP) == 0U)\r\n    {\r\n      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\r\n      {\r\n        ret = HAL_TIMEOUT;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Reset the Backup domain only if the RTC Clock source selection is modified */\r\n      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))\r\n      {\r\n        /* Store the content of BDCR register before the reset of Backup Domain */\r\n        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));\r\n        /* RTC Clock selection can be changed only if the Backup Domain is reset */\r\n        __HAL_RCC_BACKUPRESET_FORCE();\r\n        __HAL_RCC_BACKUPRESET_RELEASE();\r\n        /* Restore the Content of BDCR register */\r\n        RCC->BDCR = tmpreg;\r\n      }\r\n\r\n      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */\r\n      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)\r\n      {\r\n        /* Get Start Tick*/\r\n        tickstart = HAL_GetTick();\r\n\r\n        /* Wait till LSE is ready */\r\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)\r\n        {\r\n          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)\r\n          {\r\n            ret = HAL_TIMEOUT;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if(ret == HAL_OK)\r\n      {\r\n        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);\r\n      }\r\n      else\r\n      {\r\n        /* set overall return value */\r\n        status = ret;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n\r\n  /*-------------------------- USART1/6 configuration --------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)\r\n  {\r\n    switch(PeriphClkInit->Usart16ClockSelection)\r\n    {\r\n    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */\r\n      /* USART1/6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n      /* USART1/6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);\r\n      /* USART1/6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART16CLKSOURCE_HSI:\r\n      /* HSI oscillator clock is used as source of USART1/6 clock */\r\n      /* USART1/6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART16CLKSOURCE_CSI:\r\n      /* CSI oscillator clock is used as source of USART1/6 clock */\r\n      /* USART1/6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART16CLKSOURCE_LSE:\r\n      /* LSE,  oscillator is used as source of USART1/6 clock */\r\n      /* USART1/6 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of USART1/6 clock */\r\n      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)\r\n  {\r\n    switch(PeriphClkInit->Usart234578ClockSelection)\r\n    {\r\n    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */\r\n      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);\r\n      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART234578CLKSOURCE_HSI:\r\n      /* HSI oscillator clock is used as source of USART2/3/4/5/7/8 clock */\r\n      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART234578CLKSOURCE_CSI:\r\n      /* CSI oscillator clock is used as source of USART2/3/4/5/7/8 clock */\r\n      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USART234578CLKSOURCE_LSE:\r\n      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */\r\n      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of USART2/3/4/5/7/8 clock */\r\n      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*-------------------------- LPUART1 Configuration -------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)\r\n  {\r\n    switch(PeriphClkInit->Lpuart1ClockSelection)\r\n    {\r\n    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */\r\n      /* LPUART1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);\r\n      /* LPUART1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);\r\n      /* LPUART1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPUART1CLKSOURCE_HSI:\r\n      /* HSI oscillator clock is used as source of LPUART1 clock */\r\n      /* LPUART1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPUART1CLKSOURCE_CSI:\r\n      /* CSI oscillator clock is used as source of LPUART1 clock */\r\n      /* LPUART1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPUART1CLKSOURCE_LSE:\r\n      /* LSE,  oscillator is used as source of LPUART1 clock */\r\n      /* LPUART1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of LPUART1 clock */\r\n      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- LPTIM1 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)\r\n  {\r\n    switch(PeriphClkInit->Lptim1ClockSelection)\r\n    {\r\n    case RCC_LPTIM1CLKSOURCE_PCLK1:      /* CD/D2 PCLK1 as clock source for LPTIM1*/\r\n      /* LPTIM1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* LPTIM1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);\r\n\r\n      /* LPTIM1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM1CLKSOURCE_LSE:\r\n      /* External low speed OSC clock is used as source of LPTIM1 clock*/\r\n      /* LPTIM1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM1CLKSOURCE_LSI:\r\n      /* Internal  low speed OSC clock is used  as source of LPTIM1 clock*/\r\n      /* LPTIM1 clock source configuration done later after clock selection check */\r\n      break;\r\n    case RCC_LPTIM1CLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */\r\n      /* LPTIM1 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of LPTIM1 clock*/\r\n      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- LPTIM2 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)\r\n  {\r\n    switch(PeriphClkInit->Lptim2ClockSelection)\r\n    {\r\n    case RCC_LPTIM2CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM2*/\r\n      /* LPTIM2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* LPTIM2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);\r\n\r\n      /* LPTIM2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM2CLKSOURCE_LSE:\r\n      /* External low speed OSC clock is used as source of LPTIM2 clock*/\r\n      /* LPTIM2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM2CLKSOURCE_LSI:\r\n      /* Internal  low speed OSC clock is used  as source of LPTIM2 clock*/\r\n      /* LPTIM2 clock source configuration done later after clock selection check */\r\n      break;\r\n    case RCC_LPTIM2CLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */\r\n      /* LPTIM2 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of LPTIM2 clock*/\r\n      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*---------------------------- LPTIM345 configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)\r\n  {\r\n    switch(PeriphClkInit->Lptim345ClockSelection)\r\n    {\r\n\r\n    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */\r\n      /* LPTIM3/4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* LPTIM3/4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);\r\n\r\n      /* LPTIM3/4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM345CLKSOURCE_LSE:\r\n      /* External low speed OSC clock is used as source of LPTIM3/4/5 clock */\r\n      /* LPTIM3/4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_LPTIM345CLKSOURCE_LSI:\r\n      /* Internal  low speed OSC clock is used  as source of LPTIM3/4/5 clock */\r\n      /* LPTIM3/4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n    case RCC_LPTIM345CLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */\r\n      /* LPTIM3/4/5 clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of LPTIM3/4/5 clock */\r\n      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*------------------------------ I2C1/2/3/5* Configuration ------------------------*/\r\n#if defined(I2C5)\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1235) == RCC_PERIPHCLK_I2C1235)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C1235CLKSOURCE(PeriphClkInit->I2c1235ClockSelection));\r\n\r\n    if ((PeriphClkInit->I2c1235ClockSelection )== RCC_I2C1235CLKSOURCE_PLL3 )\r\n    {\r\n        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n    }\r\n\r\n      __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);\r\n\r\n  }\r\n#else\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));\r\n\r\n    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )\r\n    {\r\n        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)\r\n        {\r\n          status = HAL_ERROR;\r\n        }\r\n    }\r\n\r\n      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);\r\n\r\n  }\r\n#endif /* I2C5 */\r\n\r\n  /*------------------------------ I2C4 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));\r\n\r\n    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )\r\n    {\r\n      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)\r\n      {\r\n        status = HAL_ERROR;\r\n      }\r\n    }\r\n\r\n      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);\r\n\r\n  }\r\n\r\n  /*---------------------------- ADC configuration -------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)\r\n  {\r\n    switch(PeriphClkInit->AdcClockSelection)\r\n    {\r\n\r\n    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);\r\n\r\n      /* ADC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);\r\n\r\n      /* ADC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_ADCCLKSOURCE_CLKP:\r\n      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */\r\n      /* ADC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of ADC clock*/\r\n      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n  /*------------------------------ USB Configuration -------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)\r\n  {\r\n\r\n    switch(PeriphClkInit->UsbClockSelection)\r\n    {\r\n    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/\r\n      /* Enable USB Clock output generated form System USB . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* USB clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/\r\n\r\n      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);\r\n\r\n      /* USB clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_USBCLKSOURCE_HSI48:\r\n      /* HSI48 oscillator is used as source of USB clock */\r\n      /* USB clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of USB clock*/\r\n      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n\r\n  }\r\n\r\n  /*------------------------------------- SDMMC Configuration ------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));\r\n\r\n    switch(PeriphClkInit->SdmmcClockSelection)\r\n    {\r\n    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/\r\n      /* Enable SDMMC Clock output generated form System PLL . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* SDMMC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/\r\n\r\n      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);\r\n\r\n      /* SDMMC clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of SDMMC clock*/\r\n      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n  }\r\n\r\n#if defined(LTDC)\r\n  /*-------------------------------------- LTDC Configuration -----------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)\r\n  {\r\n    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)\r\n    {\r\n      status=HAL_ERROR;\r\n    }\r\n  }\r\n#endif /* LTDC */\r\n\r\n  /*------------------------------ RNG Configuration -------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)\r\n  {\r\n\r\n    switch(PeriphClkInit->RngClockSelection)\r\n    {\r\n    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/\r\n      /* Enable RNG Clock output generated form System RNG . */\r\n      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);\r\n\r\n      /* RNG clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_RNGCLKSOURCE_LSE: /* LSE is used as clock source for RNG*/\r\n\r\n      /* RNG clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    case RCC_RNGCLKSOURCE_LSI: /* LSI is used as clock source for RNG*/\r\n\r\n      /* RNG clock source configuration done later after clock selection check */\r\n      break;\r\n    case RCC_RNGCLKSOURCE_HSI48:\r\n      /* HSI48 oscillator is used as source of RNG clock */\r\n      /* RNG clock source configuration done later after clock selection check */\r\n      break;\r\n\r\n    default:\r\n      ret = HAL_ERROR;\r\n      break;\r\n    }\r\n\r\n    if(ret == HAL_OK)\r\n    {\r\n      /* Set the source of RNG clock*/\r\n      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);\r\n    }\r\n    else\r\n    {\r\n      /* set overall return value */\r\n      status = ret;\r\n    }\r\n\r\n  }\r\n\r\n  /*------------------------------ SWPMI1 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));\r\n\r\n    /* Configure the SWPMI1 interface clock source */\r\n    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);\r\n  }\r\n#if defined(HRTIM1)\r\n  /*------------------------------ HRTIM1 clock Configuration ----------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));\r\n\r\n    /* Configure the HRTIM1 clock source */\r\n    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);\r\n  }\r\n#endif  /*HRTIM1*/\r\n  /*------------------------------ DFSDM1 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));\r\n\r\n    /* Configure the DFSDM1 interface clock source */\r\n    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);\r\n  }\r\n\r\n#if defined(DFSDM2_BASE)\r\n  /*------------------------------ DFSDM2 Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM2) == RCC_PERIPHCLK_DFSDM2)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_DFSDM2CLKSOURCE(PeriphClkInit->Dfsdm2ClockSelection));\r\n\r\n    /* Configure the DFSDM2 interface clock source */\r\n    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);\r\n  }\r\n#endif  /* DFSDM2 */\r\n\r\n  /*------------------------------------ TIM configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));\r\n\r\n    /* Configure Timer Prescaler */\r\n    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);\r\n  }\r\n\r\n  /*------------------------------------ CKPER configuration --------------------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));\r\n\r\n    /* Configure the CKPER clock source */\r\n    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);\r\n  }\r\n\r\n  /*------------------------------ CEC Configuration ------------------------*/\r\n  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));\r\n\r\n    /* Configure the CEC interface clock source */\r\n    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    return HAL_OK;\r\n  }\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Get the RCC_ClkInitStruct according to the internal RCC configuration registers.\r\n  * @param  PeriphClkInit: pointer to an RCC_PeriphCLKInitTypeDef structure that\r\n  *         returns the configuration information for the Extended Peripherals clocks :\r\n  *         (SDMMC, CKPER, FMC, QSPI*, OSPI*, DSI*, SPI45, SPDIF, DFSDM1, DFSDM2*, FDCAN, SWPMI, SAI23*, SAI1, SPI123,\r\n  *         USART234578, USART16, RNG, HRTIM1*, I2C123 (I2C1235*), USB, CEC, LPTIM1, LPUART1, I2C4, LPTIM2, LPTIM345, ADC.\r\n  *         SAI4A*, SAI4B*, SPI6, RTC, TIM).\r\n  * @retval None\r\n  *\r\n  *   (*) : Available on some STM32H7 lines only.\r\n  */\r\nvoid HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)\r\n{\r\n  /* Set all possible values for the extended clock type parameter------------*/\r\n  PeriphClkInit->PeriphClockSelection =\r\n                 RCC_PERIPHCLK_USART16 | RCC_PERIPHCLK_USART234578 | RCC_PERIPHCLK_LPUART1 |\r\n                 RCC_PERIPHCLK_I2C4    | RCC_PERIPHCLK_LPTIM1      | RCC_PERIPHCLK_LPTIM2  | RCC_PERIPHCLK_LPTIM345 |\r\n                 RCC_PERIPHCLK_SAI1    | RCC_PERIPHCLK_SPI123      | RCC_PERIPHCLK_SPI45   | RCC_PERIPHCLK_SPI6     |\r\n\t         RCC_PERIPHCLK_FDCAN   | RCC_PERIPHCLK_SDMMC       | RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_USB      |\r\n\t         RCC_PERIPHCLK_ADC     | RCC_PERIPHCLK_SWPMI1      | RCC_PERIPHCLK_DFSDM1  | RCC_PERIPHCLK_RTC      |\r\n\t         RCC_PERIPHCLK_CEC     | RCC_PERIPHCLK_FMC         | RCC_PERIPHCLK_SPDIFRX | RCC_PERIPHCLK_TIM      |\r\n\t         RCC_PERIPHCLK_CKPER;\r\n\r\n#if defined(I2C5)\r\nPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C1235;\r\n#else\r\nPeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;\r\n#endif /*I2C5*/\r\n#if defined(RCC_CDCCIP1R_SAI2ASEL)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2A;\r\n#endif /* RCC_CDCCIP1R_SAI2ASEL */\r\n#if defined(RCC_CDCCIP1R_SAI2BSEL)\t\t \r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;\r\n#endif /* RCC_CDCCIP1R_SAI2BSEL */\r\n#if defined(SAI3)\t \r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;\r\n#endif /* SAI3 */\r\n#if defined(SAI4)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;\r\n#endif /* SAI4 */\r\n#if defined(DFSDM2_BASE)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;\r\n#endif /* DFSDM2 */\r\n#if defined(QUADSPI)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;\r\n#endif /* QUADSPI */\r\n#if defined(OCTOSPI1) || defined(OCTOSPI2)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_OSPI;\r\n#endif /* OCTOSPI1 || OCTOSPI2 */\r\n#if defined(HRTIM1)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;\r\n#endif /* HRTIM1 */\r\n#if defined(LTDC)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;\r\n#endif /* LTDC */\r\n#if defined(DSI)\r\n  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;\r\n#endif /* DSI */\r\n\r\n  /* Get the PLL3 Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);\r\n  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;\r\n  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;\r\n  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;\r\n  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;\r\n  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);\r\n  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);\r\n\r\n  /* Get the PLL2 Clock configuration -----------------------------------------------*/\r\n  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);\r\n  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;\r\n  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;\r\n  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;\r\n  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;\r\n  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);\r\n  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);\r\n\r\n  /* Get the USART1 configuration --------------------------------------------*/\r\n  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();\r\n  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/\r\n  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();\r\n  /* Get the LPUART1 clock source --------------------------------------------*/\r\n  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();\r\n#if defined(I2C5)\r\n  /* Get the I2C1/2/3/5 clock source -----------------------------------------*/\r\n  PeriphClkInit->I2c1235ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();\r\n#else\r\n  /* Get the I2C1/2/3 clock source -------------------------------------------*/\r\n  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();\r\n#endif /*I2C5*/\r\n  /* Get the LPTIM1 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();\r\n  /* Get the LPTIM2 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();\r\n  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/\r\n  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();\r\n  /* Get the SAI1 clock source -----------------------------------------------*/\r\n  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();\r\n#if defined(SAI3)\r\n  /* Get the SAI2/3 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();\r\n#endif  /*SAI3*/\r\n#if defined(RCC_CDCCIP1R_SAI2ASEL_0)\r\n  /* Get the SAI2A clock source ---------------------------------------------*/\r\n  PeriphClkInit->Sai2AClockSelection        = __HAL_RCC_GET_SAI2A_SOURCE();\r\n#endif  /*SAI2A*/\r\n#if defined(RCC_CDCCIP1R_SAI2BSEL_0)\r\n  /* Get the SAI2B clock source ---------------------------------------------*/\r\n  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();\r\n#endif  /*SAI2B*/\r\n#if defined(SAI4)\r\n  /* Get the SAI4A clock source ----------------------------------------------*/\r\n  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();\r\n  /* Get the SAI4B clock source ----------------------------------------------*/\r\n  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();\r\n#endif  /*SAI4*/\r\n  /* Get the RTC clock source ------------------------------------------------*/\r\n  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();\r\n  /* Get the USB clock source ------------------------------------------------*/\r\n  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();\r\n  /* Get the SDMMC clock source ----------------------------------------------*/\r\n  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();\r\n  /* Get the RNG clock source ------------------------------------------------*/\r\n  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();\r\n#if defined(HRTIM1)\r\n  /* Get the HRTIM1 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();\r\n#endif /* HRTIM1 */\r\n  /* Get the ADC clock source ------------------------------------------------*/\r\n  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();\r\n  /* Get the SWPMI1 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();\r\n  /* Get the DFSDM1 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();\r\n#if defined(DFSDM2_BASE)\r\n  /* Get the DFSDM2 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();\r\n#endif /* DFSDM2 */\r\n  /* Get the SPDIFRX clock source --------------------------------------------*/\r\n  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();\r\n  /* Get the SPI1/2/3 clock source -------------------------------------------*/\r\n  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();\r\n  /* Get the SPI4/5 clock source ---------------------------------------------*/\r\n  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();\r\n  /* Get the SPI6 clock source -----------------------------------------------*/\r\n  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();\r\n  /* Get the FDCAN clock source ----------------------------------------------*/\r\n  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();\r\n  /* Get the CEC clock source ------------------------------------------------*/\r\n  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();\r\n  /* Get the FMC clock source ------------------------------------------------*/\r\n  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();\r\n#if defined(QUADSPI)\r\n  /* Get the QSPI clock source -----------------------------------------------*/\r\n  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();\r\n#endif /* QUADSPI */\r\n#if defined(OCTOSPI1) || defined(OCTOSPI2)\r\n  /* Get the OSPI clock source -----------------------------------------------*/\r\n  PeriphClkInit->OspiClockSelection         = __HAL_RCC_GET_OSPI_SOURCE();\r\n#endif /* OCTOSPI1 || OCTOSPI2 */\r\n\r\n#if defined(DSI)\r\n  /* Get the DSI clock source ------------------------------------------------*/\r\n  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();\r\n#endif /*DSI*/\r\n\r\n  /* Get the CKPER clock source ----------------------------------------------*/\r\n  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n  /* Get the TIM Prescaler configuration -------------------------------------*/\r\n  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;\r\n  }\r\n  else\r\n  {\r\n    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)\r\n  * @note   Return 0 if peripheral clock identifier not managed by this API\r\n  * @param  PeriphClk: Peripheral clock identifier\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_PERIPHCLK_SAI1  : SAI1 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_SAI23 : SAI2/3  peripheral clock (*)\r\n  *            @arg RCC_PERIPHCLK_SAI2A : SAI2A peripheral clock (*)\r\n  *            @arg RCC_PERIPHCLK_SAI2B : SAI2B peripheral clock (*)\r\n  *            @arg RCC_PERIPHCLK_SAI4A : SAI4A peripheral clock (*)\r\n  *            @arg RCC_PERIPHCLK_SAI4B : SAI4B peripheral clock (*)\r\n  *            @arg RCC_PERIPHCLK_SPI123: SPI1/2/3 peripheral clock\r\n  *            @arg RCC_PERIPHCLK_ADC   : ADC peripheral clock\r\n  *            @arg RCC_PERIPHCLK_SDMMC : SDMMC peripheral clock\r\n  *            @arg RCC_PERIPHCLK_SPI6  : SPI6 peripheral clock\r\n  * @retval Frequency in KHz\r\n  *\r\n  *  (*) : Available on some STM32H7 lines only.\r\n  */\r\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\r\n{\r\n  PLL1_ClocksTypeDef pll1_clocks;\r\n  PLL2_ClocksTypeDef pll2_clocks;\r\n  PLL3_ClocksTypeDef pll3_clocks;\r\n\r\n  /* This variable is used to store the clock frequency (value in Hz) */\r\n  uint32_t frequency;\r\n  /* This variable is used to store the SAI and CKP clock source */\r\n  uint32_t saiclocksource;\r\n  uint32_t ckpclocksource;\r\n  uint32_t srcclk;\r\n\r\n  if (PeriphClk == RCC_PERIPHCLK_SAI1)\r\n    {\r\n\r\n      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();\r\n\r\n      switch (saiclocksource)\r\n      {\r\n      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n           HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n           frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n#if defined(SAI3)\r\n  else if (PeriphClk == RCC_PERIPHCLK_SAI23)\r\n    {\r\n\r\n      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();\r\n\r\n      switch (saiclocksource)\r\n      {\r\n      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n#endif /* SAI3 */\r\n\r\n#if  defined(RCC_CDCCIP1R_SAI2ASEL)\r\n\r\n    else if (PeriphClk == RCC_PERIPHCLK_SAI2A)\r\n    {\r\n      saiclocksource= __HAL_RCC_GET_SAI2A_SOURCE();\r\n\r\n      switch (saiclocksource)\r\n      {\r\n      case RCC_SAI2ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI2A */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SAI2ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI2A */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI2ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI2A  */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI2ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI2A  */\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      case (RCC_SAI2ACLKSOURCE_PIN): /* External clock is the clock source for SAI2A */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n\r\n    }\r\n#endif\r\n\r\n#if  defined(RCC_CDCCIP1R_SAI2BSEL_0)\r\n  else if (PeriphClk == RCC_PERIPHCLK_SAI2B)\r\n    {\r\n\r\n      saiclocksource= __HAL_RCC_GET_SAI2B_SOURCE();\r\n\r\n      switch (saiclocksource)\r\n      {\r\n      case RCC_SAI2BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI2B */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SAI2BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI2B */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI2BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI2B */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI2BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI2B*/\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n          break;\r\n        }\r\n\r\n      case (RCC_SAI2BCLKSOURCE_PIN): /* External clock is the clock source for SAI2B */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n#endif\r\n\r\n#if defined(SAI4)\r\n  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)\r\n    {\r\n\r\n      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();\r\n\r\n      switch (saiclocksource)\r\n      {\r\n      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */\r\n        {\r\n          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)\r\n    {\r\n\r\n      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();\r\n\r\n      switch (saiclocksource)\r\n      {\r\n      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n          }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n#endif /*SAI4*/\r\n  else if (PeriphClk == RCC_PERIPHCLK_SPI123)\r\n    {\r\n      /* Get SPI1/2/3 clock source */\r\n      srcclk= __HAL_RCC_GET_SPI123_SOURCE();\r\n\r\n      switch (srcclk)\r\n      {\r\n      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  else if (PeriphClk == RCC_PERIPHCLK_ADC)\r\n    {\r\n      /* Get ADC clock source */\r\n      srcclk= __HAL_RCC_GET_ADC_SOURCE();\r\n\r\n      switch (srcclk)\r\n      {\r\n      case RCC_ADCCLKSOURCE_PLL2:\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_P_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_ADCCLKSOURCE_PLL3:\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_R_Frequency;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      case RCC_ADCCLKSOURCE_CLKP:\r\n        {\r\n\r\n          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();\r\n\r\n         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))\r\n          {\r\n            /* In Case the CKPER Source is HSI */\r\n            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))\r\n          {\r\n            /* In Case the CKPER Source is CSI */\r\n            frequency = CSI_VALUE;\r\n          }\r\n\r\n          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))\r\n          {\r\n            /* In Case the CKPER Source is HSE */\r\n            frequency = HSE_VALUE;\r\n          }\r\n\r\n          else\r\n          {\r\n            /* In Case the CKPER is disabled*/\r\n            frequency = 0;\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)\r\n    {\r\n      /* Get SDMMC clock source */\r\n      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();\r\n\r\n      switch (srcclk)\r\n      {\r\n      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */\r\n        {\r\n          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_R_Frequency;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  else if (PeriphClk == RCC_PERIPHCLK_SPI6)\r\n    {\r\n      /* Get SPI6 clock source */\r\n      srcclk= __HAL_RCC_GET_SPI6_SOURCE();\r\n\r\n      switch (srcclk)\r\n      {\r\n      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */\r\n        {\r\n          frequency = HAL_RCCEx_GetD3PCLK1Freq();\r\n          break;\r\n        }\r\n      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n          frequency = pll3_clocks.PLL3_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))\r\n         {\r\n          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))\r\n         {\r\n          frequency = CSI_VALUE;\r\n         }\r\n         else\r\n         {\r\n           frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))\r\n         {\r\n          frequency = HSE_VALUE;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n#if defined(RCC_SPI6CLKSOURCE_PIN)\r\n      case RCC_SPI6CLKSOURCE_PIN: /* External clock is the clock source for SPI6 */\r\n        {\r\n          frequency = EXTERNAL_CLOCK_VALUE;\r\n          break;\r\n        }\r\n#endif /* RCC_SPI6CLKSOURCE_PIN */\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)\r\n    {\r\n      /* Get FDCAN clock source */\r\n      srcclk= __HAL_RCC_GET_FDCAN_SOURCE();\r\n\r\n      switch (srcclk)\r\n      {\r\n      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))\r\n         {\r\n          frequency = HSE_VALUE;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);\r\n          frequency = pll1_clocks.PLL1_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */\r\n        {\r\n         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))\r\n         {\r\n          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n          frequency = pll2_clocks.PLL2_Q_Frequency;\r\n         }\r\n         else\r\n         {\r\n          frequency = 0;\r\n         }\r\n          break;\r\n        }\r\n      default :\r\n        {\r\n          frequency = 0;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  else\r\n    {\r\n      frequency = 0;\r\n    }\r\n\r\n  return frequency;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Returns the D1PCLK1 frequency\r\n  * @note   Each time D1PCLK1 changes, this function must be called to update the\r\n  *         right D1PCLK1 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval D1PCLK1 frequency\r\n  */\r\nuint32_t HAL_RCCEx_GetD1PCLK1Freq(void)\r\n{\r\n#if defined(RCC_D1CFGR_D1PPRE)\r\n  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE)>> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));\r\n#else\r\n/* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE)>> RCC_CDCFGR1_CDPPRE_Pos] & 0x1FU));\r\n#endif\r\n}\r\n\r\n/**\r\n  * @brief  Returns the D3PCLK1 frequency\r\n  * @note   Each time D3PCLK1 changes, this function must be called to update the\r\n  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @retval D3PCLK1 frequency\r\n  */\r\nuint32_t HAL_RCCEx_GetD3PCLK1Freq(void)\r\n{\r\n#if defined(RCC_D3CFGR_D3PPRE)\r\n  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));\r\n#else\r\n  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/\r\n  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));\r\n#endif\r\n}\r\n/**\r\n* @brief  Returns the PLL2 clock frequencies :PLL2_P_Frequency,PLL2_R_Frequency and PLL2_Q_Frequency\r\n  * @note   The PLL2 clock frequencies computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     The function returns values based on HSE_VALUE, HSI_VALUE or CSI Value multiplied/divided by the PLL factors.\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud-rate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time PLL2CLK changes, this function must be called to update the\r\n  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @param  PLL2_Clocks structure.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)\r\n{\r\n  uint32_t  pllsource, pll2m,  pll2fracen, hsivalue;\r\n  float_t fracn2, pll2vco;\r\n\r\n  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N\r\n     PLL2xCLK = PLL2_VCO / PLL2x\r\n  */\r\n  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\r\n  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);\r\n  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;\r\n  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));\r\n\r\n  if (pll2m != 0U)\r\n  {\r\n    switch (pllsource)\r\n    {\r\n\r\n    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n\r\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n      {\r\n        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );\r\n      }\r\n      else\r\n      {\r\n        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );\r\n      }\r\n      break;\r\n\r\n    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */\r\n      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n\r\n    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n\r\n    default:\r\n      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n    }\r\n    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;\r\n    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;\r\n    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;\r\n  }\r\n  else\r\n  {\r\n    PLL2_Clocks->PLL2_P_Frequency = 0U;\r\n    PLL2_Clocks->PLL2_Q_Frequency = 0U;\r\n    PLL2_Clocks->PLL2_R_Frequency = 0U;\r\n  }\r\n}\r\n\r\n/**\r\n* @brief  Returns the PLL3 clock frequencies :PLL3_P_Frequency,PLL3_R_Frequency and PLL3_Q_Frequency\r\n  * @note   The PLL3 clock frequencies computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     The function returns values based on HSE_VALUE, HSI_VALUE or CSI Value multiplied/divided by the PLL factors.\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud-rate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time PLL3CLK changes, this function must be called to update the\r\n  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @param  PLL3_Clocks structure.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)\r\n{\r\n  uint32_t pllsource, pll3m, pll3fracen, hsivalue;\r\n  float_t fracn3, pll3vco;\r\n\r\n  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N\r\n     PLL3xCLK = PLL3_VCO / PLLxR\r\n  */\r\n  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\r\n  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;\r\n  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;\r\n  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));\r\n\r\n  if (pll3m != 0U)\r\n  {\r\n    switch (pllsource)\r\n    {\r\n    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n\r\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n      {\r\n        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );\r\n      }\r\n      else\r\n      {\r\n        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );\r\n      }\r\n      break;\r\n    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */\r\n      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n\r\n    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n\r\n    default:\r\n      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n    }\r\n    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;\r\n    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;\r\n    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;\r\n  }\r\n  else\r\n  {\r\n    PLL3_Clocks->PLL3_P_Frequency = 0U;\r\n    PLL3_Clocks->PLL3_Q_Frequency = 0U;\r\n    PLL3_Clocks->PLL3_R_Frequency = 0U;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @brief  Returns the PLL1 clock frequencies :PLL1_P_Frequency,PLL1_R_Frequency and PLL1_Q_Frequency\r\n  * @note   The PLL1 clock frequencies computed by this function is not the real\r\n  *         frequency in the chip. It is calculated based on the predefined\r\n  *         constant and the selected clock source:\r\n  * @note     The function returns values based on HSE_VALUE, HSI_VALUE or CSI Value multiplied/divided by the PLL factors.\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud-rate for the communication peripherals or configure other parameters.\r\n  *\r\n  * @note   Each time PLL1CLK changes, this function must be called to update the\r\n  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @param  PLL1_Clocks structure.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef* PLL1_Clocks)\r\n{\r\n  uint32_t pllsource, pll1m, pll1fracen, hsivalue;\r\n  float_t fracn1, pll1vco;\r\n\r\n  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\r\n  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);\r\n  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;\r\n  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));\r\n\r\n  if (pll1m != 0U)\r\n  {\r\n    switch (pllsource)\r\n    {\r\n\r\n    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */\r\n\r\n      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n      {\r\n        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));\r\n        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n      }\r\n      else\r\n      {\r\n        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n      }\r\n      break;\r\n    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */\r\n      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n\r\n    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */\r\n      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n\r\n    default:\r\n      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n      break;\r\n    }\r\n\r\n    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;\r\n    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;\r\n    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;\r\n  }\r\n  else\r\n  {\r\n    PLL1_Clocks->PLL1_P_Frequency = 0U;\r\n    PLL1_Clocks->PLL1_Q_Frequency = 0U;\r\n    PLL1_Clocks->PLL1_R_Frequency = 0U;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n  * @brief  Returns the main System frequency\r\n  * @note   Each time System clock changes, this function must be called to update the\r\n  *         right core clock value. Otherwise, any configuration based on this function will be incorrect.\r\n  * @note   The SystemCoreClock CMSIS variable is used to store System current Core Clock Frequency\r\n  *         and updated within this function\r\n  * @retval HCLK frequency\r\n  */\r\nuint32_t HAL_RCCEx_GetD1SysClockFreq(void)\r\n{\r\nuint32_t common_system_clock;\r\n\r\n#if defined(RCC_D1CFGR_D1CPRE)\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);\r\n#else\r\n  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);\r\n#endif\r\n\r\n  /* Update the SystemD2Clock global variable */\r\n#if defined(RCC_D1CFGR_HPRE)\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\r\n#else\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\r\n#endif\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  SystemCoreClock = SystemD2Clock;\r\n#else\r\n  SystemCoreClock = common_system_clock;\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n\r\n  return common_system_clock;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group2 Extended System Control functions\r\n *  @brief  Extended Peripheral Control functions\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Enables the LSE Clock Security System.\r\n  * @note   Prior to enable the LSE Clock Security System, LSE oscillator is to be enabled\r\n  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC\r\n  *         clock with HAL_RCCEx_PeriphCLKConfig().\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_EnableLSECSS(void)\r\n{\r\n  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;\r\n}\r\n\r\n/**\r\n  * @brief  Disables the LSE Clock Security System.\r\n  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_DisableLSECSS(void)\r\n{\r\n  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;\r\n  /* Disable LSE CSS IT if any */\r\n  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.\r\n  * @note   LSE Clock Security System Interrupt is mapped on EXTI line 18\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_EnableLSECSS_IT(void)\r\n{\r\n  /* Enable LSE CSS */\r\n  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;\r\n\r\n  /* Enable LSE CSS IT */\r\n  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);\r\n\r\n  /* Enable IT on EXTI Line 18 */\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  __HAL_RCC_C2_LSECSS_EXTI_ENABLE_IT();\r\n#else\r\n  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();\r\n}\r\n\r\n/**\r\n  * @brief  Configure the oscillator clock source for wakeup from Stop and CSS backup clock\r\n  * @param  WakeUpClk: Wakeup clock\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_STOP_WAKEUPCLOCK_CSI: CSI oscillator selection\r\n  *            @arg RCC_STOP_WAKEUPCLOCK_HSI: HSI oscillator selection\r\n  * @note   This function shall not be called after the Clock Security System on HSE has been\r\n  *         enabled.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)\r\n{\r\n  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));\r\n\r\n  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);\r\n}\r\n\r\n/**\r\n  * @brief  Configure the oscillator Kernel clock source for wakeup from Stop\r\n  * @param  WakeUpClk: Kernel Wakeup clock\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection\r\n  *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)\r\n{\r\n  assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));\r\n\r\n  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);\r\n}\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Enable COREx boot independently of CMx_B option byte value\r\n  * @param  RCC_BootCx: Boot Core to be enabled\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_BOOT_C1: CM7 core selection\r\n  *            @arg RCC_BOOT_C2: CM4 core selection\r\n  * @note   This bit can be set by software but is cleared by hardware after a system reset or STANDBY\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_EnableBootCore(uint32_t RCC_BootCx)\r\n{\r\n  assert_param(IS_RCC_BOOT_CORE(RCC_BootCx));\r\n  SET_BIT(RCC->GCR, RCC_BootCx) ;\r\n}\r\n\r\n#endif /*DUAL_CORE*/\r\n\r\n#if defined(DUAL_CORE)\r\n/**\r\n  * @brief  Configure WWDGx to generate a system reset not only CPUx reset(default) when a time-out occurs\r\n  * @param  RCC_WWDGx: WWDGx to be configured\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_WWDG1: WWDG1 generates system reset\r\n  *            @arg RCC_WWDG2: WWDG2 generates system reset\r\n  * @note   This bit can be set by software but is cleared by hardware during a system reset\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)\r\n{\r\n  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));\r\n  SET_BIT(RCC->GCR, RCC_WWDGx) ;\r\n}\r\n\r\n#else\r\n#if defined(RCC_GCR_WW1RSC)\r\n/**\r\n  * @brief  Configure WWDG1 to generate a system reset not only CPU reset(default) when a time-out occurs\r\n  * @param  RCC_WWDGx: WWDGx to be configured\r\n  *         This parameter can be one of the following values:\r\n  *            @arg RCC_WWDG1: WWDG1 generates system reset\r\n  * @note   This bit can be set by software but is cleared by hardware during a system reset\r\n  *\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)\r\n{\r\n  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));\r\n  SET_BIT(RCC->GCR, RCC_WWDGx) ;\r\n}\r\n#endif\r\n#endif /*DUAL_CORE*/\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCCEx_Exported_Functions_Group3 Extended Clock Recovery System Control functions\r\n *  @brief  Extended Clock Recovery System Control functions\r\n *\r\n@verbatim\r\n ===============================================================================\r\n                ##### Extended Clock Recovery System Control functions  #####\r\n ===============================================================================\r\n    [..]\r\n      For devices with Clock Recovery System feature (CRS), RCC Extension HAL driver can be used as follows:\r\n\r\n      (#) In System clock config, HSI48 needs to be enabled\r\n\r\n      (#) Enable CRS clock in IP MSP init which will use CRS functions\r\n\r\n      (#) Call CRS functions as follows:\r\n          (##) Prepare synchronization configuration necessary for HSI48 calibration\r\n              (+++) Default values can be set for frequency Error Measurement (reload and error limit)\r\n                        and also HSI48 oscillator smooth trimming.\r\n              (+++) Macro __HAL_RCC_CRS_RELOADVALUE_CALCULATE can be also used to calculate\r\n                        directly reload value with target and synchronization frequencies values\r\n          (##) Call function HAL_RCCEx_CRSConfig which\r\n              (+++) Resets CRS registers to their default values.\r\n              (+++) Configures CRS registers with synchronization configuration\r\n              (+++) Enables automatic calibration and frequency error counter feature\r\n           Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the\r\n           periodic USB SOF will not be generated by the host. No SYNC signal will therefore be\r\n           provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock\r\n           precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs\r\n           should be used as SYNC signal.\r\n\r\n          (##) A polling function is provided to wait for complete synchronization\r\n              (+++) Call function HAL_RCCEx_CRSWaitSynchronization()\r\n              (+++) According to CRS status, user can decide to adjust again the calibration or continue\r\n                        application if synchronization is OK\r\n\r\n      (#) User can retrieve information related to synchronization in calling function\r\n            HAL_RCCEx_CRSGetSynchronizationInfo()\r\n\r\n      (#) Regarding synchronization status and synchronization information, user can try a new calibration\r\n           in changing synchronization configuration and call again HAL_RCCEx_CRSConfig.\r\n           Note: When the SYNC event is detected during the down-counting phase (before reaching the zero value),\r\n           it means that the actual frequency is lower than the target (and so, that the TRIM value should be\r\n           incremented), while when it is detected during the up-counting phase it means that the actual frequency\r\n           is higher (and that the TRIM value should be decremented).\r\n\r\n      (#) In interrupt mode, user can resort to the available macros (__HAL_RCC_CRS_XXX_IT). Interrupts will go\r\n          through CRS Handler (CRS_IRQn/CRS_IRQHandler)\r\n              (++) Call function HAL_RCCEx_CRSConfig()\r\n              (++) Enable CRS_IRQn (thanks to NVIC functions)\r\n              (++) Enable CRS interrupt (__HAL_RCC_CRS_ENABLE_IT)\r\n              (++) Implement CRS status management in the following user callbacks called from\r\n                   HAL_RCCEx_CRS_IRQHandler():\r\n                   (+++) HAL_RCCEx_CRS_SyncOkCallback()\r\n                   (+++) HAL_RCCEx_CRS_SyncWarnCallback()\r\n                   (+++) HAL_RCCEx_CRS_ExpectedSyncCallback()\r\n                   (+++) HAL_RCCEx_CRS_ErrorCallback()\r\n\r\n      (#) To force a SYNC EVENT, user can use the function HAL_RCCEx_CRSSoftwareSynchronizationGenerate().\r\n          This function can be called before calling HAL_RCCEx_CRSConfig (for instance in Systick handler)\r\n\r\n@endverbatim\r\n * @{\r\n */\r\n\r\n/**\r\n  * @brief  Start automatic synchronization for polling mode\r\n  * @param  pInit Pointer on RCC_CRSInitTypeDef structure\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)\r\n{\r\n  uint32_t value;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_RCC_CRS_SYNC_DIV(pInit->Prescaler));\r\n  assert_param(IS_RCC_CRS_SYNC_SOURCE(pInit->Source));\r\n  assert_param(IS_RCC_CRS_SYNC_POLARITY(pInit->Polarity));\r\n  assert_param(IS_RCC_CRS_RELOADVALUE(pInit->ReloadValue));\r\n  assert_param(IS_RCC_CRS_ERRORLIMIT(pInit->ErrorLimitValue));\r\n  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));\r\n\r\n  /* CONFIGURATION */\r\n\r\n  /* Before configuration, reset CRS registers to their default values*/\r\n  __HAL_RCC_CRS_FORCE_RESET();\r\n  __HAL_RCC_CRS_RELEASE_RESET();\r\n\r\n  /* Set the SYNCDIV[2:0] bits according to Pre-scaler value */\r\n  /* Set the SYNCSRC[1:0] bits according to Source value */\r\n  /* Set the SYNCSPOL bit according to Polarity value */\r\n  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))\r\n  {\r\n    /* Use Rev.Y value of USB2 */\r\n    value = (pInit->Prescaler | RCC_CRS_SYNC_SOURCE_PIN | pInit->Polarity);\r\n  }\r\n  else\r\n  {\r\n    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);\r\n  }\r\n  /* Set the RELOAD[15:0] bits according to ReloadValue value */\r\n  value |= pInit->ReloadValue;\r\n  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */\r\n  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);\r\n  WRITE_REG(CRS->CFGR, value);\r\n\r\n  /* Adjust HSI48 oscillator smooth trimming */\r\n  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */\r\n  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));\r\n\r\n  /* START AUTOMATIC SYNCHRONIZATION*/\r\n\r\n  /* Enable Automatic trimming & Frequency error counter */\r\n  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);\r\n}\r\n\r\n/**\r\n  * @brief  Generate the software synchronization event\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)\r\n{\r\n  SET_BIT(CRS->CR, CRS_CR_SWSYNC);\r\n}\r\n\r\n/**\r\n  * @brief  Return synchronization info\r\n  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)\r\n{\r\n  /* Check the parameter */\r\n  assert_param(pSynchroInfo != (void *)NULL);\r\n\r\n  /* Get the reload value */\r\n  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));\r\n\r\n  /* Get HSI48 oscillator smooth trimming */\r\n  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);\r\n\r\n  /* Get Frequency error capture */\r\n  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);\r\n\r\n  /* Get Frequency error direction */\r\n  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));\r\n}\r\n\r\n/**\r\n* @brief Wait for CRS Synchronization status.\r\n* @param Timeout  Duration of the time-out\r\n* @note  Timeout is based on the maximum time to receive a SYNC event based on synchronization\r\n*        frequency.\r\n* @note    If Time-out set to HAL_MAX_DELAY, HAL_TIMEOUT will be never returned.\r\n* @retval Combination of Synchronization status\r\n*          This parameter can be a combination of the following values:\r\n*            @arg @ref RCC_CRS_TIMEOUT\r\n*            @arg @ref RCC_CRS_SYNCOK\r\n*            @arg @ref RCC_CRS_SYNCWARN\r\n*            @arg @ref RCC_CRS_SYNCERR\r\n*            @arg @ref RCC_CRS_SYNCMISS\r\n*            @arg @ref RCC_CRS_TRIMOVF\r\n*/\r\nuint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)\r\n{\r\n  uint32_t crsstatus = RCC_CRS_NONE;\r\n  uint32_t tickstart;\r\n\r\n  /* Get time-out */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait for CRS flag or time-out detection */\r\n  do\r\n  {\r\n    if(Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        crsstatus = RCC_CRS_TIMEOUT;\r\n      }\r\n    }\r\n    /* Check CRS SYNCOK flag  */\r\n    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))\r\n    {\r\n      /* CRS SYNC event OK */\r\n      crsstatus |= RCC_CRS_SYNCOK;\r\n\r\n      /* Clear CRS SYNC event OK bit */\r\n      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);\r\n    }\r\n\r\n    /* Check CRS SYNCWARN flag  */\r\n    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))\r\n    {\r\n      /* CRS SYNC warning */\r\n      crsstatus |= RCC_CRS_SYNCWARN;\r\n\r\n      /* Clear CRS SYNCWARN bit */\r\n      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);\r\n    }\r\n\r\n    /* Check CRS TRIM overflow flag  */\r\n    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))\r\n    {\r\n      /* CRS SYNC Error */\r\n      crsstatus |= RCC_CRS_TRIMOVF;\r\n\r\n      /* Clear CRS Error bit */\r\n      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);\r\n    }\r\n\r\n    /* Check CRS Error flag  */\r\n    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))\r\n    {\r\n      /* CRS SYNC Error */\r\n      crsstatus |= RCC_CRS_SYNCERR;\r\n\r\n      /* Clear CRS Error bit */\r\n      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);\r\n    }\r\n\r\n    /* Check CRS SYNC Missed flag  */\r\n    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))\r\n    {\r\n      /* CRS SYNC Missed */\r\n      crsstatus |= RCC_CRS_SYNCMISS;\r\n\r\n      /* Clear CRS SYNC Missed bit */\r\n      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);\r\n    }\r\n\r\n    /* Check CRS Expected SYNC flag  */\r\n    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))\r\n    {\r\n      /* frequency error counter reached a zero value */\r\n      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);\r\n    }\r\n  } while(RCC_CRS_NONE == crsstatus);\r\n\r\n  return crsstatus;\r\n}\r\n\r\n/**\r\n  * @brief Handle the Clock Recovery System interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_CRS_IRQHandler(void)\r\n{\r\n  uint32_t crserror = RCC_CRS_NONE;\r\n  /* Get current IT flags and IT sources values */\r\n  uint32_t itflags = READ_REG(CRS->ISR);\r\n  uint32_t itsources = READ_REG(CRS->CR);\r\n\r\n  /* Check CRS SYNCOK flag  */\r\n  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))\r\n  {\r\n    /* Clear CRS SYNC event OK flag */\r\n    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);\r\n\r\n    /* user callback */\r\n    HAL_RCCEx_CRS_SyncOkCallback();\r\n  }\r\n  /* Check CRS SYNCWARN flag  */\r\n  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))\r\n  {\r\n    /* Clear CRS SYNCWARN flag */\r\n    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);\r\n\r\n    /* user callback */\r\n    HAL_RCCEx_CRS_SyncWarnCallback();\r\n  }\r\n  /* Check CRS Expected SYNC flag  */\r\n  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))\r\n  {\r\n    /* frequency error counter reached a zero value */\r\n    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);\r\n\r\n    /* user callback */\r\n    HAL_RCCEx_CRS_ExpectedSyncCallback();\r\n  }\r\n  /* Check CRS Error flags  */\r\n  else\r\n  {\r\n    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))\r\n    {\r\n      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)\r\n      {\r\n        crserror |= RCC_CRS_SYNCERR;\r\n      }\r\n      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)\r\n      {\r\n        crserror |= RCC_CRS_SYNCMISS;\r\n      }\r\n      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)\r\n      {\r\n        crserror |= RCC_CRS_TRIMOVF;\r\n      }\r\n\r\n      /* Clear CRS Error flags */\r\n      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);\r\n\r\n      /* user error callback */\r\n      HAL_RCCEx_CRS_ErrorCallback(crserror);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.\r\n  * @retval none\r\n  */\r\n__weak void HAL_RCCEx_CRS_SyncOkCallback(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.\r\n  * @retval none\r\n  */\r\n__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.\r\n  * @retval none\r\n  */\r\n__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  RCCEx Clock Recovery System Error interrupt callback.\r\n  * @param  Error Combination of Error status.\r\n  *         This parameter can be a combination of the following values:\r\n  *           @arg @ref RCC_CRS_SYNCERR\r\n  *           @arg @ref RCC_CRS_SYNCMISS\r\n  *           @arg @ref RCC_CRS_TRIMOVF\r\n  * @retval none\r\n  */\r\n__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(Error);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup RCCEx_Private_functions RCCEx Private Functions\r\n * @{\r\n */\r\n/**\r\n  * @brief  Configure the PLL2 VCI,VCO ranges, multiplication and division factors and enable it\r\n  * @param  pll2: Pointer to an RCC_PLL2InitTypeDef structure that\r\n  *         contains the configuration parameters  as well as VCI, VCO clock ranges.\r\n  * @param  Divider  divider parameter to be updated\r\n  * @note   PLL2 is temporary disabled to apply new parameters\r\n  *\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)\r\n{\r\n\r\n  uint32_t tickstart;\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));\r\n  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));\r\n  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));\r\n  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));\r\n  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));\r\n  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));\r\n  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));\r\n  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));\r\n\r\n  /* Check that PLL2 OSC clock source is already set */\r\n  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n\r\n  else\r\n  {\r\n    /* Disable  PLL2. */\r\n    __HAL_RCC_PLL2_DISABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLL is disabled */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)\r\n    {\r\n      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Configure PLL2 multiplication and division factors. */\r\n    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,\r\n                          pll2->PLL2N,\r\n                          pll2->PLL2P,\r\n                          pll2->PLL2Q,\r\n                          pll2->PLL2R);\r\n\r\n    /* Select PLL2 input reference frequency range: VCI */\r\n    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;\r\n\r\n    /* Select PLL2 output frequency range : VCO */\r\n    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;\r\n\r\n    /* Disable PLL2FRACN . */\r\n    __HAL_RCC_PLL2FRACN_DISABLE();\r\n\r\n    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */\r\n    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);\r\n\r\n    /* Enable PLL2FRACN . */\r\n    __HAL_RCC_PLL2FRACN_ENABLE();\r\n\r\n    /* Enable the PLL2 clock output */\r\n    if(Divider == DIVIDER_P_UPDATE)\r\n    {\r\n      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);\r\n    }\r\n    else if(Divider == DIVIDER_Q_UPDATE)\r\n    {\r\n      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);\r\n    }\r\n    else\r\n    {\r\n      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);\r\n    }\r\n\r\n    /* Enable  PLL2. */\r\n    __HAL_RCC_PLL2_ENABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLL2 is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)\r\n    {\r\n      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n\r\n  return status;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Configure the PLL3 VCI,VCO ranges, multiplication and division factors and enable it\r\n  * @param  pll3: Pointer to an RCC_PLL3InitTypeDef structure that\r\n  *         contains the configuration parameters  as well as VCI, VCO clock ranges.\r\n  * @param  Divider  divider parameter to be updated\r\n  * @note   PLL3 is temporary disabled to apply new parameters\r\n  *\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)\r\n{\r\n  uint32_t tickstart;\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));\r\n  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));\r\n  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));\r\n  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));\r\n  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));\r\n  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));\r\n  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));\r\n  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));\r\n\r\n  /* Check that PLL3 OSC clock source is already set */\r\n  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n\r\n  else\r\n  {\r\n    /* Disable  PLL3. */\r\n    __HAL_RCC_PLL3_DISABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n    /* Wait till PLL3 is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)\r\n    {\r\n      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n    /* Configure the PLL3  multiplication and division factors. */\r\n    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,\r\n                          pll3->PLL3N,\r\n                          pll3->PLL3P,\r\n                          pll3->PLL3Q,\r\n                          pll3->PLL3R);\r\n\r\n    /* Select PLL3 input reference frequency range: VCI */\r\n    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;\r\n\r\n    /* Select PLL3 output frequency range : VCO */\r\n    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;\r\n\r\n    /* Disable PLL3FRACN . */\r\n    __HAL_RCC_PLL3FRACN_DISABLE();\r\n\r\n    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */\r\n    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);\r\n\r\n    /* Enable PLL3FRACN . */\r\n    __HAL_RCC_PLL3FRACN_ENABLE();\r\n\r\n    /* Enable the PLL3 clock output */\r\n    if(Divider == DIVIDER_P_UPDATE)\r\n    {\r\n      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);\r\n    }\r\n    else if(Divider == DIVIDER_Q_UPDATE)\r\n    {\r\n      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);\r\n    }\r\n    else\r\n    {\r\n      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);\r\n    }\r\n\r\n    /* Enable  PLL3. */\r\n    __HAL_RCC_PLL3_ENABLE();\r\n\r\n    /* Get Start Tick*/\r\n    tickstart = HAL_GetTick();\r\n\r\n    /* Wait till PLL3 is ready */\r\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)\r\n    {\r\n      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Handle the RCC LSE Clock Security System interrupt request.\r\n  * @retval None\r\n  */\r\nvoid HAL_RCCEx_LSECSS_IRQHandler(void)\r\n{\r\n  /* Check RCC LSE CSSF flag  */\r\n  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))\r\n  {\r\n\r\n    /* Clear RCC LSE CSS pending bit */\r\n    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);\r\n\r\n    /* RCC LSE Clock Security System interrupt user callback */\r\n    HAL_RCCEx_LSECSS_Callback();\r\n\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  RCCEx LSE Clock Security System interrupt callback.\r\n  * @retval none\r\n  */\r\n__weak void HAL_RCCEx_LSECSS_Callback(void)\r\n{\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file\r\n  */\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_RCC_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_spi.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_spi.c\r\n  * @author  MCD Application Team\r\n  * @brief   SPI HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Serial Peripheral Interface (SPI) peripheral:\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral Control functions\r\n  *           + Peripheral State functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                        ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n      The SPI HAL driver can be used as follows:\r\n\r\n      (#) Declare a SPI_HandleTypeDef handle structure, for example:\r\n          SPI_HandleTypeDef  hspi;\r\n\r\n      (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API:\r\n          (##) Enable the SPIx interface clock\r\n          (##) SPI pins configuration\r\n              (+++) Enable the clock for the SPI GPIOs\r\n              (+++) Configure these SPI pins as alternate function push-pull\r\n          (##) NVIC configuration if you need to use interrupt process or DMA process\r\n              (+++) Configure the SPIx interrupt priority\r\n              (+++) Enable the NVIC SPI IRQ handle\r\n          (##) DMA Configuration if you need to use DMA process\r\n              (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Stream/Channel\r\n              (+++) Enable the DMAx clock\r\n              (+++) Configure the DMA handle parameters\r\n              (+++) Configure the DMA Tx or Rx Stream/Channel\r\n              (+++) Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle\r\n              (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx\r\n                    or Rx Stream/Channel\r\n\r\n      (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS\r\n          management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.\r\n\r\n      (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:\r\n          (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)\r\n              by calling the customized HAL_SPI_MspInit() API.\r\n     [..]\r\n       Callback registration:\r\n\r\n      (#) The compilation flag USE_HAL_SPI_REGISTER_CALLBACKS when set to 1UL\r\n          allows the user to configure dynamically the driver callbacks.\r\n          Use Functions HAL_SPI_RegisterCallback() to register an interrupt callback.\r\n\r\n          Function HAL_SPI_RegisterCallback() allows to register following callbacks:\r\n            (+) TxCpltCallback        : SPI Tx Completed callback\r\n            (+) RxCpltCallback        : SPI Rx Completed callback\r\n            (+) TxRxCpltCallback      : SPI TxRx Completed callback\r\n            (+) TxHalfCpltCallback    : SPI Tx Half Completed callback\r\n            (+) RxHalfCpltCallback    : SPI Rx Half Completed callback\r\n            (+) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback\r\n            (+) ErrorCallback         : SPI Error callback\r\n            (+) AbortCpltCallback     : SPI Abort callback\r\n            (+) MspInitCallback       : SPI Msp Init callback\r\n            (+) MspDeInitCallback     : SPI Msp DeInit callback\r\n          This function takes as parameters the HAL peripheral handle, the Callback ID\r\n          and a pointer to the user callback function.\r\n\r\n\r\n      (#) Use function HAL_SPI_UnRegisterCallback to reset a callback to the default\r\n          weak function.\r\n          HAL_SPI_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n          and the Callback ID.\r\n          This function allows to reset following callbacks:\r\n            (+) TxCpltCallback        : SPI Tx Completed callback\r\n            (+) RxCpltCallback        : SPI Rx Completed callback\r\n            (+) TxRxCpltCallback      : SPI TxRx Completed callback\r\n            (+) TxHalfCpltCallback    : SPI Tx Half Completed callback\r\n            (+) RxHalfCpltCallback    : SPI Rx Half Completed callback\r\n            (+) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback\r\n            (+) ErrorCallback         : SPI Error callback\r\n            (+) AbortCpltCallback     : SPI Abort callback\r\n            (+) MspInitCallback       : SPI Msp Init callback\r\n            (+) MspDeInitCallback     : SPI Msp DeInit callback\r\n\r\n       By default, after the HAL_SPI_Init() and when the state is HAL_SPI_STATE_RESET\r\n       all callbacks are set to the corresponding weak functions:\r\n       examples HAL_SPI_MasterTxCpltCallback(), HAL_SPI_MasterRxCpltCallback().\r\n       Exception done for MspInit and MspDeInit functions that are\r\n       reset to the legacy weak functions in the HAL_SPI_Init()/ HAL_SPI_DeInit() only when\r\n       these callbacks are null (not registered beforehand).\r\n       If MspInit or MspDeInit are not null, the HAL_SPI_Init()/ HAL_SPI_DeInit()\r\n       keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.\r\n\r\n       Callbacks can be registered/unregistered in HAL_SPI_STATE_READY state only.\r\n       Exception done MspInit/MspDeInit functions that can be registered/unregistered\r\n       in HAL_SPI_STATE_READY or HAL_SPI_STATE_RESET state,\r\n       thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.\r\n       Then, the user first registers the MspInit/MspDeInit user callbacks\r\n       using HAL_SPI_RegisterCallback() before calling HAL_SPI_DeInit()\r\n       or HAL_SPI_Init() function.\r\n\r\n       When The compilation define USE_HAL_PPP_REGISTER_CALLBACKS is set to 0 or\r\n       not defined, the callback registering feature is not available\r\n       and weak (surcharged) callbacks are used.\r\n\r\n\r\n    [..]\r\n      Circular mode restriction:\r\n      (+) The DMA circular mode cannot be used when the SPI is configured in these modes:\r\n          (++) Master 2Lines RxOnly\r\n          (++) Master 1Line Rx\r\n      (+) The CRC feature is not managed when the DMA circular mode is enabled\r\n      (+) The functions HAL_SPI_DMAPause()/ HAL_SPI_DMAResume() are not supported. Return always\r\n          HAL_ERROR with ErrorCode set to HAL_SPI_ERROR_NOT_SUPPORTED.\r\n          Those functions are maintained for backward compatibility reasons.\r\n\r\n  @endverbatim\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup SPI SPI\r\n  * @brief SPI HAL module driver\r\n  * @{\r\n  */\r\n#ifdef HAL_SPI_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines -----------------------------------------------------------*/\r\n/** @defgroup SPI_Private_Constants SPI Private Constants\r\n  * @{\r\n  */\r\n#define SPI_DEFAULT_TIMEOUT 100UL\r\n#define MAX_FIFO_LENGTH     16UL\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup SPI_Private_Functions SPI Private Functions\r\n  * @{\r\n  */\r\nstatic void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMAError(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma);\r\nstatic void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus FlagStatus,\r\n                                                    uint32_t Timeout, uint32_t Tickstart);\r\nstatic void SPI_TxISR_8BIT(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_TxISR_16BIT(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_TxISR_32BIT(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_RxISR_8BIT(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_RxISR_16BIT(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_RxISR_32BIT(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_AbortTransfer(SPI_HandleTypeDef *hspi);\r\nstatic void SPI_CloseTransfer(SPI_HandleTypeDef *hspi);\r\nstatic uint32_t SPI_GetPacketSize(SPI_HandleTypeDef *hspi);\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup SPI_Exported_Functions SPI Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n              ##### Initialization and de-initialization functions #####\r\n ===============================================================================\r\n    [..]  This subsection provides a set of functions allowing to initialize and\r\n          de-initialize the SPIx peripheral:\r\n\r\n      (+) User must implement HAL_SPI_MspInit() function in which he configures\r\n          all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).\r\n\r\n      (+) Call the function HAL_SPI_Init() to configure the selected device with\r\n          the selected configuration:\r\n        (++) Mode\r\n        (++) Direction\r\n        (++) Data Size\r\n        (++) Clock Polarity and Phase\r\n        (++) NSS Management\r\n        (++) BaudRate Prescaler\r\n        (++) FirstBit\r\n        (++) TIMode\r\n        (++) CRC Calculation\r\n        (++) CRC Polynomial if CRC enabled\r\n        (++) CRC Length, used only with Data8 and Data16\r\n        (++) FIFO reception threshold\r\n        (++) FIFO transmission threshold\r\n\r\n      (+) Call the function HAL_SPI_DeInit() to restore the default configuration\r\n          of the selected SPIx peripheral.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initialize the SPI according to the specified parameters\r\n  *         in the SPI_InitTypeDef and initialize the associated handle.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)\r\n{\r\n  uint32_t crc_length;\r\n  uint32_t packet_length;\r\n\r\n  /* Check the SPI handle allocation */\r\n  if (hspi == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));\r\n  assert_param(IS_SPI_MODE(hspi->Init.Mode));\r\n  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));\r\n  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));\r\n  assert_param(IS_SPI_FIFOTHRESHOLD(hspi->Init.FifoThreshold));\r\n  assert_param(IS_SPI_NSS(hspi->Init.NSS));\r\n  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));\r\n  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));\r\n  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));\r\n  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));\r\n  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)\r\n  {\r\n    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));\r\n    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));\r\n  }\r\n#if (USE_SPI_CRC != 0UL)\r\n  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));\r\n  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)\r\n  {\r\n    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));\r\n    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));\r\n    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.TxCRCInitializationPattern));\r\n    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.RxCRCInitializationPattern));\r\n  }\r\n#else\r\n  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;\r\n#endif /* USE_SPI_CRC */\r\n\r\n  /* Verify that the SPI instance supports Data Size higher than 16bits */\r\n  if ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (hspi->Init.DataSize > SPI_DATASIZE_16BIT))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Verify that the SPI instance supports requested data packing */\r\n  packet_length = SPI_GetPacketSize(hspi);\r\n  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||\r\n      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n#if (USE_SPI_CRC != 0UL)\r\n  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)\r\n  {\r\n    /* Verify that the SPI instance supports CRC Length higher than 16bits */\r\n    if ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (hspi->Init.CRCLength > SPI_CRC_LENGTH_16BIT))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    /* Align the CRC Length on the data size */\r\n    if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)\r\n    {\r\n      crc_length = (hspi->Init.DataSize >> SPI_CFG1_DSIZE_Pos) << SPI_CFG1_CRCSIZE_Pos;\r\n    }\r\n    else\r\n    {\r\n      crc_length = hspi->Init.CRCLength;\r\n    }\r\n\r\n    /* Verify that the CRC Length is higher than DataSize */\r\n    if ((hspi->Init.DataSize >> SPI_CFG1_DSIZE_Pos) > (crc_length >> SPI_CFG1_CRCSIZE_Pos))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    crc_length = hspi->Init.DataSize << SPI_CFG1_CRCSIZE_Pos;\r\n  }\r\n#endif /* USE_SPI_CRC */\r\n\r\n  if (hspi->State == HAL_SPI_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    hspi->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n    /* Init the SPI Callback settings */\r\n    hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */\r\n    hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */\r\n    hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */\r\n    hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */\r\n    hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */\r\n    hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */\r\n    hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */\r\n    hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */\r\n\r\n    if (hspi->MspInitCallback == NULL)\r\n    {\r\n      hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */\r\n    }\r\n\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC... */\r\n    hspi->MspInitCallback(hspi);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC... */\r\n    HAL_SPI_MspInit(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  hspi->State = HAL_SPI_STATE_BUSY;\r\n\r\n  /* Disable the selected SPI peripheral */\r\n  __HAL_SPI_DISABLE(hspi);\r\n\r\n#if (USE_SPI_CRC == 0)\r\n  /* Keep the default value of CRCSIZE in case of CRC is not used */\r\n  crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;\r\n#endif /* USE_SPI_CRC */\r\n\r\n  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/\r\n  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,\r\n  Communication speed, First bit, CRC calculation state, CRC Length */\r\n\r\n  /* SPIx NSS Software Management Configuration */\r\n  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \\\r\n                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \\\r\n                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \\\r\n                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))\r\n  {\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);\r\n  }\r\n\r\n  /* SPIx CFG1 Configuration */\r\n  WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |\r\n                                   hspi->Init.FifoThreshold     | hspi->Init.DataSize));\r\n\r\n  /* SPIx CFG2 Configuration */\r\n  WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                | hspi->Init.TIMode    |\r\n                                   hspi->Init.NSSPolarity             | hspi->Init.NSS       |\r\n                                   hspi->Init.CLKPolarity             | hspi->Init.CLKPhase  |\r\n                                   hspi->Init.FirstBit                | hspi->Init.Mode      |\r\n                                   hspi->Init.MasterInterDataIdleness | hspi->Init.Direction |\r\n                                   hspi->Init.MasterSSIdleness        | hspi->Init.IOSwap));\r\n\r\n#if (USE_SPI_CRC != 0UL)\r\n  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/\r\n  /* Configure : CRC Polynomial */\r\n  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)\r\n  {\r\n    /* Initialize TXCRC Pattern Initial Value */\r\n    if (hspi->Init.TxCRCInitializationPattern == SPI_CRC_INITIALIZATION_ALL_ONE_PATTERN)\r\n    {\r\n      SET_BIT(hspi->Instance->CR1, SPI_CR1_TCRCINI);\r\n    }\r\n    else\r\n    {\r\n      CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_TCRCINI);\r\n    }\r\n\r\n    /* Initialize RXCRC Pattern Initial Value */\r\n    if (hspi->Init.RxCRCInitializationPattern == SPI_CRC_INITIALIZATION_ALL_ONE_PATTERN)\r\n    {\r\n      SET_BIT(hspi->Instance->CR1, SPI_CR1_RCRCINI);\r\n    }\r\n    else\r\n    {\r\n      CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_RCRCINI);\r\n    }\r\n\r\n    /* Enable 33/17 bits CRC computation */\r\n    if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (crc_length == SPI_CRC_LENGTH_16BIT)) ||\r\n        ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance))  && (crc_length == SPI_CRC_LENGTH_32BIT)))\r\n    {\r\n      SET_BIT(hspi->Instance->CR1, SPI_CR1_CRC33_17);\r\n    }\r\n    else\r\n    {\r\n      CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRC33_17);\r\n    }\r\n\r\n    /* Write CRC polynomial in SPI Register */\r\n    WRITE_REG(hspi->Instance->CRCPOLY, hspi->Init.CRCPolynomial);\r\n  }\r\n#endif /* USE_SPI_CRC */\r\n\r\n  /* Insure that Underrun configuration is managed only by Salve */\r\n  if (hspi->Init.Mode == SPI_MODE_SLAVE)\r\n  {\r\n    /* Set Default Underrun configuration */\r\n#if (USE_SPI_CRC != 0UL)\r\n    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_DISABLE)\r\n#endif /* USE_SPI_CRC */\r\n    {\r\n      MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, SPI_CFG1_UDRDET_0);\r\n    }\r\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, SPI_CFG1_UDRCFG_1);\r\n  }\r\n\r\n#if defined(SPI_I2SCFGR_I2SMOD)\r\n  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */\r\n  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);\r\n#endif /* SPI_I2SCFGR_I2SMOD */\r\n\r\n  /* Insure that AFCNTR is managed only by Master */\r\n  if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)\r\n  {\r\n    /* Alternate function GPIOs control */\r\n    MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));\r\n  }\r\n\r\n  hspi->ErrorCode = HAL_SPI_ERROR_NONE;\r\n  hspi->State     = HAL_SPI_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  De-Initialize the SPI peripheral.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Check the SPI handle allocation */\r\n  if (hspi == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check SPI Instance parameter */\r\n  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));\r\n\r\n  hspi->State = HAL_SPI_STATE_BUSY;\r\n\r\n  /* Disable the SPI Peripheral Clock */\r\n  __HAL_SPI_DISABLE(hspi);\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  if (hspi->MspDeInitCallback == NULL)\r\n  {\r\n    hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */\r\n  }\r\n\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */\r\n  hspi->MspDeInitCallback(hspi);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */\r\n  HAL_SPI_MspDeInit(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n\r\n  hspi->ErrorCode = HAL_SPI_ERROR_NONE;\r\n  hspi->State = HAL_SPI_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hspi);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the SPI MSP.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_MspInit should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  De-Initialize the SPI MSP.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_MspDeInit should be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n/**\r\n  * @brief  Register a User SPI Callback\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified SPI.\r\n  * @param  CallbackID ID of the callback to be registered\r\n  * @param  pCallback pointer to the Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_RegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID,\r\n                                           pSPI_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    /* Update the error code */\r\n    hspi->ErrorCode |= HAL_SPI_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if (HAL_SPI_STATE_READY == hspi->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_SPI_TX_COMPLETE_CB_ID :\r\n        hspi->TxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_RX_COMPLETE_CB_ID :\r\n        hspi->RxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_TX_RX_COMPLETE_CB_ID :\r\n        hspi->TxRxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_TX_HALF_COMPLETE_CB_ID :\r\n        hspi->TxHalfCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_RX_HALF_COMPLETE_CB_ID :\r\n        hspi->RxHalfCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :\r\n        hspi->TxRxHalfCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_ERROR_CB_ID :\r\n        hspi->ErrorCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_ABORT_CB_ID :\r\n        hspi->AbortCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_MSPINIT_CB_ID :\r\n        hspi->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_MSPDEINIT_CB_ID :\r\n        hspi->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_SPI_STATE_RESET == hspi->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_SPI_MSPINIT_CB_ID :\r\n        hspi->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_SPI_MSPDEINIT_CB_ID :\r\n        hspi->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hspi);\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister an SPI Callback\r\n  *         SPI callback is redirected to the weak predefined callback\r\n  * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified SPI.\r\n  * @param  CallbackID ID of the callback to be unregistered\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_UnRegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if (HAL_SPI_STATE_READY == hspi->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_SPI_TX_COMPLETE_CB_ID :\r\n        hspi->TxCpltCallback = HAL_SPI_TxCpltCallback;             /* Legacy weak TxCpltCallback       */\r\n        break;\r\n\r\n      case HAL_SPI_RX_COMPLETE_CB_ID :\r\n        hspi->RxCpltCallback = HAL_SPI_RxCpltCallback;             /* Legacy weak RxCpltCallback       */\r\n        break;\r\n\r\n      case HAL_SPI_TX_RX_COMPLETE_CB_ID :\r\n        hspi->TxRxCpltCallback = HAL_SPI_TxRxCpltCallback;         /* Legacy weak TxRxCpltCallback     */\r\n        break;\r\n\r\n      case HAL_SPI_TX_HALF_COMPLETE_CB_ID :\r\n        hspi->TxHalfCpltCallback = HAL_SPI_TxHalfCpltCallback;     /* Legacy weak TxHalfCpltCallback   */\r\n        break;\r\n\r\n      case HAL_SPI_RX_HALF_COMPLETE_CB_ID :\r\n        hspi->RxHalfCpltCallback = HAL_SPI_RxHalfCpltCallback;     /* Legacy weak RxHalfCpltCallback   */\r\n        break;\r\n\r\n      case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :\r\n        hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */\r\n        break;\r\n\r\n      case HAL_SPI_ERROR_CB_ID :\r\n        hspi->ErrorCallback = HAL_SPI_ErrorCallback;               /* Legacy weak ErrorCallback        */\r\n        break;\r\n\r\n      case HAL_SPI_ABORT_CB_ID :\r\n        hspi->AbortCpltCallback = HAL_SPI_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */\r\n        break;\r\n\r\n      case HAL_SPI_MSPINIT_CB_ID :\r\n        hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */\r\n        break;\r\n\r\n      case HAL_SPI_MSPDEINIT_CB_ID :\r\n        hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_SPI_STATE_RESET == hspi->State)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_SPI_MSPINIT_CB_ID :\r\n        hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */\r\n        break;\r\n\r\n      case HAL_SPI_MSPDEINIT_CB_ID :\r\n        hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */\r\n        break;\r\n\r\n      default :\r\n        /* Update the error code */\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);\r\n\r\n        /* Return error status */\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Update the error code */\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);\r\n\r\n    /* Return error status */\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(hspi);\r\n  return status;\r\n}\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup SPI_Exported_Functions_Group2 IO operation functions\r\n  *  @brief   Data transfers functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n [..]\r\n    This subsection provides a set of functions allowing to manage the SPI\r\n    data transfers.\r\n\r\n    [..] The SPI supports master and slave mode :\r\n\r\n    (#) There are two modes of transfer:\r\n       (##) Blocking mode: The communication is performed in polling mode.\r\n            The HAL status of all data processing is returned by the same function\r\n            after finishing transfer.\r\n       (##) No-Blocking mode: The communication is performed using Interrupts\r\n            or DMA, These APIs return the HAL status.\r\n            The end of the data processing will be indicated through the\r\n            dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when\r\n            using DMA mode.\r\n            The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks\r\n            will be executed respectively at the end of the transmit or Receive process\r\n            The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected\r\n\r\n    (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)\r\n        exist for 1Line (simplex) and 2Lines (full duplex) modes.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Transmit an amount of data in blocking mode.\r\n  * @param  hspi   : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                  the configuration information for SPI module.\r\n  * @param  pData  : pointer to data buffer\r\n  * @param  Size   : amount of data to be sent\r\n  * @param  Timeout: Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));\r\n#endif /* __GNUC__ */\r\n\r\n  uint32_t tickstart;\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_TXONLY(hspi->Init.Direction));\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Init tickstart for timeout management*/\r\n  tickstart = HAL_GetTick();\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->State       = HAL_SPI_STATE_BUSY_TX;\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pTxBuffPtr  = (uint8_t *)pData;\r\n  hspi->TxXferSize  = Size;\r\n  hspi->TxXferCount = Size;\r\n\r\n  /*Init field not used in handle to zero */\r\n  hspi->pRxBuffPtr  = NULL;\r\n  hspi->RxXferSize  = (uint16_t) 0UL;\r\n  hspi->RxXferCount = (uint16_t) 0UL;\r\n  hspi->TxISR       = NULL;\r\n  hspi->RxISR       = NULL;\r\n\r\n  /* Configure communication direction : 1Line */\r\n  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)\r\n  {\r\n    SPI_1LINE_TX(hspi);\r\n  }\r\n\r\n  /* Set the number of data at current transfer */\r\n  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Transmit data in 32 Bit mode */\r\n  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n  {\r\n    /* Transmit data in 32 Bit mode */\r\n    while (hspi->TxXferCount > 0UL)\r\n    {\r\n      /* Wait until TXP flag is set to send data */\r\n      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP))\r\n      {\r\n        *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n        hspi->pTxBuffPtr += sizeof(uint32_t);\r\n        hspi->TxXferCount--;\r\n      }\r\n      else\r\n      {\r\n        /* Timeout management */\r\n        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n        {\r\n          /* Call standard close procedure with error check */\r\n          SPI_CloseTransfer(hspi);\r\n\r\n          /* Unlock the process */\r\n          __HAL_UNLOCK(hspi);\r\n\r\n          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n          hspi->State = HAL_SPI_STATE_READY;\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* Transmit data in 16 Bit mode */\r\n  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n  {\r\n    /* Transmit data in 16 Bit mode */\r\n    while (hspi->TxXferCount > 0UL)\r\n    {\r\n      /* Wait until TXP flag is set to send data */\r\n      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP))\r\n      {\r\n        if ((hspi->TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))\r\n        {\r\n          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint32_t);\r\n          hspi->TxXferCount -= (uint16_t)2UL;\r\n        }\r\n        else\r\n        {\r\n#if defined (__GNUC__)\r\n          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n          hspi->pTxBuffPtr += sizeof(uint16_t);\r\n          hspi->TxXferCount--;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Timeout management */\r\n        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n        {\r\n          /* Call standard close procedure with error check */\r\n          SPI_CloseTransfer(hspi);\r\n\r\n          /* Unlock the process */\r\n          __HAL_UNLOCK(hspi);\r\n\r\n          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n          hspi->State = HAL_SPI_STATE_READY;\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* Transmit data in 8 Bit mode */\r\n  else\r\n  {\r\n    while (hspi->TxXferCount > 0UL)\r\n    {\r\n      /* Wait until TXP flag is set to send data */\r\n      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP))\r\n      {\r\n        if ((hspi->TxXferCount > 3UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_03DATA))\r\n        {\r\n          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint32_t);\r\n          hspi->TxXferCount -= (uint16_t)4UL;\r\n        }\r\n        else if ((hspi->TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))\r\n        {\r\n#if defined (__GNUC__)\r\n          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n          hspi->pTxBuffPtr += sizeof(uint16_t);\r\n          hspi->TxXferCount -= (uint16_t)2UL;\r\n        }\r\n        else\r\n        {\r\n          *((__IO uint8_t *)&hspi->Instance->TXDR) = *((uint8_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint8_t);\r\n          hspi->TxXferCount--;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Timeout management */\r\n        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n        {\r\n          /* Call standard close procedure with error check */\r\n          SPI_CloseTransfer(hspi);\r\n\r\n          /* Unlock the process */\r\n          __HAL_UNLOCK(hspi);\r\n\r\n          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n          hspi->State = HAL_SPI_STATE_READY;\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Wait for Tx (and CRC) data to be sent */\r\n  if (SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_EOT, RESET, tickstart, Timeout) != HAL_OK)\r\n  {\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);\r\n  }\r\n\r\n  /* Call standard close procedure with error check */\r\n  SPI_CloseTransfer(hspi);\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Receive an amount of data in blocking mode.\r\n  * @param  hspi   : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                  the configuration information for SPI module.\r\n  * @param  pData  : pointer to data buffer\r\n  * @param  Size   : amount of data to be received\r\n  * @param  Timeout: Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint32_t tickstart;\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));\r\n#endif /* __GNUC__ */\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_RXONLY(hspi->Init.Direction));\r\n\r\n  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))\r\n  {\r\n    hspi->State = HAL_SPI_STATE_BUSY_RX;\r\n    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */\r\n    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);\r\n  }\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Init tickstart for timeout management*/\r\n  tickstart = HAL_GetTick();\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->State       = HAL_SPI_STATE_BUSY_RX;\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pRxBuffPtr  = (uint8_t *)pData;\r\n  hspi->RxXferSize  = Size;\r\n  hspi->RxXferCount = Size;\r\n\r\n  /*Init field not used in handle to zero */\r\n  hspi->pTxBuffPtr  = NULL;\r\n  hspi->TxXferSize  = (uint16_t) 0UL;\r\n  hspi->TxXferCount = (uint16_t) 0UL;\r\n  hspi->RxISR       = NULL;\r\n  hspi->TxISR       = NULL;\r\n\r\n  /* Configure communication direction: 1Line */\r\n  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)\r\n  {\r\n    SPI_1LINE_RX(hspi);\r\n  }\r\n\r\n  /* Set the number of data at current transfer */\r\n  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Receive data in 32 Bit mode */\r\n  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n  {\r\n    /* Transfer loop */\r\n    while (hspi->RxXferCount > 0UL)\r\n    {\r\n      /* Check the RXWNE/EOT flag */\r\n      if ((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_EOT)) != 0UL)\r\n      {\r\n        *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n        hspi->pRxBuffPtr += sizeof(uint32_t);\r\n        hspi->RxXferCount--;\r\n      }\r\n      else\r\n      {\r\n        /* Timeout management */\r\n        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n        {\r\n          /* Call standard close procedure with error check */\r\n          SPI_CloseTransfer(hspi);\r\n\r\n          /* Unlock the process */\r\n          __HAL_UNLOCK(hspi);\r\n\r\n          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n          hspi->State = HAL_SPI_STATE_READY;\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* Receive data in 16 Bit mode */\r\n  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n  {\r\n    /* Transfer loop */\r\n    while (hspi->RxXferCount > 0UL)\r\n    {\r\n      /* Check the RXWNE/FRLVL flag */\r\n      if ((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_FRLVL)) != 0UL)\r\n      {\r\n        if ((hspi->Instance->SR & SPI_FLAG_RXWNE) != 0UL)\r\n        {\r\n          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n          hspi->pRxBuffPtr += sizeof(uint32_t);\r\n          hspi->RxXferCount -= (uint16_t)2UL;\r\n        }\r\n        else\r\n        {\r\n#if defined (__GNUC__)\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;\r\n#else\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);\r\n#endif /* __GNUC__ */\r\n          hspi->pRxBuffPtr += sizeof(uint16_t);\r\n          hspi->RxXferCount--;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Timeout management */\r\n        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n        {\r\n          /* Call standard close procedure with error check */\r\n          SPI_CloseTransfer(hspi);\r\n\r\n          /* Unlock the process */\r\n          __HAL_UNLOCK(hspi);\r\n\r\n          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n          hspi->State = HAL_SPI_STATE_READY;\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /* Receive data in 8 Bit mode */\r\n  else\r\n  {\r\n    /* Transfer loop */\r\n    while (hspi->RxXferCount > 0UL)\r\n    {\r\n      /* Check the RXWNE/FRLVL flag */\r\n      if ((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_FRLVL)) != 0UL)\r\n      {\r\n        if ((hspi->Instance->SR & SPI_FLAG_RXWNE) != 0UL)\r\n        {\r\n          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n          hspi->pRxBuffPtr += sizeof(uint32_t);\r\n          hspi->RxXferCount -= (uint16_t)4UL;\r\n        }\r\n        else if ((hspi->Instance->SR & SPI_FLAG_FRLVL) > SPI_RX_FIFO_1PACKET)\r\n        {\r\n#if defined (__GNUC__)\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;\r\n#else\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);\r\n#endif /* __GNUC__ */\r\n          hspi->pRxBuffPtr += sizeof(uint16_t);\r\n          hspi->RxXferCount -= (uint16_t)2UL;\r\n        }\r\n        else\r\n        {\r\n          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);\r\n          hspi->pRxBuffPtr += sizeof(uint8_t);\r\n          hspi->RxXferCount--;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Timeout management */\r\n        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n        {\r\n          /* Call standard close procedure with error check */\r\n          SPI_CloseTransfer(hspi);\r\n\r\n          /* Unlock the process */\r\n          __HAL_UNLOCK(hspi);\r\n\r\n          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n          hspi->State = HAL_SPI_STATE_READY;\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n#if (USE_SPI_CRC != 0UL)\r\n  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)\r\n  {\r\n    /* Wait for crc data to be received */\r\n    if (SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_EOT, RESET, tickstart, Timeout) != HAL_OK)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);\r\n    }\r\n  }\r\n#endif /* USE_SPI_CRC */\r\n\r\n  /* Call standard close procedure with error check */\r\n  SPI_CloseTransfer(hspi);\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Transmit and Receive an amount of data in blocking mode.\r\n  * @param  hspi   : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                  the configuration information for SPI module.\r\n  * @param  pTxData: pointer to transmission data buffer\r\n  * @param  pRxData: pointer to reception data buffer\r\n  * @param  Size   : amount of data to be sent and received\r\n  * @param  Timeout: Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,\r\n                                          uint32_t Timeout)\r\n{\r\n  HAL_SPI_StateTypeDef tmp_state;\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));\r\n  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));\r\n#endif /* __GNUC__ */\r\n\r\n  uint32_t   tickstart;\r\n  uint32_t   tmp_mode;\r\n  uint16_t   initial_TxXferCount;\r\n  uint16_t   initial_RxXferCount;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Init tickstart for timeout management*/\r\n  tickstart = HAL_GetTick();\r\n\r\n  initial_TxXferCount = Size;\r\n  initial_RxXferCount = Size;\r\n  tmp_state           = hspi->State;\r\n  tmp_mode            = hspi->Init.Mode;\r\n\r\n  if (!((tmp_state == HAL_SPI_STATE_READY) || \\\r\n        ((tmp_mode == SPI_MODE_MASTER) && \\\r\n         (hspi->Init.Direction == SPI_DIRECTION_2LINES) && \\\r\n         (tmp_state == HAL_SPI_STATE_BUSY_RX))))\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */\r\n  if (hspi->State != HAL_SPI_STATE_BUSY_RX)\r\n  {\r\n    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pRxBuffPtr  = (uint8_t *)pRxData;\r\n  hspi->RxXferCount = Size;\r\n  hspi->RxXferSize  = Size;\r\n  hspi->pTxBuffPtr  = (uint8_t *)pTxData;\r\n  hspi->TxXferCount = Size;\r\n  hspi->TxXferSize  = Size;\r\n\r\n  /*Init field not used in handle to zero */\r\n  hspi->RxISR       = NULL;\r\n  hspi->TxISR       = NULL;\r\n\r\n  /* Set the number of data at current transfer */\r\n  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Transmit and Receive data in 32 Bit mode */\r\n  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n  {\r\n    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))\r\n    {\r\n      /* Check TXP flag */\r\n      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL))\r\n      {\r\n        *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n        hspi->pTxBuffPtr += sizeof(uint32_t);\r\n        hspi->TxXferCount --;\r\n        initial_TxXferCount = hspi->TxXferCount;\r\n      }\r\n\r\n      /* Check RXWNE/EOT flag */\r\n      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_EOT)) != 0UL) && (initial_RxXferCount > 0UL))\r\n      {\r\n        *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n        hspi->pRxBuffPtr += sizeof(uint32_t);\r\n        hspi->RxXferCount --;\r\n        initial_RxXferCount = hspi->RxXferCount;\r\n      }\r\n\r\n      /* Timeout management */\r\n      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n      {\r\n        /* Call standard close procedure with error check */\r\n        SPI_CloseTransfer(hspi);\r\n\r\n        /* Unlock the process */\r\n        __HAL_UNLOCK(hspi);\r\n\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n        hspi->State = HAL_SPI_STATE_READY;\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /* Transmit and Receive data in 16 Bit mode */\r\n  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n  {\r\n    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))\r\n    {\r\n      /* Check TXP flag */\r\n      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP) && (initial_TxXferCount > 0UL))\r\n      {\r\n        if ((initial_TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))\r\n        {\r\n          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint32_t);\r\n          hspi->TxXferCount -= (uint16_t)2UL;\r\n          initial_TxXferCount = hspi->TxXferCount;\r\n        }\r\n        else\r\n        {\r\n#if defined (__GNUC__)\r\n          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n          hspi->pTxBuffPtr += sizeof(uint16_t);\r\n          hspi->TxXferCount--;\r\n          initial_TxXferCount = hspi->TxXferCount;\r\n        }\r\n      }\r\n\r\n      /* Check RXWNE/FRLVL flag */\r\n      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_FRLVL)) != 0UL) && (initial_RxXferCount > 0UL))\r\n      {\r\n        if ((hspi->Instance->SR & SPI_FLAG_RXWNE) != 0UL)\r\n        {\r\n          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n          hspi->pRxBuffPtr += sizeof(uint32_t);\r\n          hspi->RxXferCount -= (uint16_t)2UL;\r\n          initial_RxXferCount = hspi->RxXferCount;\r\n        }\r\n        else\r\n        {\r\n#if defined (__GNUC__)\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;\r\n#else\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);\r\n#endif /* __GNUC__ */\r\n          hspi->pRxBuffPtr += sizeof(uint16_t);\r\n          hspi->RxXferCount--;\r\n          initial_RxXferCount = hspi->RxXferCount;\r\n        }\r\n      }\r\n\r\n      /* Timeout management */\r\n      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n      {\r\n        /* Call standard close procedure with error check */\r\n        SPI_CloseTransfer(hspi);\r\n\r\n        /* Unlock the process */\r\n        __HAL_UNLOCK(hspi);\r\n\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n        hspi->State = HAL_SPI_STATE_READY;\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  /* Transmit and Receive data in 8 Bit mode */\r\n  else\r\n  {\r\n    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))\r\n    {\r\n      /* check TXP flag */\r\n      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL))\r\n      {\r\n        if ((initial_TxXferCount > 3UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_03DATA))\r\n        {\r\n          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint32_t);\r\n          hspi->TxXferCount -= (uint16_t)4UL;\r\n          initial_TxXferCount = hspi->TxXferCount;\r\n        }\r\n        else if ((initial_TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))\r\n        {\r\n#if defined (__GNUC__)\r\n          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n          hspi->pTxBuffPtr += sizeof(uint16_t);\r\n          hspi->TxXferCount -= (uint16_t)2UL;\r\n          initial_TxXferCount = hspi->TxXferCount;\r\n        }\r\n        else\r\n        {\r\n          *((__IO uint8_t *)&hspi->Instance->TXDR) = *((uint8_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint8_t);\r\n          hspi->TxXferCount--;\r\n          initial_TxXferCount = hspi->TxXferCount;\r\n        }\r\n      }\r\n\r\n      /* Wait until RXWNE/FRLVL flag is reset */\r\n      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_FRLVL)) != 0UL) && (initial_RxXferCount > 0UL))\r\n      {\r\n        if ((hspi->Instance->SR & SPI_FLAG_RXWNE) != 0UL)\r\n        {\r\n          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n          hspi->pRxBuffPtr += sizeof(uint32_t);\r\n          hspi->RxXferCount -= (uint16_t)4UL;\r\n          initial_RxXferCount = hspi->RxXferCount;\r\n        }\r\n        else if ((hspi->Instance->SR & SPI_FLAG_FRLVL) > SPI_RX_FIFO_1PACKET)\r\n        {\r\n#if defined (__GNUC__)\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;\r\n#else\r\n          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);\r\n#endif /* __GNUC__ */\r\n          hspi->pRxBuffPtr += sizeof(uint16_t);\r\n          hspi->RxXferCount -= (uint16_t)2UL;\r\n          initial_RxXferCount = hspi->RxXferCount;\r\n        }\r\n        else\r\n        {\r\n          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);\r\n          hspi->pRxBuffPtr += sizeof(uint8_t);\r\n          hspi->RxXferCount--;\r\n          initial_RxXferCount = hspi->RxXferCount;\r\n        }\r\n      }\r\n\r\n      /* Timeout management */\r\n      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n      {\r\n        /* Call standard close procedure with error check */\r\n        SPI_CloseTransfer(hspi);\r\n\r\n        /* Unlock the process */\r\n        __HAL_UNLOCK(hspi);\r\n\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);\r\n        hspi->State = HAL_SPI_STATE_READY;\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Wait for Tx/Rx (and CRC) data to be sent/received */\r\n  if (SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_EOT, RESET, tickstart, Timeout) != HAL_OK)\r\n  {\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);\r\n  }\r\n\r\n  /* Call standard close procedure with error check */\r\n  SPI_CloseTransfer(hspi);\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Transmit an amount of data in non-blocking mode with Interrupt.\r\n  * @param  hspi : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for SPI module.\r\n  * @param  pData: pointer to data buffer\r\n  * @param  Size : amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_TXONLY(hspi->Init.Direction));\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->State       = HAL_SPI_STATE_BUSY_TX;\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pTxBuffPtr  = (uint8_t *)pData;\r\n  hspi->TxXferSize  = Size;\r\n  hspi->TxXferCount = Size;\r\n\r\n  /* Init field not used in handle to zero */\r\n  hspi->pRxBuffPtr  = NULL;\r\n  hspi->RxXferSize  = (uint16_t) 0UL;\r\n  hspi->RxXferCount = (uint16_t) 0UL;\r\n  hspi->RxISR       = NULL;\r\n\r\n  /* Set the function for IT treatment */\r\n  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n  {\r\n    hspi->TxISR = SPI_TxISR_32BIT;\r\n  }\r\n  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n  {\r\n    hspi->TxISR = SPI_TxISR_16BIT;\r\n  }\r\n  else\r\n  {\r\n    hspi->TxISR = SPI_TxISR_8BIT;\r\n  }\r\n\r\n  /* Configure communication direction : 1Line */\r\n  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)\r\n  {\r\n    SPI_1LINE_TX(hspi);\r\n  }\r\n\r\n  /* Set the number of data at current transfer */\r\n  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  /* Enable EOT, TXP, FRE, MODF, UDR and TSERF interrupts */\r\n  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_UDR | SPI_IT_FRE | SPI_IT_MODF | SPI_IT_TSERF));\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Receive an amount of data in non-blocking mode with Interrupt.\r\n  * @param  hspi : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for SPI module.\r\n  * @param  pData: pointer to data buffer\r\n  * @param  Size : amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_RXONLY(hspi->Init.Direction));\r\n\r\n  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))\r\n  {\r\n    hspi->State = HAL_SPI_STATE_BUSY_RX;\r\n    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */\r\n    return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);\r\n  }\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->State       = HAL_SPI_STATE_BUSY_RX;\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pRxBuffPtr  = (uint8_t *)pData;\r\n  hspi->RxXferSize  = Size;\r\n  hspi->RxXferCount = Size;\r\n\r\n  /* Init field not used in handle to zero */\r\n  hspi->pTxBuffPtr  = NULL;\r\n  hspi->TxXferSize  = (uint16_t) 0UL;\r\n  hspi->TxXferCount = (uint16_t) 0UL;\r\n  hspi->TxISR       = NULL;\r\n\r\n  /* Set the function for IT treatment */\r\n  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n  {\r\n    hspi->RxISR = SPI_RxISR_32BIT;\r\n  }\r\n  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n  {\r\n    hspi->RxISR = SPI_RxISR_16BIT;\r\n  }\r\n  else\r\n  {\r\n    hspi->RxISR = SPI_RxISR_8BIT;\r\n  }\r\n\r\n  /* Configure communication direction : 1Line */\r\n  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)\r\n  {\r\n    SPI_1LINE_RX(hspi);\r\n  }\r\n\r\n  /* Note : The SPI must be enabled after unlocking current process\r\n            to avoid the risk of SPI interrupt handle execution before current\r\n            process unlock */\r\n\r\n  /* Set the number of data at current transfer */\r\n  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  /* Enable EOT, RXP, OVR, FRE, MODF and TSERF interrupts */\r\n  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_RXP | SPI_IT_OVR | SPI_IT_FRE | SPI_IT_MODF | SPI_IT_TSERF));\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Transmit and Receive an amount of data in non-blocking mode with Interrupt.\r\n  * @param  hspi   : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                  the configuration information for SPI module.\r\n  * @param  pTxData: pointer to transmission data buffer\r\n  * @param  pRxData: pointer to reception data buffer\r\n  * @param  Size   : amount of data to be sent and received\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)\r\n{\r\n  HAL_SPI_StateTypeDef  tmp_state;\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n  uint32_t max_fifo_length = 0UL;\r\n  uint32_t tmp_TxXferCount;\r\n\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));\r\n#endif /* __GNUC__ */\r\n\r\n  uint32_t  tmp_mode;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Init temporary variables */\r\n  tmp_state  = hspi->State;\r\n  tmp_mode   = hspi->Init.Mode;\r\n\r\n  if (!((tmp_state == HAL_SPI_STATE_READY) || \\\r\n        ((tmp_mode == SPI_MODE_MASTER) && \\\r\n         (hspi->Init.Direction == SPI_DIRECTION_2LINES) && \\\r\n         (tmp_state == HAL_SPI_STATE_BUSY_RX))))\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */\r\n  if (hspi->State != HAL_SPI_STATE_BUSY_RX)\r\n  {\r\n    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pTxBuffPtr  = (uint8_t *)pTxData;\r\n  hspi->TxXferSize  = Size;\r\n  hspi->TxXferCount = Size;\r\n  hspi->pRxBuffPtr  = (uint8_t *)pRxData;\r\n  hspi->RxXferSize  = Size;\r\n  hspi->RxXferCount = Size;\r\n  tmp_TxXferCount   = hspi->TxXferCount;\r\n\r\n  /* Set the function for IT treatment */\r\n  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n  {\r\n    hspi->TxISR     = SPI_TxISR_32BIT;\r\n    hspi->RxISR     = SPI_RxISR_32BIT;\r\n  }\r\n  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n  {\r\n    hspi->RxISR     = SPI_RxISR_16BIT;\r\n    hspi->TxISR     = SPI_TxISR_16BIT;\r\n  }\r\n  else\r\n  {\r\n    hspi->RxISR     = SPI_RxISR_8BIT;\r\n    hspi->TxISR     = SPI_TxISR_8BIT;\r\n  }\r\n\r\n  /* Set the number of data at current transfer */\r\n  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  /* Fill in the TxFIFO */\r\n  while ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (tmp_TxXferCount != 0UL))\r\n  {\r\n    if (max_fifo_length < MAX_FIFO_LENGTH)\r\n    {\r\n      /* Transmit data in 32 Bit mode */\r\n      if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n      {\r\n        *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n        hspi->pTxBuffPtr += sizeof(uint32_t);\r\n        hspi->TxXferCount--;\r\n        tmp_TxXferCount = hspi->TxXferCount;\r\n      }\r\n      /* Transmit data in 16 Bit mode */\r\n      else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n      {\r\n        if ((hspi->TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))\r\n        {\r\n          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint32_t);\r\n          hspi->TxXferCount -= (uint16_t)2UL;\r\n          tmp_TxXferCount = hspi->TxXferCount;\r\n        }\r\n        else\r\n        {\r\n#if defined (__GNUC__)\r\n          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n          hspi->pTxBuffPtr += sizeof(uint16_t);\r\n          hspi->TxXferCount--;\r\n          tmp_TxXferCount = hspi->TxXferCount;\r\n        }\r\n      }\r\n      /* Transmit data in 8 Bit mode */\r\n      else\r\n      {\r\n        if ((hspi->TxXferCount > 3UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_03DATA))\r\n        {\r\n          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint32_t);\r\n          hspi->TxXferCount -= (uint16_t)4UL;\r\n          tmp_TxXferCount = hspi->TxXferCount;\r\n        }\r\n        else if ((hspi->TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))\r\n        {\r\n#if defined (__GNUC__)\r\n          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n          hspi->pTxBuffPtr += sizeof(uint16_t);\r\n          hspi->TxXferCount -= (uint16_t)2UL;\r\n          tmp_TxXferCount = hspi->TxXferCount;\r\n        }\r\n        else\r\n        {\r\n          *((__IO uint8_t *)&hspi->Instance->TXDR) = *((uint8_t *)hspi->pTxBuffPtr);\r\n          hspi->pTxBuffPtr += sizeof(uint8_t);\r\n          hspi->TxXferCount--;\r\n          tmp_TxXferCount = hspi->TxXferCount;\r\n        }\r\n      }\r\n\r\n      max_fifo_length++;\r\n    }\r\n    else\r\n    {\r\n      errorcode = HAL_BUSY;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n  }\r\n\r\n  /* Enable EOT, DXP, UDR, OVR, FRE, MODF and TSERF interrupts */\r\n  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR |\r\n                             SPI_IT_FRE | SPI_IT_MODF | SPI_IT_TSERF));\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Start Master transfer */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n/**\r\n  * @brief  Transmit an additional amount of data in blocking mode.\r\n  * @param  hspi : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for SPI module.\r\n  * @param  pData: pointer to data buffer\r\n  * @param  Size : amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Reload_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n  HAL_SPI_StateTypeDef  tmp_state;\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if (hspi->State == HAL_SPI_STATE_BUSY_TX)\r\n  {\r\n    /* check if there is already a request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      errorcode = HAL_ERROR;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n\r\n    /* Insert the new number of data to be sent just after the current one */\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSER, (Size & 0xFFFFFFFFUL) << 16UL);\r\n\r\n    /* Set the transaction information */\r\n    hspi->Reload.Requested   = 1UL;\r\n    hspi->Reload.pTxBuffPtr  = (uint8_t *)pData;\r\n    hspi->Reload.TxXferSize  = Size;\r\n\r\n    tmp_state = hspi->State;\r\n\r\n    /* Check if the current transmit is already completed */\r\n    if (((hspi->Instance->CR2 & SPI_CR2_TSER) != 0UL) && (tmp_state == HAL_SPI_STATE_READY))\r\n    {\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TSERF);\r\n      MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSER, 0UL);\r\n      hspi->Reload.Requested = 0UL;\r\n      errorcode = HAL_ERROR;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n/**\r\n  * @brief  Receive an additional amount of data in blocking mode.\r\n  * @param  hspi : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for SPI module.\r\n  * @param  pData: pointer to data buffer\r\n  * @param  Size : amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Reload_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n  HAL_SPI_StateTypeDef  tmp_state;\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if (hspi->State == HAL_SPI_STATE_BUSY_RX)\r\n  {\r\n    /* check if there is already a request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      errorcode = HAL_ERROR;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n\r\n    /* Insert the new number of data that will be received just after the current one */\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSER, (Size & 0xFFFFFFFFUL) << 16UL);\r\n\r\n    /* Set the transaction information */\r\n    hspi->Reload.Requested   = 1UL;\r\n    hspi->Reload.pRxBuffPtr  = (uint8_t *)pData;\r\n    hspi->Reload.RxXferSize  = Size;\r\n\r\n    tmp_state = hspi->State;\r\n\r\n    /* Check if the current reception is already completed */\r\n    if (((hspi->Instance->CR2 & SPI_CR2_TSER) != 0UL) && (tmp_state == HAL_SPI_STATE_READY))\r\n    {\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TSERF);\r\n      MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSER, 0UL);\r\n      hspi->Reload.Requested = 0UL;\r\n      errorcode = HAL_ERROR;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n/**\r\n  * @brief  Transmit and receive an additional amount of data in blocking mode.\r\n  * @param  hspi   : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                  the configuration information for SPI module.\r\n  * @param  pTxData: pointer to transmission data buffer\r\n  * @param  pRxData: pointer to reception data buffer\r\n  * @param  Size   : amount of data to be sent and received\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Reload_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n  HAL_SPI_StateTypeDef  tmp_state;\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if (hspi->State == HAL_SPI_STATE_BUSY_TX_RX)\r\n  {\r\n    /* check if there is already a request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      errorcode = HAL_ERROR;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n\r\n    /* Insert the new number of data that will be sent and received just after the current one */\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSER, (Size & 0xFFFFFFFFUL) << 16UL);\r\n\r\n    /* Set the transaction information */\r\n    hspi->Reload.Requested   = 1UL;\r\n    hspi->Reload.pTxBuffPtr  = (uint8_t *)pTxData;\r\n    hspi->Reload.TxXferSize  = Size;\r\n    hspi->Reload.pRxBuffPtr  = (uint8_t *)pRxData;\r\n    hspi->Reload.RxXferSize  = Size;\r\n\r\n    tmp_state = hspi->State;\r\n\r\n    /* Check if the current transmit is already completed */\r\n    if (((hspi->Instance->CR2 & SPI_CR2_TSER) != 0UL) && (tmp_state == HAL_SPI_STATE_READY))\r\n    {\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TSERF);\r\n      MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSER, 0UL);\r\n      hspi->Reload.Requested = 0UL;\r\n      errorcode = HAL_ERROR;\r\n      __HAL_UNLOCK(hspi);\r\n      return errorcode;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n\r\n/**\r\n  * @brief  Transmit an amount of data in non-blocking mode with DMA.\r\n  * @param  hspi : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for SPI module.\r\n  * @param  pData: pointer to data buffer\r\n  * @param  Size : amount of data to be sent\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_TXONLY(hspi->Init.Direction));\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->State       = HAL_SPI_STATE_BUSY_TX;\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pTxBuffPtr  = (uint8_t *)pData;\r\n  hspi->TxXferSize  = Size;\r\n  hspi->TxXferCount = Size;\r\n\r\n  /* Init field not used in handle to zero */\r\n  hspi->pRxBuffPtr  = NULL;\r\n  hspi->TxISR       = NULL;\r\n  hspi->RxISR       = NULL;\r\n  hspi->RxXferSize  = (uint16_t)0UL;\r\n  hspi->RxXferCount = (uint16_t)0UL;\r\n\r\n  /* Configure communication direction : 1Line */\r\n  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)\r\n  {\r\n    SPI_1LINE_TX(hspi);\r\n  }\r\n\r\n  /* Packing mode management is enabled by the DMA settings */\r\n  if (((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (hspi->hdmatx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))    || \\\r\n      ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) && ((hspi->hdmatx->Init.MemDataAlignment != DMA_MDATAALIGN_HALFWORD) && \\\r\n                                                     (hspi->hdmatx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))))\r\n  {\r\n    /* Restriction the DMA data received is not allowed in this mode */\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Adjust XferCount according to DMA alignment / Data size */\r\n  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)\r\n  {\r\n    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n    {\r\n      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 3UL) >> 2UL;\r\n    }\r\n  }\r\n  else if (hspi->Init.DataSize <= SPI_DATASIZE_16BIT)\r\n  {\r\n    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Adjustment done */\r\n  }\r\n\r\n  /* Set the SPI TxDMA Half transfer complete callback */\r\n  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;\r\n\r\n  /* Set the SPI TxDMA transfer complete callback */\r\n  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;\r\n\r\n  /* Set the DMA error callback */\r\n  hspi->hdmatx->XferErrorCallback = SPI_DMAError;\r\n\r\n  /* Set the DMA AbortCpltCallback */\r\n  hspi->hdmatx->XferAbortCallback = NULL;\r\n\r\n  /* Clear TXDMAEN bit*/\r\n  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);\r\n\r\n  /* Enable the Tx DMA Stream/Channel */\r\n  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->TXDR,\r\n                                 hspi->TxXferCount))\r\n  {\r\n    /* Update SPI error code */\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);\r\n\r\n    /* Unlock the process */\r\n    __HAL_UNLOCK(hspi);\r\n\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the number of data at current transfer */\r\n  if (hspi->hdmatx->Init.Mode == DMA_CIRCULAR)\r\n  {\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, 0UL);\r\n  }\r\n  else\r\n  {\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n  }\r\n\r\n  /* Enable Tx DMA Request */\r\n  SET_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);\r\n\r\n  /* Enable the SPI Error Interrupt Bit */\r\n  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_UDR | SPI_IT_FRE | SPI_IT_MODF));\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Receive an amount of data in non-blocking mode with DMA.\r\n  * @param  hspi : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                the configuration information for SPI module.\r\n  * @param  pData: pointer to data buffer\r\n  * @param  Size : amount of data to be sent\r\n  * @note   When the CRC feature is enabled the pData Length must be Size + 1.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE_2LINES_RXONLY(hspi->Init.Direction));\r\n\r\n  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))\r\n  {\r\n    hspi->State = HAL_SPI_STATE_BUSY_RX;\r\n    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */\r\n    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);\r\n  }\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->State       = HAL_SPI_STATE_BUSY_RX;\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pRxBuffPtr  = (uint8_t *)pData;\r\n  hspi->RxXferSize  = Size;\r\n  hspi->RxXferCount = Size;\r\n\r\n  /*Init field not used in handle to zero */\r\n  hspi->RxISR       = NULL;\r\n  hspi->TxISR       = NULL;\r\n  hspi->TxXferSize  = (uint16_t) 0UL;\r\n  hspi->TxXferCount = (uint16_t) 0UL;\r\n\r\n  /* Configure communication direction : 1Line */\r\n  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)\r\n  {\r\n    SPI_1LINE_RX(hspi);\r\n  }\r\n\r\n  /* Packing mode management is enabled by the DMA settings */\r\n  if (((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (hspi->hdmarx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))    || \\\r\n      ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) && ((hspi->hdmarx->Init.MemDataAlignment != DMA_MDATAALIGN_HALFWORD) && \\\r\n                                                     (hspi->hdmarx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))))\r\n  {\r\n    /* Restriction the DMA data received is not allowed in this mode */\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Clear RXDMAEN bit */\r\n  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_RXDMAEN);\r\n\r\n  /* Adjust XferCount according to DMA alignment / Data size */\r\n  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)\r\n  {\r\n    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n    {\r\n      hspi->RxXferCount = (hspi->RxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->RxXferCount = (hspi->RxXferCount + (uint16_t) 3UL) >> 2UL;\r\n    }\r\n  }\r\n  else if (hspi->Init.DataSize <= SPI_DATASIZE_16BIT)\r\n  {\r\n    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->RxXferCount = (hspi->RxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Adjustment done */\r\n  }\r\n\r\n  /* Set the SPI RxDMA Half transfer complete callback */\r\n  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;\r\n\r\n  /* Set the SPI Rx DMA transfer complete callback */\r\n  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;\r\n\r\n  /* Set the DMA error callback */\r\n  hspi->hdmarx->XferErrorCallback = SPI_DMAError;\r\n\r\n  /* Set the DMA AbortCpltCallback */\r\n  hspi->hdmarx->XferAbortCallback = NULL;\r\n\r\n  /* Enable the Rx DMA Stream/Channel  */\r\n  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->RXDR, (uint32_t)hspi->pRxBuffPtr,\r\n                                 hspi->RxXferCount))\r\n  {\r\n    /* Update SPI error code */\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);\r\n\r\n    /* Unlock the process */\r\n    __HAL_UNLOCK(hspi);\r\n\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  /* Set the number of data at current transfer */\r\n  if (hspi->hdmarx->Init.Mode == DMA_CIRCULAR)\r\n  {\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, 0UL);\r\n  }\r\n  else\r\n  {\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n  }\r\n\r\n  /* Enable Rx DMA Request */\r\n  SET_BIT(hspi->Instance->CFG1, SPI_CFG1_RXDMAEN);\r\n\r\n  /* Enable the SPI Error Interrupt Bit */\r\n  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_OVR | SPI_IT_FRE | SPI_IT_MODF));\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Transmit and Receive an amount of data in non-blocking mode with DMA.\r\n  * @param  hspi   : pointer to a SPI_HandleTypeDef structure that contains\r\n  *                  the configuration information for SPI module.\r\n  * @param  pTxData: pointer to transmission data buffer\r\n  * @param  pRxData: pointer to reception data buffer\r\n  * @param  Size   : amount of data to be sent\r\n  * @note   When the CRC feature is enabled the pRxData Length must be Size + 1\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,\r\n                                              uint16_t Size)\r\n{\r\n  HAL_SPI_StateTypeDef tmp_state;\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  uint32_t             tmp_mode;\r\n\r\n  /* Check Direction parameter */\r\n  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Init temporary variables */\r\n  tmp_state   = hspi->State;\r\n  tmp_mode    = hspi->Init.Mode;\r\n\r\n  if (!((tmp_state == HAL_SPI_STATE_READY) || \\\r\n        ((tmp_mode == SPI_MODE_MASTER) && \\\r\n         (hspi->Init.Direction == SPI_DIRECTION_2LINES) && \\\r\n         (tmp_state == HAL_SPI_STATE_BUSY_RX))))\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))\r\n  {\r\n    errorcode = HAL_ERROR;\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */\r\n  if (hspi->State != HAL_SPI_STATE_BUSY_RX)\r\n  {\r\n    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;\r\n  }\r\n\r\n  /* Set the transaction information */\r\n  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;\r\n  hspi->pTxBuffPtr  = (uint8_t *)pTxData;\r\n  hspi->TxXferSize  = Size;\r\n  hspi->TxXferCount = Size;\r\n  hspi->pRxBuffPtr  = (uint8_t *)pRxData;\r\n  hspi->RxXferSize  = Size;\r\n  hspi->RxXferCount = Size;\r\n\r\n  /* Init field not used in handle to zero */\r\n  hspi->RxISR       = NULL;\r\n  hspi->TxISR       = NULL;\r\n\r\n  /* Reset the Tx/Rx DMA bits */\r\n  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);\r\n\r\n  /* Packing mode management is enabled by the DMA settings */\r\n  if (((hspi->Init.DataSize > SPI_DATASIZE_16BIT) && (hspi->hdmarx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))    || \\\r\n      ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) && ((hspi->hdmarx->Init.MemDataAlignment != DMA_MDATAALIGN_HALFWORD) && \\\r\n                                                     (hspi->hdmarx->Init.MemDataAlignment != DMA_MDATAALIGN_WORD))))\r\n  {\r\n    /* Restriction the DMA data received is not allowed in this mode */\r\n    errorcode = HAL_ERROR;\r\n    /* Unlock the process */\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Adjust XferCount according to DMA alignment / Data size */\r\n  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)\r\n  {\r\n    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n    {\r\n      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 3UL) >> 2UL;\r\n    }\r\n    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)\r\n    {\r\n      hspi->RxXferCount = (hspi->RxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->RxXferCount = (hspi->RxXferCount + (uint16_t) 3UL) >> 2UL;\r\n    }\r\n  }\r\n  else if (hspi->Init.DataSize <= SPI_DATASIZE_16BIT)\r\n  {\r\n    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->TxXferCount = (hspi->TxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_WORD)\r\n    {\r\n      hspi->RxXferCount = (hspi->RxXferCount + (uint16_t) 1UL) >> 1UL;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Adjustment done */\r\n  }\r\n\r\n  /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */\r\n  if (hspi->State == HAL_SPI_STATE_BUSY_RX)\r\n  {\r\n    /* Set the SPI Rx DMA Half transfer complete callback */\r\n    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;\r\n    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;\r\n  }\r\n  else\r\n  {\r\n    /* Set the SPI Tx/Rx DMA Half transfer complete callback */\r\n    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;\r\n    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;\r\n  }\r\n\r\n  /* Set the DMA error callback */\r\n  hspi->hdmarx->XferErrorCallback = SPI_DMAError;\r\n\r\n  /* Set the DMA AbortCallback */\r\n  hspi->hdmarx->XferAbortCallback = NULL;\r\n\r\n  /* Enable the Rx DMA Stream/Channel  */\r\n  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->RXDR, (uint32_t)hspi->pRxBuffPtr,\r\n                                 hspi->RxXferCount))\r\n  {\r\n    /* Update SPI error code */\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);\r\n\r\n    /* Unlock the process */\r\n    __HAL_UNLOCK(hspi);\r\n\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  /* Enable Rx DMA Request */\r\n  SET_BIT(hspi->Instance->CFG1, SPI_CFG1_RXDMAEN);\r\n\r\n  /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing\r\n  is performed in DMA reception complete callback  */\r\n  hspi->hdmatx->XferHalfCpltCallback = NULL;\r\n  hspi->hdmatx->XferCpltCallback     = NULL;\r\n  hspi->hdmatx->XferErrorCallback    = NULL;\r\n  hspi->hdmatx->XferAbortCallback    = NULL;\r\n\r\n  /* Enable the Tx DMA Stream/Channel  */\r\n  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->TXDR,\r\n                                 hspi->TxXferCount))\r\n  {\r\n    /* Update SPI error code */\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);\r\n\r\n    /* Unlock the process */\r\n    __HAL_UNLOCK(hspi);\r\n\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n    errorcode = HAL_ERROR;\r\n    return errorcode;\r\n  }\r\n\r\n  if (hspi->hdmatx->Init.Mode == DMA_CIRCULAR)\r\n  {\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, 0UL);\r\n  }\r\n  else\r\n  {\r\n    MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);\r\n  }\r\n\r\n  /* Enable Tx DMA Request */\r\n  SET_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN);\r\n\r\n  /* Enable the SPI Error Interrupt Bit */\r\n  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_OVR | SPI_IT_UDR | SPI_IT_FRE | SPI_IT_MODF));\r\n\r\n  /* Enable SPI peripheral */\r\n  __HAL_SPI_ENABLE(hspi);\r\n\r\n  if (hspi->Init.Mode == SPI_MODE_MASTER)\r\n  {\r\n    /* Master transfer start */\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);\r\n  }\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing transfer (blocking mode).\r\n  * @param  hspi SPI handle.\r\n  * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),\r\n  *         started in Interrupt or DMA mode.\r\n  * @note   This procedure performs following operations :\r\n  *          + Disable SPI Interrupts (depending of transfer direction)\r\n  *          + Disable the DMA transfer in the peripheral register (if enabled)\r\n  *          + Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)\r\n  *          + Set handle State to READY.\r\n  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)\r\n{\r\n  HAL_StatusTypeDef errorcode;\r\n\r\n  __IO uint32_t count;\r\n\r\n  /* Lock the process */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Set hspi->state to aborting to avoid any interaction */\r\n  hspi->State = HAL_SPI_STATE_ABORT;\r\n\r\n  /* Initialized local variable  */\r\n  errorcode = HAL_OK;\r\n  count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24UL / 1000UL);\r\n\r\n  /* If master communication on going, make sure current frame is done before closing the connection */\r\n  if (HAL_IS_BIT_SET(hspi->Instance->CR1, SPI_CR1_CSTART))\r\n  {\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSUSP);\r\n    do\r\n    {\r\n      count--;\r\n      if (count == 0UL)\r\n      {\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);\r\n        break;\r\n      }\r\n    } while (HAL_IS_BIT_SET(hspi->Instance->CR1, SPI_CR1_CSTART));\r\n  }\r\n\r\n  /* Disable the SPI DMA Tx request if enabled */\r\n  if (HAL_IS_BIT_SET(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN))\r\n  {\r\n    if (hspi->hdmatx != NULL)\r\n    {\r\n      /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */\r\n      hspi->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Abort DMA Tx Handle linked to SPI Peripheral */\r\n      if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(hspi->hdmatx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          hspi->ErrorCode = HAL_SPI_ERROR_ABORT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Disable the SPI DMA Rx request if enabled */\r\n  if (HAL_IS_BIT_SET(hspi->Instance->CFG1, SPI_CFG1_RXDMAEN))\r\n  {\r\n    if (hspi->hdmarx != NULL)\r\n    {\r\n      /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */\r\n      hspi->hdmarx->XferAbortCallback = NULL;\r\n\r\n      /* Abort DMA Rx Handle linked to SPI Peripheral */\r\n      if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(hspi->hdmarx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          hspi->ErrorCode = HAL_SPI_ERROR_ABORT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Proceed with abort procedure */\r\n  SPI_AbortTransfer(hspi);\r\n\r\n  /* Check error during Abort procedure */\r\n  if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)\r\n  {\r\n    /* return HAL_Error in case of error during Abort procedure */\r\n    errorcode = HAL_ERROR;\r\n  }\r\n  else\r\n  {\r\n    /* Reset errorCode */\r\n    hspi->ErrorCode = HAL_SPI_ERROR_NONE;\r\n  }\r\n\r\n  /* Unlock the process */\r\n  __HAL_UNLOCK(hspi);\r\n\r\n  /* Restore hspi->state to ready */\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing transfer (Interrupt mode).\r\n  * @param  hspi SPI handle.\r\n  * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),\r\n  *         started in Interrupt or DMA mode.\r\n  * @note   This procedure performs following operations :\r\n  *          + Disable SPI Interrupts (depending of transfer direction)\r\n  *          + Disable the DMA transfer in the peripheral register (if enabled)\r\n  *          + Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)\r\n  *          + Set handle State to READY\r\n  *          + At abort completion, call user abort complete callback.\r\n  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be\r\n  *         considered as completed only when user abort complete callback is executed (not when exiting function).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)\r\n{\r\n  HAL_StatusTypeDef errorcode;\r\n  __IO uint32_t count;\r\n  uint32_t dma_tx_abort_done = 1UL;\r\n  uint32_t dma_rx_abort_done = 1UL;\r\n\r\n  /* Set hspi->state to aborting to avoid any interaction */\r\n  hspi->State = HAL_SPI_STATE_ABORT;\r\n\r\n  /* Initialized local variable  */\r\n  errorcode = HAL_OK;\r\n  count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24UL / 1000UL);\r\n\r\n  /* If master communication on going, make sure current frame is done before closing the connection */\r\n  if (HAL_IS_BIT_SET(hspi->Instance->CR1, SPI_CR1_CSTART))\r\n  {\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSUSP);\r\n    do\r\n    {\r\n      count--;\r\n      if (count == 0UL)\r\n      {\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);\r\n        break;\r\n      }\r\n    } while (HAL_IS_BIT_SET(hspi->Instance->CR1, SPI_CR1_CSTART));\r\n  }\r\n\r\n  /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialized\r\n     before any call to DMA Abort functions */\r\n\r\n  if (hspi->hdmatx != NULL)\r\n  {\r\n    if (HAL_IS_BIT_SET(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN))\r\n    {\r\n      /* Set DMA Abort Complete callback if SPI DMA Tx request if enabled */\r\n      hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;\r\n\r\n      dma_tx_abort_done = 0UL;\r\n\r\n      /* Abort DMA Tx Handle linked to SPI Peripheral */\r\n      if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(hspi->hdmatx) == HAL_DMA_ERROR_NO_XFER)\r\n        {\r\n          dma_tx_abort_done = 1UL;\r\n          hspi->hdmatx->XferAbortCallback = NULL;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      hspi->hdmatx->XferAbortCallback = NULL;\r\n    }\r\n  }\r\n\r\n  if (hspi->hdmarx != NULL)\r\n  {\r\n    if (HAL_IS_BIT_SET(hspi->Instance->CFG1, SPI_CFG1_RXDMAEN))\r\n    {\r\n      /* Set DMA Abort Complete callback if SPI DMA Rx request if enabled */\r\n      hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;\r\n\r\n      dma_rx_abort_done = 0UL;\r\n\r\n      /* Abort DMA Rx Handle linked to SPI Peripheral */\r\n      if (HAL_DMA_Abort_IT(hspi->hdmarx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(hspi->hdmarx) == HAL_DMA_ERROR_NO_XFER)\r\n        {\r\n          dma_rx_abort_done = 1UL;\r\n          hspi->hdmarx->XferAbortCallback = NULL;\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      hspi->hdmarx->XferAbortCallback = NULL;\r\n    }\r\n  }\r\n\r\n  /* If no running DMA transfer, finish cleanup and call callbacks */\r\n  if ((dma_tx_abort_done == 1UL) && (dma_rx_abort_done == 1UL))\r\n  {\r\n    /* Proceed with abort procedure */\r\n    SPI_AbortTransfer(hspi);\r\n\r\n    /* Check error during Abort procedure */\r\n    if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)\r\n    {\r\n      /* return HAL_Error in case of error during Abort procedure */\r\n      errorcode = HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      /* Reset errorCode */\r\n      hspi->ErrorCode = HAL_SPI_ERROR_NONE;\r\n    }\r\n\r\n    /* Restore hspi->state to ready */\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n\r\n    /* Call user Abort complete callback */\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n    hspi->AbortCpltCallback(hspi);\r\n#else\r\n    HAL_SPI_AbortCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Pause the DMA Transfer.\r\n  *         This API is not supported, it is maintained for backward compatibility.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified SPI module.\r\n  * @retval HAL_ERROR\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Set error code to not supported */\r\n  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_NOT_SUPPORTED);\r\n\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Resume the DMA Transfer.\r\n  *         This API is not supported, it is maintained for backward compatibility.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified SPI module.\r\n  * @retval HAL_ERROR\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Set error code to not supported */\r\n  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_NOT_SUPPORTED);\r\n\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Stop the DMA Transfer.\r\n  *         This API is not supported, it is maintained for backward compatibility.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified SPI module.\r\n  * @retval HAL_ERROR\r\n  */\r\nHAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Set error code to not supported */\r\n  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_NOT_SUPPORTED);\r\n\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Handle SPI interrupt request.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified SPI module.\r\n  * @retval None\r\n  */\r\nvoid HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)\r\n{\r\n  uint32_t itsource = hspi->Instance->IER;\r\n  uint32_t itflag   = hspi->Instance->SR;\r\n  uint32_t trigger  = itsource & itflag;\r\n  uint32_t cfg1     = hspi->Instance->CFG1;\r\n  uint32_t handled  = 0UL;\r\n\r\n  HAL_SPI_StateTypeDef State = hspi->State;\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));\r\n#endif /* __GNUC__ */\r\n\r\n\r\n  /* SPI in mode Transmitter and Receiver ------------------------------------*/\r\n  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \\\r\n      HAL_IS_BIT_SET(trigger, SPI_FLAG_DXP))\r\n  {\r\n    hspi->TxISR(hspi);\r\n    hspi->RxISR(hspi);\r\n    handled = 1UL;\r\n  }\r\n\r\n  /* SPI in mode Receiver ----------------------------------------------------*/\r\n  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \\\r\n      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))\r\n  {\r\n    hspi->RxISR(hspi);\r\n    handled = 1UL;\r\n  }\r\n\r\n  /* SPI in mode Transmitter -------------------------------------------------*/\r\n  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \\\r\n      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))\r\n  {\r\n    hspi->TxISR(hspi);\r\n    handled = 1UL;\r\n  }\r\n\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n  /* SPI Reload  -------------------------------------------------*/\r\n  if (HAL_IS_BIT_SET(trigger, SPI_FLAG_TSERF))\r\n  {\r\n    hspi->Reload.Requested = 0UL;\r\n    __HAL_SPI_CLEAR_TSERFFLAG(hspi);\r\n  }\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n\r\n  if (handled != 0UL)\r\n  {\r\n    return;\r\n  }\r\n\r\n  /* SPI End Of Transfer: DMA or IT based transfer */\r\n  if (HAL_IS_BIT_SET(trigger, SPI_FLAG_EOT))\r\n  {\r\n    /* Clear EOT/TXTF/SUSP flag */\r\n    __HAL_SPI_CLEAR_EOTFLAG(hspi);\r\n    __HAL_SPI_CLEAR_TXTFFLAG(hspi);\r\n    __HAL_SPI_CLEAR_SUSPFLAG(hspi);\r\n\r\n    /* Disable EOT interrupt */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_EOT);\r\n\r\n    /* DMA Normal Mode */\r\n    if (HAL_IS_BIT_CLR(cfg1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN) ||\r\n        ((State != HAL_SPI_STATE_BUSY_RX) && (hspi->hdmatx->Init.Mode == DMA_NORMAL)) ||\r\n        ((State != HAL_SPI_STATE_BUSY_TX) && (hspi->hdmarx->Init.Mode == DMA_NORMAL)))\r\n    {\r\n      /* For the IT based receive extra polling maybe required for last packet */\r\n      if (HAL_IS_BIT_CLR(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))\r\n      {\r\n        /* Pooling remaining data */\r\n        while (hspi->RxXferCount != 0UL)\r\n        {\r\n          /* Receive data in 32 Bit mode */\r\n          if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)\r\n          {\r\n            *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);\r\n            hspi->pRxBuffPtr += sizeof(uint32_t);\r\n          }\r\n          /* Receive data in 16 Bit mode */\r\n          else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)\r\n          {\r\n#if defined (__GNUC__)\r\n            *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;\r\n#else\r\n            *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);\r\n#endif /* __GNUC__ */\r\n            hspi->pRxBuffPtr += sizeof(uint16_t);\r\n          }\r\n          /* Receive data in 8 Bit mode */\r\n          else\r\n          {\r\n            *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);\r\n            hspi->pRxBuffPtr += sizeof(uint8_t);\r\n          }\r\n\r\n          hspi->RxXferCount--;\r\n        }\r\n      }\r\n\r\n      /* Call SPI Standard close procedure */\r\n      SPI_CloseTransfer(hspi);\r\n\r\n      hspi->State = HAL_SPI_STATE_READY;\r\n      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)\r\n      {\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n        hspi->ErrorCallback(hspi);\r\n#else\r\n        HAL_SPI_ErrorCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n        return;\r\n      }\r\n    }\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n    /* Call appropriate user callback */\r\n    if (State == HAL_SPI_STATE_BUSY_TX_RX)\r\n    {\r\n      hspi->TxRxCpltCallback(hspi);\r\n    }\r\n    else if (State == HAL_SPI_STATE_BUSY_RX)\r\n    {\r\n      hspi->RxCpltCallback(hspi);\r\n    }\r\n    else if (State == HAL_SPI_STATE_BUSY_TX)\r\n    {\r\n      hspi->TxCpltCallback(hspi);\r\n    }\r\n#else\r\n    /* Call appropriate user callback */\r\n    if (State == HAL_SPI_STATE_BUSY_TX_RX)\r\n    {\r\n      HAL_SPI_TxRxCpltCallback(hspi);\r\n    }\r\n    else if (State == HAL_SPI_STATE_BUSY_RX)\r\n    {\r\n      HAL_SPI_RxCpltCallback(hspi);\r\n    }\r\n    else if (State == HAL_SPI_STATE_BUSY_TX)\r\n    {\r\n      HAL_SPI_TxCpltCallback(hspi);\r\n    }\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n    else\r\n    {\r\n      /* End of the appropriate call */\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  if (HAL_IS_BIT_SET(itflag, SPI_FLAG_SUSP) && HAL_IS_BIT_SET(itsource, SPI_FLAG_EOT))\r\n  {\r\n    /* Abort on going, clear SUSP flag to avoid infinite looping */\r\n    __HAL_SPI_CLEAR_SUSPFLAG(hspi);\r\n\r\n    return;\r\n  }\r\n\r\n  /* SPI in Error Treatment --------------------------------------------------*/\r\n  if ((trigger & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE | SPI_FLAG_UDR)) != 0UL)\r\n  {\r\n    /* SPI Overrun error interrupt occurred ----------------------------------*/\r\n    if ((trigger & SPI_FLAG_OVR) != 0UL)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);\r\n      __HAL_SPI_CLEAR_OVRFLAG(hspi);\r\n    }\r\n\r\n    /* SPI Mode Fault error interrupt occurred -------------------------------*/\r\n    if ((trigger & SPI_FLAG_MODF) != 0UL)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);\r\n      __HAL_SPI_CLEAR_MODFFLAG(hspi);\r\n    }\r\n\r\n    /* SPI Frame error interrupt occurred ------------------------------------*/\r\n    if ((trigger & SPI_FLAG_FRE) != 0UL)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);\r\n      __HAL_SPI_CLEAR_FREFLAG(hspi);\r\n    }\r\n\r\n    /* SPI Underrun error interrupt occurred ------------------------------------*/\r\n    if ((trigger & SPI_FLAG_UDR) != 0UL)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);\r\n      __HAL_SPI_CLEAR_UDRFLAG(hspi);\r\n    }\r\n\r\n    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)\r\n    {\r\n      /* Disable SPI peripheral */\r\n      __HAL_SPI_DISABLE(hspi);\r\n\r\n      /* Disable all interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_RXP | SPI_IT_TXP | SPI_IT_MODF |\r\n                                  SPI_IT_OVR | SPI_IT_FRE | SPI_IT_UDR));\r\n\r\n      /* Disable the SPI DMA requests if enabled */\r\n      if (HAL_IS_BIT_SET(cfg1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))\r\n      {\r\n        /* Disable the SPI DMA requests */\r\n        CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);\r\n\r\n        /* Abort the SPI DMA Rx channel */\r\n        if (hspi->hdmarx != NULL)\r\n        {\r\n          /* Set the SPI DMA Abort callback :\r\n          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */\r\n          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;\r\n          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))\r\n          {\r\n            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);\r\n          }\r\n        }\r\n        /* Abort the SPI DMA Tx channel */\r\n        if (hspi->hdmatx != NULL)\r\n        {\r\n          /* Set the SPI DMA Abort callback :\r\n          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */\r\n          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;\r\n          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))\r\n          {\r\n            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Restore hspi->State to Ready */\r\n        hspi->State = HAL_SPI_STATE_READY;\r\n\r\n        /* Call user error callback */\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n        hspi->ErrorCallback(hspi);\r\n#else\r\n        HAL_SPI_ErrorCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Tx Transfer completed callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_TxCpltCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief Rx Transfer completed callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_RxCpltCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief Tx and Rx Transfer completed callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_TxRxCpltCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief Tx Half Transfer completed callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_TxHalfCpltCallback should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief Rx Half Transfer completed callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief Tx and Rx Half Transfer callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief SPI error callback.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_ErrorCallback should be implemented in the user file\r\n   */\r\n  /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes\r\n            and user can use HAL_SPI_GetError() API to check the latest error occurred\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  SPI Abort Complete callback.\r\n  * @param  hspi SPI handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(hspi);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_SPI_AbortCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions\r\n  * @brief   SPI control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral State and Errors functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the SPI.\r\n     (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral\r\n     (+) HAL_SPI_GetError() check in run-time Errors occurring during communication\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the SPI handle state.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval SPI state\r\n  */\r\nHAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Return SPI handle state */\r\n  return hspi->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the SPI error code.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval SPI error code in bitmap format\r\n  */\r\nuint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Return SPI ErrorCode */\r\n  return hspi->ErrorCode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup SPI_Private_Functions\r\n  * @brief   Private functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief DMA SPI transmit process complete callback.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hspi->State != HAL_SPI_STATE_ABORT)\r\n  {\r\n    if (hspi->hdmatx->Init.Mode == DMA_CIRCULAR)\r\n    {\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n      hspi->TxCpltCallback(hspi);\r\n#else\r\n      HAL_SPI_TxCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      /* Enable EOT interrupt */\r\n      __HAL_SPI_ENABLE_IT(hspi, SPI_IT_EOT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA SPI receive process complete callback.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hspi->State != HAL_SPI_STATE_ABORT)\r\n  {\r\n    if (hspi->hdmarx->Init.Mode == DMA_CIRCULAR)\r\n    {\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n      hspi->RxCpltCallback(hspi);\r\n#else\r\n      HAL_SPI_RxCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      /* Enable EOT interrupt */\r\n      __HAL_SPI_ENABLE_IT(hspi, SPI_IT_EOT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI transmit receive process complete callback.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hspi->State != HAL_SPI_STATE_ABORT)\r\n  {\r\n    if (hspi->hdmatx->Init.Mode == DMA_CIRCULAR)\r\n    {\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n      hspi->TxRxCpltCallback(hspi);\r\n#else\r\n      HAL_SPI_TxRxCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n    }\r\n    else\r\n    {\r\n      /* Enable EOT interrupt */\r\n      __HAL_SPI_ENABLE_IT(hspi, SPI_IT_EOT);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI half transmit process complete callback.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  hspi->TxHalfCpltCallback(hspi);\r\n#else\r\n  HAL_SPI_TxHalfCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI half receive process complete callback\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  hspi->RxHalfCpltCallback(hspi);\r\n#else\r\n  HAL_SPI_RxHalfCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI half transmit receive process complete callback.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  hspi->TxRxHalfCpltCallback(hspi);\r\n#else\r\n  HAL_SPI_TxRxHalfCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI communication error callback.\r\n  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified DMA module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* if DMA error is FIFO error ignore it */\r\n  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)\r\n  {\r\n    /* Call SPI standard close procedure */\r\n    SPI_CloseTransfer(hspi);\r\n\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n    hspi->ErrorCallback(hspi);\r\n#else\r\n    HAL_SPI_ErrorCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI communication abort callback, when initiated by HAL services on Error\r\n  *         (To be called at end of DMA Abort procedure following error occurrence).\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n  hspi->RxXferCount = (uint16_t) 0UL;\r\n  hspi->TxXferCount = (uint16_t) 0UL;\r\n\r\n  /* Restore hspi->State to Ready */\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  hspi->ErrorCallback(hspi);\r\n#else\r\n  HAL_SPI_ErrorCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI Tx communication abort callback, when initiated by user\r\n  *         (To be called at end of DMA Tx Abort procedure following user abort request).\r\n  * @note   When this callback is executed, User Abort complete call back is called only if no\r\n  *         Abort still ongoing for Rx DMA Handle.\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  hspi->hdmatx->XferAbortCallback = NULL;\r\n\r\n  /* Check if an Abort process is still ongoing */\r\n  if (hspi->hdmarx != NULL)\r\n  {\r\n    if (hspi->hdmarx->XferAbortCallback != NULL)\r\n    {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* Call the Abort procedure */\r\n  SPI_AbortTransfer(hspi);\r\n\r\n  /* Restore hspi->State to Ready */\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n  /* Call user Abort complete callback */\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  hspi->AbortCpltCallback(hspi);\r\n#else\r\n  HAL_SPI_AbortCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA SPI Rx communication abort callback, when initiated by user\r\n  *         (To be called at end of DMA Rx Abort procedure following user abort request).\r\n  * @note   When this callback is executed, User Abort complete call back is called only if no\r\n  *         Abort still ongoing for Tx DMA Handle.\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)\r\n{\r\n  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  hspi->hdmarx->XferAbortCallback = NULL;\r\n\r\n  /* Check if an Abort process is still ongoing */\r\n  if (hspi->hdmatx != NULL)\r\n  {\r\n    if (hspi->hdmatx->XferAbortCallback != NULL)\r\n    {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* Call the Abort procedure */\r\n  SPI_AbortTransfer(hspi);\r\n\r\n  /* Restore hspi->State to Ready */\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n\r\n  /* Call user Abort complete callback */\r\n#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)\r\n  hspi->AbortCpltCallback(hspi);\r\n#else\r\n  HAL_SPI_AbortCpltCallback(hspi);\r\n#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  Manage the receive 8-bit in Interrupt context.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_RxISR_8BIT(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Receive data in 8 Bit mode */\r\n  *((uint8_t *)hspi->pRxBuffPtr) = (*(__IO uint8_t *)&hspi->Instance->RXDR);\r\n  hspi->pRxBuffPtr += sizeof(uint8_t);\r\n  hspi->RxXferCount--;\r\n\r\n  /* Disable IT if no more data excepted */\r\n  if (hspi->RxXferCount == 0UL)\r\n  {\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n    /* Check if there is any request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      hspi->RxXferSize  = hspi->Reload.RxXferSize;\r\n      hspi->RxXferCount = hspi->Reload.RxXferSize;\r\n      hspi->pRxBuffPtr  = hspi->Reload.pRxBuffPtr;\r\n    }\r\n    else\r\n    {\r\n      /* Disable RXP interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXP);\r\n    }\r\n#else\r\n    /* Disable RXP interrupts */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXP);\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Manage the 16-bit receive in Interrupt context.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_RxISR_16BIT(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Receive data in 16 Bit mode */\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));\r\n\r\n  *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;\r\n#else\r\n  *((uint16_t *)hspi->pRxBuffPtr) = (*(__IO uint16_t *)&hspi->Instance->RXDR);\r\n#endif /* __GNUC__ */\r\n  hspi->pRxBuffPtr += sizeof(uint16_t);\r\n  hspi->RxXferCount--;\r\n\r\n  /* Disable IT if no more data excepted */\r\n  if (hspi->RxXferCount == 0UL)\r\n  {\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n    /* Check if there is any request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      hspi->RxXferSize  = hspi->Reload.RxXferSize;\r\n      hspi->RxXferCount = hspi->Reload.RxXferSize;\r\n      hspi->pRxBuffPtr  = hspi->Reload.pRxBuffPtr;\r\n    }\r\n    else\r\n    {\r\n      /* Disable RXP interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXP);\r\n    }\r\n#else\r\n    /* Disable RXP interrupts */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXP);\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Manage the 32-bit receive in Interrupt context.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_RxISR_32BIT(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Receive data in 32 Bit mode */\r\n  *((uint32_t *)hspi->pRxBuffPtr) = (*(__IO uint32_t *)&hspi->Instance->RXDR);\r\n  hspi->pRxBuffPtr += sizeof(uint32_t);\r\n  hspi->RxXferCount--;\r\n\r\n  /* Disable IT if no more data excepted */\r\n  if (hspi->RxXferCount == 0UL)\r\n  {\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n    /* Check if there is any request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      hspi->RxXferSize  = hspi->Reload.RxXferSize;\r\n      hspi->RxXferCount = hspi->Reload.RxXferSize;\r\n      hspi->pRxBuffPtr  = hspi->Reload.pRxBuffPtr;\r\n    }\r\n    else\r\n    {\r\n      /* Disable RXP interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXP);\r\n    }\r\n#else\r\n    /* Disable RXP interrupts */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXP);\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n  }\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Handle the data 8-bit transmit in Interrupt mode.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_TxISR_8BIT(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Transmit data in 8 Bit mode */\r\n  *(__IO uint8_t *)&hspi->Instance->TXDR = *((uint8_t *)hspi->pTxBuffPtr);\r\n  hspi->pTxBuffPtr += sizeof(uint8_t);\r\n  hspi->TxXferCount--;\r\n\r\n  /* Disable IT if no more data excepted */\r\n  if (hspi->TxXferCount == 0UL)\r\n  {\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n    /* Check if there is any request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      hspi->TxXferSize  = hspi->Reload.TxXferSize;\r\n      hspi->TxXferCount = hspi->Reload.TxXferSize;\r\n      hspi->pTxBuffPtr  = hspi->Reload.pTxBuffPtr;\r\n    }\r\n    else\r\n    {\r\n      /* Disable TXP interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXP);\r\n    }\r\n#else\r\n    /* Disable TXP interrupts */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXP);\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Handle the data 16-bit transmit in Interrupt mode.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_TxISR_16BIT(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Transmit data in 16 Bit mode */\r\n#if defined (__GNUC__)\r\n  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));\r\n\r\n  *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);\r\n#else\r\n  *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);\r\n#endif /* __GNUC__ */\r\n  hspi->pTxBuffPtr += sizeof(uint16_t);\r\n  hspi->TxXferCount--;\r\n\r\n  /* Disable IT if no more data excepted */\r\n  if (hspi->TxXferCount == 0UL)\r\n  {\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n    /* Check if there is any request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      hspi->TxXferSize  = hspi->Reload.TxXferSize;\r\n      hspi->TxXferCount = hspi->Reload.TxXferSize;\r\n      hspi->pTxBuffPtr  = hspi->Reload.pTxBuffPtr;\r\n    }\r\n    else\r\n    {\r\n      /* Disable TXP interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXP);\r\n    }\r\n#else\r\n    /* Disable TXP interrupts */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXP);\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Handle the data 32-bit transmit in Interrupt mode.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_TxISR_32BIT(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Transmit data in 32 Bit mode */\r\n  *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);\r\n  hspi->pTxBuffPtr += sizeof(uint32_t);\r\n  hspi->TxXferCount--;\r\n\r\n  /* Disable IT if no more data excepted */\r\n  if (hspi->TxXferCount == 0UL)\r\n  {\r\n#if defined(USE_SPI_RELOAD_TRANSFER)\r\n    /* Check if there is any request to reload */\r\n    if (hspi->Reload.Requested == 1UL)\r\n    {\r\n      hspi->TxXferSize  = hspi->Reload.TxXferSize;\r\n      hspi->TxXferCount = hspi->Reload.TxXferSize;\r\n      hspi->pTxBuffPtr  = hspi->Reload.pTxBuffPtr;\r\n    }\r\n    else\r\n    {\r\n      /* Disable TXP interrupts */\r\n      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXP);\r\n    }\r\n#else\r\n    /* Disable TXP interrupts */\r\n    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXP);\r\n#endif /* USE_SPI_RELOAD_TRANSFER */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Abort Transfer and clear flags.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nstatic void SPI_AbortTransfer(SPI_HandleTypeDef *hspi)\r\n{\r\n  /* Disable SPI peripheral */\r\n  __HAL_SPI_DISABLE(hspi);\r\n\r\n  /* Disable ITs */\r\n  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \\\r\n                              SPI_IT_FRE | SPI_IT_MODF));\r\n\r\n  /* Clear the Status flags in the SR register */\r\n  __HAL_SPI_CLEAR_EOTFLAG(hspi);\r\n  __HAL_SPI_CLEAR_TXTFFLAG(hspi);\r\n\r\n  /* Disable Tx DMA Request */\r\n  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);\r\n\r\n  /* Clear the Error flags in the SR register */\r\n  __HAL_SPI_CLEAR_OVRFLAG(hspi);\r\n  __HAL_SPI_CLEAR_UDRFLAG(hspi);\r\n  __HAL_SPI_CLEAR_FREFLAG(hspi);\r\n  __HAL_SPI_CLEAR_MODFFLAG(hspi);\r\n  __HAL_SPI_CLEAR_SUSPFLAG(hspi);\r\n\r\n#if (USE_SPI_CRC != 0U)\r\n  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);\r\n#endif /* USE_SPI_CRC */\r\n\r\n  hspi->TxXferCount = (uint16_t)0UL;\r\n  hspi->RxXferCount = (uint16_t)0UL;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Close Transfer and clear flags.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval HAL_ERROR: if any error detected\r\n  *         HAL_OK: if nothing detected\r\n  */\r\nstatic void SPI_CloseTransfer(SPI_HandleTypeDef *hspi)\r\n{\r\n  uint32_t itflag = hspi->Instance->SR;\r\n\r\n  __HAL_SPI_CLEAR_EOTFLAG(hspi);\r\n  __HAL_SPI_CLEAR_TXTFFLAG(hspi);\r\n\r\n  /* Disable SPI peripheral */\r\n  __HAL_SPI_DISABLE(hspi);\r\n\r\n  /* Disable ITs */\r\n  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \\\r\n                              SPI_IT_FRE | SPI_IT_MODF));\r\n\r\n  /* Disable Tx DMA Request */\r\n  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);\r\n\r\n  /* Report UnderRun error for non RX Only communication */\r\n  if (hspi->State != HAL_SPI_STATE_BUSY_RX)\r\n  {\r\n    if ((itflag & SPI_FLAG_UDR) != 0UL)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);\r\n      __HAL_SPI_CLEAR_UDRFLAG(hspi);\r\n    }\r\n  }\r\n\r\n  /* Report OverRun error for non TX Only communication */\r\n  if (hspi->State != HAL_SPI_STATE_BUSY_TX)\r\n  {\r\n    if ((itflag & SPI_FLAG_OVR) != 0UL)\r\n    {\r\n      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);\r\n      __HAL_SPI_CLEAR_OVRFLAG(hspi);\r\n    }\r\n\r\n#if (USE_SPI_CRC != 0UL)\r\n    /* Check if CRC error occurred */\r\n    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)\r\n    {\r\n      if ((itflag & SPI_FLAG_CRCERR) != 0UL)\r\n      {\r\n        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);\r\n        __HAL_SPI_CLEAR_CRCERRFLAG(hspi);\r\n      }\r\n    }\r\n#endif /* USE_SPI_CRC */\r\n  }\r\n\r\n  /* SPI Mode Fault error interrupt occurred -------------------------------*/\r\n  if ((itflag & SPI_FLAG_MODF) != 0UL)\r\n  {\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);\r\n    __HAL_SPI_CLEAR_MODFFLAG(hspi);\r\n  }\r\n\r\n  /* SPI Frame error interrupt occurred ------------------------------------*/\r\n  if ((itflag & SPI_FLAG_FRE) != 0UL)\r\n  {\r\n    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);\r\n    __HAL_SPI_CLEAR_FREFLAG(hspi);\r\n  }\r\n\r\n  hspi->TxXferCount = (uint16_t)0UL;\r\n  hspi->RxXferCount = (uint16_t)0UL;\r\n}\r\n\r\n/**\r\n  * @brief Handle SPI Communication Timeout.\r\n  * @param hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *              the configuration information for SPI module.\r\n  * @param Flag: SPI flag to check\r\n  * @param Status: flag state to check\r\n  * @param Timeout: Timeout duration\r\n  * @param Tickstart: Tick start value\r\n  * @retval HAL status\r\n  */\r\nstatic HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status,\r\n                                                    uint32_t Tickstart, uint32_t Timeout)\r\n{\r\n  /* Wait until flag is set */\r\n  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)\r\n  {\r\n    /* Check for the Timeout */\r\n    if ((((HAL_GetTick() - Tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Compute configured packet size from fifo perspective.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval Packet size occupied in the fifo\r\n  */\r\nstatic uint32_t SPI_GetPacketSize(SPI_HandleTypeDef *hspi)\r\n{\r\n  uint32_t fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;\r\n  uint32_t data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;\r\n\r\n  /* Convert data size to Byte */\r\n  data_size = (data_size + 7UL) / 8UL;\r\n\r\n  return data_size * fifo_threashold;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_SPI_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_spi_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_spi_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended SPI HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          SPI peripheral extended functionalities :\r\n  *           + IO operation functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup SPIEx SPIEx\r\n  * @brief SPI Extended HAL module driver\r\n  * @{\r\n  */\r\n#ifdef HAL_SPI_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private defines -----------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup SPIEx_Exported_Functions SPIEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup SPIEx_Exported_Functions_Group1 IO operation functions\r\n  *  @brief   Data transfers functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n [..]\r\n    This subsection provides a set of extended functions to manage the SPI\r\n    data transfers.\r\n\r\n    (#) SPIEx function:\r\n        (++) HAL_SPIEx_FlushRxFifo()\r\n        (++) HAL_SPIEx_FlushRxFifo()\r\n        (++) HAL_SPIEx_EnableLockConfiguration()\r\n        (++) HAL_SPIEx_ConfigureUnderrun()\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Flush the RX fifo.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified SPI module.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_SPIEx_FlushRxFifo(SPI_HandleTypeDef *hspi)\r\n{\r\n  uint8_t  count  = 0;\r\n  uint32_t itflag = hspi->Instance->SR;\r\n  __IO uint32_t tmpreg;\r\n\r\n  while (((hspi->Instance->SR & SPI_FLAG_FRLVL) !=  SPI_RX_FIFO_0PACKET) || ((itflag & SPI_FLAG_RXWNE) !=  0UL))\r\n  {\r\n    count += (uint8_t)4UL;\r\n    tmpreg = hspi->Instance->RXDR;\r\n    UNUSED(tmpreg); /* To avoid GCC warning */\r\n\r\n    if (IS_SPI_HIGHEND_INSTANCE(hspi->Instance))\r\n    {\r\n      if (count > SPI_HIGHEND_FIFO_SIZE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      if (count > SPI_LOWEND_FIFO_SIZE)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Enable the Lock for the AF configuration of associated IOs\r\n  *         and write protect the Content of Configuration register 2\r\n  *         when SPI is enabled\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_SPIEx_EnableLockConfiguration(SPI_HandleTypeDef *hspi)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(hspi);\r\n\r\n  if (hspi->State != HAL_SPI_STATE_READY)\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Check if the SPI is disabled to edit IOLOCK bit */\r\n  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)\r\n  {\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_IOLOCK);\r\n  }\r\n  else\r\n  {\r\n    /* Disable SPI peripheral */\r\n    __HAL_SPI_DISABLE(hspi);\r\n\r\n    SET_BIT(hspi->Instance->CR1, SPI_CR1_IOLOCK);\r\n\r\n    /* Enable SPI peripheral */\r\n    __HAL_SPI_ENABLE(hspi);\r\n  }\r\n\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the UNDERRUN condition and behavior of slave transmitter.\r\n  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains\r\n  *               the configuration information for SPI module.\r\n  * @param  UnderrunDetection : Detection of underrun condition at slave transmitter\r\n  *                             This parameter can be a value of @ref SPI_Underrun_Detection.\r\n  * @param  UnderrunBehaviour : Behavior of slave transmitter at underrun condition\r\n  *                             This parameter can be a value of @ref SPI_Underrun_Behaviour.\r\n  * @retval None\r\n  */\r\nHAL_StatusTypeDef HAL_SPIEx_ConfigureUnderrun(SPI_HandleTypeDef *hspi, uint32_t UnderrunDetection,\r\n                                              uint32_t UnderrunBehaviour)\r\n{\r\n  HAL_StatusTypeDef errorcode = HAL_OK;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(hspi);\r\n\r\n  /* Check State and Insure that Underrun configuration is managed only by Salve */\r\n  if ((hspi->State != HAL_SPI_STATE_READY) || (hspi->Init.Mode != SPI_MODE_SLAVE))\r\n  {\r\n    errorcode = HAL_BUSY;\r\n    hspi->State = HAL_SPI_STATE_READY;\r\n    /* Process Unlocked */\r\n    __HAL_UNLOCK(hspi);\r\n    return errorcode;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_SPI_UNDERRUN_DETECTION(UnderrunDetection));\r\n  assert_param(IS_SPI_UNDERRUN_BEHAVIOUR(UnderrunBehaviour));\r\n\r\n  /* Check if the SPI is disabled to edit CFG1 register */\r\n  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)\r\n  {\r\n    /* Configure Underrun fields */\r\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, UnderrunDetection);\r\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, UnderrunBehaviour);\r\n  }\r\n  else\r\n  {\r\n    /* Disable SPI peripheral */\r\n    __HAL_SPI_DISABLE(hspi);\r\n\r\n    /* Configure Underrun fields */\r\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, UnderrunDetection);\r\n    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, UnderrunBehaviour);\r\n\r\n    /* Enable SPI peripheral */\r\n    __HAL_SPI_ENABLE(hspi);\r\n  }\r\n\r\n\r\n  hspi->State = HAL_SPI_STATE_READY;\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(hspi);\r\n  return errorcode;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_SPI_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_tim.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_tim.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Timer (TIM) peripheral:\r\n  *           + TIM Time Base Initialization\r\n  *           + TIM Time Base Start\r\n  *           + TIM Time Base Start Interruption\r\n  *           + TIM Time Base Start DMA\r\n  *           + TIM Output Compare/PWM Initialization\r\n  *           + TIM Output Compare/PWM Channel Configuration\r\n  *           + TIM Output Compare/PWM  Start\r\n  *           + TIM Output Compare/PWM  Start Interruption\r\n  *           + TIM Output Compare/PWM Start DMA\r\n  *           + TIM Input Capture Initialization\r\n  *           + TIM Input Capture Channel Configuration\r\n  *           + TIM Input Capture Start\r\n  *           + TIM Input Capture Start Interruption\r\n  *           + TIM Input Capture Start DMA\r\n  *           + TIM One Pulse Initialization\r\n  *           + TIM One Pulse Channel Configuration\r\n  *           + TIM One Pulse Start\r\n  *           + TIM Encoder Interface Initialization\r\n  *           + TIM Encoder Interface Start\r\n  *           + TIM Encoder Interface Start Interruption\r\n  *           + TIM Encoder Interface Start DMA\r\n  *           + Commutation Event configuration with Interruption and DMA\r\n  *           + TIM OCRef clear configuration\r\n  *           + TIM External Clock configuration\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### TIMER Generic features #####\r\n  ==============================================================================\r\n  [..] The Timer features include:\r\n       (#) 16-bit up, down, up/down auto-reload counter.\r\n       (#) 16-bit programmable prescaler allowing dividing (also on the fly) the\r\n           counter clock frequency either by any factor between 1 and 65536.\r\n       (#) Up to 4 independent channels for:\r\n           (++) Input Capture\r\n           (++) Output Compare\r\n           (++) PWM generation (Edge and Center-aligned Mode)\r\n           (++) One-pulse mode output\r\n       (#) Synchronization circuit to control the timer with external signals and to interconnect\r\n            several timers together.\r\n       (#) Supports incremental encoder for positioning purposes\r\n\r\n            ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n     (#) Initialize the TIM low level resources by implementing the following functions\r\n         depending on the selected feature:\r\n           (++) Time Base : HAL_TIM_Base_MspInit()\r\n           (++) Input Capture : HAL_TIM_IC_MspInit()\r\n           (++) Output Compare : HAL_TIM_OC_MspInit()\r\n           (++) PWM generation : HAL_TIM_PWM_MspInit()\r\n           (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()\r\n           (++) Encoder mode output : HAL_TIM_Encoder_MspInit()\r\n\r\n     (#) Initialize the TIM low level resources :\r\n        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();\r\n        (##) TIM pins configuration\r\n            (+++) Enable the clock for the TIM GPIOs using the following function:\r\n             __HAL_RCC_GPIOx_CLK_ENABLE();\r\n            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();\r\n\r\n     (#) The external Clock can be configured, if needed (the default clock is the\r\n         internal clock from the APBx), using the following function:\r\n         HAL_TIM_ConfigClockSource, the clock configuration should be done before\r\n         any start function.\r\n\r\n     (#) Configure the TIM in the desired functioning mode using one of the\r\n       Initialization function of this driver:\r\n       (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base\r\n       (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an\r\n            Output Compare signal.\r\n       (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a\r\n            PWM signal.\r\n       (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an\r\n            external signal.\r\n       (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer\r\n            in One Pulse Mode.\r\n       (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.\r\n\r\n     (#) Activate the TIM peripheral using one of the start functions depending from the feature used:\r\n           (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()\r\n           (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()\r\n           (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()\r\n           (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()\r\n           (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()\r\n           (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().\r\n\r\n     (#) The DMA Burst is managed with the two following functions:\r\n         HAL_TIM_DMABurst_WriteStart()\r\n         HAL_TIM_DMABurst_ReadStart()\r\n\r\n    *** Callback registration ***\r\n  =============================================\r\n\r\n  [..]\r\n  The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1\r\n  allows the user to configure dynamically the driver callbacks.\r\n\r\n  [..]\r\n  Use Function HAL_TIM_RegisterCallback() to register a callback.\r\n  HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,\r\n  the Callback ID and a pointer to the user callback function.\r\n\r\n  [..]\r\n  Use function HAL_TIM_UnRegisterCallback() to reset a callback to the default\r\n  weak function.\r\n  HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,\r\n  and the Callback ID.\r\n\r\n  [..]\r\n  These functions allow to register/unregister following callbacks:\r\n    (+) Base_MspInitCallback              : TIM Base Msp Init Callback.\r\n    (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.\r\n    (+) IC_MspInitCallback                : TIM IC Msp Init Callback.\r\n    (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.\r\n    (+) OC_MspInitCallback                : TIM OC Msp Init Callback.\r\n    (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.\r\n    (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.\r\n    (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.\r\n    (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.\r\n    (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.\r\n    (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.\r\n    (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.\r\n    (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.\r\n    (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.\r\n    (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.\r\n    (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.\r\n    (+) TriggerCallback                   : TIM Trigger Callback.\r\n    (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.\r\n    (+) IC_CaptureCallback                : TIM Input Capture Callback.\r\n    (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.\r\n    (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.\r\n    (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.\r\n    (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.\r\n    (+) ErrorCallback                     : TIM Error Callback.\r\n    (+) CommutationCallback               : TIM Commutation Callback.\r\n    (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.\r\n    (+) BreakCallback                     : TIM Break Callback.\r\n    (+) Break2Callback                    : TIM Break2 Callback.\r\n\r\n  [..]\r\nBy default, after the Init and when the state is HAL_TIM_STATE_RESET\r\nall interrupt callbacks are set to the corresponding weak functions:\r\n  examples HAL_TIM_TriggerCallback(), HAL_TIM_ErrorCallback().\r\n\r\n  [..]\r\n  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak\r\n  functionalities in the Init / DeInit only when these callbacks are null\r\n  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit\r\n    keep and use the user MspInit / MspDeInit callbacks(registered beforehand)\r\n\r\n  [..]\r\n    Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.\r\n    Exception done MspInit / MspDeInit that can be registered / unregistered\r\n    in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,\r\n    thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.\r\n  In that case first register the MspInit/MspDeInit user callbacks\r\n      using HAL_TIM_RegisterCallback() before calling DeInit or Init function.\r\n\r\n  [..]\r\n      When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or\r\n      not defined, the callback registration feature is not available and all callbacks\r\n      are set to the corresponding weak functions.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIM TIM\r\n  * @brief TIM HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_TIM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup TIM_Private_Functions\r\n  * @{\r\n  */\r\nstatic void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);\r\nstatic void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);\r\nstatic void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);\r\nstatic void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter);\r\nstatic void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);\r\nstatic void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,\r\n                                                  TIM_SlaveConfigTypeDef *sSlaveConfig);\r\n/**\r\n  * @}\r\n  */\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup TIM_Exported_Functions TIM Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions\r\n  *  @brief    Time Base functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Time Base functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM base.\r\n    (+) De-initialize the TIM base.\r\n    (+) Start the Time Base.\r\n    (+) Stop the Time Base.\r\n    (+) Start the Time Base and enable interrupt.\r\n    (+) Stop the Time Base and disable interrupt.\r\n    (+) Start the Time Base and enable DMA transfer.\r\n    (+) Stop the Time Base and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Time base Unit according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->Base_MspInitCallback == NULL)\r\n    {\r\n      htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->Base_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    HAL_TIM_Base_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Set the Time Base configuration */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Base peripheral\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->Base_MspDeInitCallback == NULL)\r\n  {\r\n    htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->Base_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_Base_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Base MSP.\r\n  * @param  htim TIM Base handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Base_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Base MSP.\r\n  * @param  htim TIM Base handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Base_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM state */\r\n  if (htim->State != HAL_TIM_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation in interrupt mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM state */\r\n  if (htim->State != HAL_TIM_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Enable the TIM Update interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation in interrupt mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the TIM Update interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Base generation in DMA mode.\r\n  * @param  htim TIM Base handle\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM state */\r\n  if (htim->State == HAL_TIM_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->State = HAL_TIM_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the DMA Period elapsed callbacks */\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n  /* Enable the DMA stream */\r\n  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR,\r\n                       Length) != HAL_OK)\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the TIM Update DMA request */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Base generation in DMA mode.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the TIM Update DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);\r\n\r\n  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions\r\n  *  @brief    TIM Output Compare functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                  ##### TIM Output Compare functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM Output Compare.\r\n    (+) De-initialize the TIM Output Compare.\r\n    (+) Start the TIM Output Compare.\r\n    (+) Stop the TIM Output Compare.\r\n    (+) Start the TIM Output Compare and enable interrupt.\r\n    (+) Stop the TIM Output Compare and disable interrupt.\r\n    (+) Start the TIM Output Compare and enable DMA transfer.\r\n    (+) Stop the TIM Output Compare and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Output Compare according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->OC_MspInitCallback == NULL)\r\n    {\r\n      htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->OC_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_OC_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the Output Compare */\r\n  TIM_Base_SetConfig(htim->Instance,  &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->OC_MspDeInitCallback == NULL)\r\n  {\r\n    htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->OC_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_OC_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Output Compare MSP.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Output Compare MSP.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Output compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Output compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in interrupt mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in DMA mode.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Output compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions\r\n  *  @brief    TIM PWM functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### TIM PWM functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM PWM.\r\n    (+) De-initialize the TIM PWM.\r\n    (+) Start the TIM PWM.\r\n    (+) Stop the TIM PWM.\r\n    (+) Start the TIM PWM and enable interrupt.\r\n    (+) Stop the TIM PWM and disable interrupt.\r\n    (+) Start the TIM PWM and enable DMA transfer.\r\n    (+) Stop the TIM PWM and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM PWM Time Base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()\r\n  * @param  htim TIM PWM handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->PWM_MspInitCallback == NULL)\r\n    {\r\n      htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->PWM_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_PWM_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the PWM */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM PWM handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->PWM_MspDeInitCallback == NULL)\r\n  {\r\n    htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->PWM_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_PWM_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM PWM MSP.\r\n  * @param  htim TIM PWM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM PWM MSP.\r\n  * @param  htim TIM PWM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Capture compare channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation in interrupt mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation in interrupt mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM PWM signal generation in DMA mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM channel state */\r\n  if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Capture/Compare 3 request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Enable the main output */\r\n      __HAL_TIM_MOE_ENABLE(htim);\r\n    }\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM PWM signal generation in DMA mode.\r\n  * @param  htim TIM PWM handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n    {\r\n      /* Disable the Main Output */\r\n      __HAL_TIM_MOE_DISABLE(htim);\r\n    }\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions\r\n  *  @brief    TIM Input Capture functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### TIM Input Capture functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides functions allowing to:\r\n   (+) Initialize and configure the TIM Input Capture.\r\n   (+) De-initialize the TIM Input Capture.\r\n   (+) Start the TIM Input Capture.\r\n   (+) Stop the TIM Input Capture.\r\n   (+) Start the TIM Input Capture and enable interrupt.\r\n   (+) Stop the TIM Input Capture and disable interrupt.\r\n   (+) Start the TIM Input Capture and enable DMA transfer.\r\n   (+) Stop the TIM Input Capture and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Input Capture Time base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->IC_MspInitCallback == NULL)\r\n    {\r\n      htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->IC_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_IC_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Init the base time for the input capture */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM peripheral\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->IC_MspDeInitCallback == NULL)\r\n  {\r\n    htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->IC_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */\r\n  HAL_TIM_IC_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Input Capture MSP.\r\n  * @param  htim TIM Input Capture handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Input Capture MSP.\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement in interrupt mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM channel state */\r\n  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Enable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Input Capture channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement in interrupt mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Input Capture channel */\r\n    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Input Capture measurement in DMA mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @param  pData The destination Buffer address.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel state */\r\n  if ((channel_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n      || (complementary_channel_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if ((channel_state == HAL_TIM_CHANNEL_STATE_READY)\r\n           && (complementary_channel_state == HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 4  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Input Capture measurement in DMA mode.\r\n  * @param  htim TIM Input Capture handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n  assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel */\r\n  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3  DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Disable the TIM Capture/Compare 4  DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM channel state */\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions\r\n  *  @brief    TIM One Pulse functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### TIM One Pulse functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM One Pulse.\r\n    (+) De-initialize the TIM One Pulse.\r\n    (+) Start the TIM One Pulse.\r\n    (+) Stop the TIM One Pulse.\r\n    (+) Start the TIM One Pulse and enable interrupt.\r\n    (+) Stop the TIM One Pulse and disable interrupt.\r\n    (+) Start the TIM One Pulse and enable DMA transfer.\r\n    (+) Stop the TIM One Pulse and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM One Pulse Time Base according to the specified\r\n  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()\r\n  * @note   When the timer instance is initialized in One Pulse mode, timer\r\n  *         channels 1 and channel 2 are reserved and cannot be used for other\r\n  *         purpose.\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OnePulseMode Select the One pulse mode.\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.\r\n  *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)\r\n{\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_OPM_MODE(OnePulseMode));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->OnePulse_MspInitCallback == NULL)\r\n    {\r\n      htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->OnePulse_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_OnePulse_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Configure the Time base in the One Pulse Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Reset the OPM Bit */\r\n  htim->Instance->CR1 &= ~TIM_CR1_OPM;\r\n\r\n  /* Configure the OPM Mode */\r\n  htim->Instance->CR1 |= OnePulseMode;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM One Pulse\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->OnePulse_MspDeInitCallback == NULL)\r\n  {\r\n    htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->OnePulse_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_OnePulse_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM One Pulse MSP.\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OnePulse_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM One Pulse MSP.\r\n  * @param  htim TIM One Pulse handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare and the Input Capture channels\r\n    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together\r\n\r\n    No need to enable the counter, it's enabled automatically by hardware\r\n    (the counter starts in response to a stimulus and generate a pulse */\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Disable the Capture compare and the Input Capture channels\r\n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation in interrupt mode.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare and the Input Capture channels\r\n    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together\r\n\r\n    No need to enable the counter, it's enabled automatically by hardware\r\n    (the counter starts in response to a stimulus and generate a pulse */\r\n\r\n  /* Enable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Enable the main output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation in interrupt mode.\r\n  * @note Though OutputChannel parameter is deprecated and ignored by the function\r\n  *        it has been kept to avoid HAL_TIM API compatibility break.\r\n  * @note The pulse output channel is determined when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel See note above\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(OutputChannel);\r\n\r\n  /* Disable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Disable the Capture compare and the Input Capture channels\r\n  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)\r\n  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and\r\n  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output\r\n  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)\r\n  {\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions\r\n  *  @brief    TIM Encoder functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                          ##### TIM Encoder functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure the TIM Encoder.\r\n    (+) De-initialize the TIM Encoder.\r\n    (+) Start the TIM Encoder.\r\n    (+) Stop the TIM Encoder.\r\n    (+) Start the TIM Encoder and enable interrupt.\r\n    (+) Stop the TIM Encoder and disable interrupt.\r\n    (+) Start the TIM Encoder and enable DMA transfer.\r\n    (+) Stop the TIM Encoder and disable DMA transfer.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.\r\n  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)\r\n  *         requires a timer reset to avoid unexpected direction\r\n  *         due to DIR bit readonly in center aligned mode.\r\n  *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()\r\n  * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together\r\n  *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource\r\n  *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa\r\n  * @note   When the timer instance is initialized in Encoder mode, timer\r\n  *         channels 1 and channel 2 are reserved and cannot be used for other\r\n  *         purpose.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  sConfig TIM Encoder Interface configuration structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)\r\n{\r\n  uint32_t tmpsmcr;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n  assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));\r\n  assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));\r\n  assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy weak callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->Encoder_MspInitCallback == NULL)\r\n    {\r\n      htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->Encoder_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIM_Encoder_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Reset the SMS and ECE bits */\r\n  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);\r\n\r\n  /* Configure the Time base in the Encoder Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmr1 = htim->Instance->CCMR1;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = htim->Instance->CCER;\r\n\r\n  /* Set the encoder Mode */\r\n  tmpsmcr |= sConfig->EncoderMode;\r\n\r\n  /* Select the Capture Compare 1 and the Capture Compare 2 as input */\r\n  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);\r\n  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));\r\n\r\n  /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */\r\n  tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);\r\n  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);\r\n  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);\r\n  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);\r\n\r\n  /* Set the TI1 and the TI2 Polarities */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);\r\n  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);\r\n  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);\r\n\r\n  /* Write to TIMx SMCR */\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  htim->Instance->CCMR1 = tmpccmr1;\r\n\r\n  /* Write to TIMx CCER */\r\n  htim->Instance->CCER = tmpccer;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Encoder interface\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->Encoder_MspDeInitCallback == NULL)\r\n  {\r\n    htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->Encoder_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIM_Encoder_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Encoder Interface MSP.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Encoder_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Encoder Interface MSP.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_Encoder_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n\r\n  /* Enable the encoder interface channels */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      break;\r\n    }\r\n  }\r\n  /* Enable the Peripheral */\r\n  __HAL_TIM_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface in interrupt mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n        || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n\r\n  /* Enable the encoder interface channels */\r\n  /* Enable the capture compare Interrupts 1 and/or 2 */\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    default :\r\n    {\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Enable the Peripheral */\r\n  __HAL_TIM_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface in interrupt mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 1 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 2 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n  }\r\n  else\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare Interrupts 1 and 2 */\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Encoder Interface in DMA mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @param  pData1 The destination Buffer address for IC1.\r\n  * @param  pData2 The destination Buffer address for IC2.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,\r\n                                            uint32_t *pData2, uint16_t Length)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((pData1 == NULL) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    if ((channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_2_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((pData2 == NULL) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n        || (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n    else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (channel_2_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n             && (complementary_channel_2_state == HAL_TIM_CHANNEL_STATE_READY))\r\n    {\r\n      if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n        TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Input Capture DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n\r\n    default:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      /* Enable the TIM Input Capture  DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n\r\n      /* Enable the Capture compare channel */\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);\r\n\r\n      /* Enable the Peripheral */\r\n      __HAL_TIM_ENABLE(htim);\r\n\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Encoder Interface in DMA mode.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1 and 2\r\n    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 1 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 2 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n  }\r\n  else\r\n  {\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);\r\n\r\n    /* Disable the capture compare DMA Request 1 and 2 */\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n  }\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel(s) state */\r\n  if ((Channel == TIM_CHANNEL_1) || (Channel == TIM_CHANNEL_2))\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n/** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management\r\n  *  @brief    TIM IRQ handler management\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### IRQ handler management #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides Timer IRQ handler function.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  This function handles TIM interrupts requests.\r\n  * @param  htim TIM  handle\r\n  * @retval None\r\n  */\r\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Capture compare 1 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)\r\n    {\r\n      {\r\n        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);\r\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n        /* Input capture event */\r\n        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)\r\n        {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n          htim->IC_CaptureCallback(htim);\r\n#else\r\n          HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n        }\r\n        /* Output compare event */\r\n        else\r\n        {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n          htim->OC_DelayElapsedCallback(htim);\r\n          htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n          HAL_TIM_OC_DelayElapsedCallback(htim);\r\n          HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n        }\r\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n      }\r\n    }\r\n  }\r\n  /* Capture compare 2 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* Capture compare 3 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* Capture compare 4 event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n      /* Input capture event */\r\n      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->IC_CaptureCallback(htim);\r\n#else\r\n        HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      /* Output compare event */\r\n      else\r\n      {\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n        htim->OC_DelayElapsedCallback(htim);\r\n        htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n        HAL_TIM_OC_DelayElapsedCallback(htim);\r\n        HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n      }\r\n      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n    }\r\n  }\r\n  /* TIM Update event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->PeriodElapsedCallback(htim);\r\n#else\r\n      HAL_TIM_PeriodElapsedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Break input event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->BreakCallback(htim);\r\n#else\r\n      HAL_TIMEx_BreakCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Break2 input event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->Break2Callback(htim);\r\n#else\r\n      HAL_TIMEx_Break2Callback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM Trigger detection event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->TriggerCallback(htim);\r\n#else\r\n      HAL_TIM_TriggerCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  /* TIM commutation event */\r\n  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)\r\n  {\r\n    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)\r\n    {\r\n      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n      htim->CommutationCallback(htim);\r\n#else\r\n      HAL_TIMEx_CommutCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions\r\n  *  @brief    TIM Peripheral Control functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                   ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides functions allowing to:\r\n      (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.\r\n      (+) Configure External Clock source.\r\n      (+) Configure Complementary channels, break features and dead time.\r\n      (+) Configure Master and the Slave synchronization.\r\n      (+) Configure the DMA Burst Mode.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initializes the TIM Output Compare Channels according to the specified\r\n  *         parameters in the TIM_OC_InitTypeDef.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  sConfig TIM Output Compare configuration structure\r\n  * @param  Channel TIM Channels to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,\r\n                                           TIM_OC_InitTypeDef *sConfig,\r\n                                           uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));\r\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 1 in Output Compare */\r\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 2 in Output Compare */\r\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 3 in Output Compare */\r\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 4 in Output Compare */\r\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_5:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 5 in Output Compare */\r\n      TIM_OC5_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_6:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the TIM Channel 6 in Output Compare */\r\n      TIM_OC6_SetConfig(htim->Instance, sConfig);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Input Capture Channels according to the specified\r\n  *         parameters in the TIM_IC_InitTypeDef.\r\n  * @param  htim TIM IC handle\r\n  * @param  sConfig TIM Input Capture configuration structure\r\n  * @param  Channel TIM Channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));\r\n  assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (Channel == TIM_CHANNEL_1)\r\n  {\r\n    /* TI1 Configuration */\r\n    TIM_TI1_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC1PSC Bits */\r\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n\r\n    /* Set the IC1PSC value */\r\n    htim->Instance->CCMR1 |= sConfig->ICPrescaler;\r\n  }\r\n  else if (Channel == TIM_CHANNEL_2)\r\n  {\r\n    /* TI2 Configuration */\r\n    assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI2_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC2PSC Bits */\r\n    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\r\n\r\n    /* Set the IC2PSC value */\r\n    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);\r\n  }\r\n  else if (Channel == TIM_CHANNEL_3)\r\n  {\r\n    /* TI3 Configuration */\r\n    assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI3_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC3PSC Bits */\r\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;\r\n\r\n    /* Set the IC3PSC value */\r\n    htim->Instance->CCMR2 |= sConfig->ICPrescaler;\r\n  }\r\n  else if (Channel == TIM_CHANNEL_4)\r\n  {\r\n    /* TI4 Configuration */\r\n    assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n    TIM_TI4_SetConfig(htim->Instance,\r\n                      sConfig->ICPolarity,\r\n                      sConfig->ICSelection,\r\n                      sConfig->ICFilter);\r\n\r\n    /* Reset the IC4PSC Bits */\r\n    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;\r\n\r\n    /* Set the IC4PSC value */\r\n    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);\r\n  }\r\n  else\r\n  {\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM PWM  channels according to the specified\r\n  *         parameters in the TIM_OC_InitTypeDef.\r\n  * @param  htim TIM PWM handle\r\n  * @param  sConfig TIM PWM configuration structure\r\n  * @param  Channel TIM Channels to be configured\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,\r\n                                            TIM_OC_InitTypeDef *sConfig,\r\n                                            uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));\r\n  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));\r\n  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 1 in PWM mode */\r\n      TIM_OC1_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel1 */\r\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;\r\n      htim->Instance->CCMR1 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 2 in PWM mode */\r\n      TIM_OC2_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel2 */\r\n      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;\r\n      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 3 in PWM mode */\r\n      TIM_OC3_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel3 */\r\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;\r\n      htim->Instance->CCMR2 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 4 in PWM mode */\r\n      TIM_OC4_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel4 */\r\n      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;\r\n      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_5:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 5 in PWM mode */\r\n      TIM_OC5_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel5*/\r\n      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;\r\n      htim->Instance->CCMR3 |= sConfig->OCFastMode;\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_6:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));\r\n\r\n      /* Configure the Channel 6 in PWM mode */\r\n      TIM_OC6_SetConfig(htim->Instance, sConfig);\r\n\r\n      /* Set the Preload enable bit for channel6 */\r\n      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;\r\n\r\n      /* Configure the Output Fast mode */\r\n      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;\r\n      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM One Pulse Channels according to the specified\r\n  *         parameters in the TIM_OnePulse_InitTypeDef.\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  sConfig TIM One Pulse configuration structure\r\n  * @param  OutputChannel TIM output channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @param  InputChannel TIM input Channel to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @note  To output a waveform with a minimum delay user can enable the fast\r\n  *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx\r\n  *        output is forced in response to the edge detection on TIx input,\r\n  *        without taking in account the comparison.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,\r\n                                                 uint32_t OutputChannel,  uint32_t InputChannel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  TIM_OC_InitTypeDef temp1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));\r\n  assert_param(IS_TIM_OPM_CHANNELS(InputChannel));\r\n\r\n  if (OutputChannel != InputChannel)\r\n  {\r\n    /* Process Locked */\r\n    __HAL_LOCK(htim);\r\n\r\n    htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n    /* Extract the Output compare configuration from sConfig structure */\r\n    temp1.OCMode = sConfig->OCMode;\r\n    temp1.Pulse = sConfig->Pulse;\r\n    temp1.OCPolarity = sConfig->OCPolarity;\r\n    temp1.OCNPolarity = sConfig->OCNPolarity;\r\n    temp1.OCIdleState = sConfig->OCIdleState;\r\n    temp1.OCNIdleState = sConfig->OCNIdleState;\r\n\r\n    switch (OutputChannel)\r\n    {\r\n      case TIM_CHANNEL_1:\r\n      {\r\n        assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n        TIM_OC1_SetConfig(htim->Instance, &temp1);\r\n        break;\r\n      }\r\n\r\n      case TIM_CHANNEL_2:\r\n      {\r\n        assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n        TIM_OC2_SetConfig(htim->Instance, &temp1);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n\r\n    if (status == HAL_OK)\r\n    {\r\n      switch (InputChannel)\r\n      {\r\n        case TIM_CHANNEL_1:\r\n        {\r\n          assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n          TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,\r\n                            sConfig->ICSelection, sConfig->ICFilter);\r\n\r\n          /* Reset the IC1PSC Bits */\r\n          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n\r\n          /* Select the Trigger source */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n          htim->Instance->SMCR |= TIM_TS_TI1FP1;\r\n\r\n          /* Select the Slave Mode */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;\r\n          break;\r\n        }\r\n\r\n        case TIM_CHANNEL_2:\r\n        {\r\n          assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n          TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,\r\n                            sConfig->ICSelection, sConfig->ICFilter);\r\n\r\n          /* Reset the IC2PSC Bits */\r\n          htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;\r\n\r\n          /* Select the Trigger source */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n          htim->Instance->SMCR |= TIM_TS_TI2FP2;\r\n\r\n          /* Select the Slave Mode */\r\n          htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n          htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;\r\n          break;\r\n        }\r\n\r\n        default:\r\n          status = HAL_ERROR;\r\n          break;\r\n      }\r\n    }\r\n\r\n    htim->State = HAL_TIM_STATE_READY;\r\n\r\n    __HAL_UNLOCK(htim);\r\n\r\n    return status;\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1\r\n  *            @arg TIM_DMABASE_AF2\r\n  *            @arg TIM_DMABASE_TISEL\r\n  *\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                              uint32_t BurstRequestSrc, uint32_t *BurstBuffer, uint32_t  BurstLength)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  status = HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,\r\n                                            ((BurstLength) >> 8U) + 1U);\r\n\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer multiple Data from the memory to the TIM peripheral\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA will start the Data write\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1\r\n  *            @arg TIM_DMABASE_AF2\r\n  *            @arg TIM_DMABASE_TISEL\r\n  *\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @param  DataLength Data length. This parameter can be one value\r\n  *         between 1 and 0xFFFF.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                                   uint32_t BurstRequestSrc, uint32_t *BurstBuffer,\r\n                                                   uint32_t  BurstLength,  uint32_t  DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n  assert_param(IS_TIM_DMA_LENGTH(BurstLength));\r\n  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));\r\n\r\n  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)\r\n  {\r\n    if ((BurstBuffer == NULL) && (BurstLength > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      /* Set the DMA Period elapsed callbacks */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      /* Set the DMA commutation callbacks */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      /* Set the DMA trigger callbacks */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,\r\n                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Configure the DMA Burst Mode */\r\n    htim->Instance->DCR = (BurstBaseAddress | BurstLength);\r\n    /* Enable the TIM DMA Request */\r\n    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM DMA Burst mode\r\n  * @param  htim TIM handle\r\n  * @param  BurstRequestSrc TIM DMA Request sources to disable\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n\r\n  /* Abort the DMA transfer (at least disable the DMA stream) */\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the TIM Update DMA request */\r\n    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\r\n\r\n    /* Change the DMA burst operation state */\r\n    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1\r\n  *            @arg TIM_DMABASE_AF2\r\n  *            @arg TIM_DMABASE_TISEL\r\n  *\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                             uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  status = HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,\r\n                                           ((BurstLength) >> 8U) + 1U);\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory\r\n  * @param  htim TIM handle\r\n  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMABASE_CR1\r\n  *            @arg TIM_DMABASE_CR2\r\n  *            @arg TIM_DMABASE_SMCR\r\n  *            @arg TIM_DMABASE_DIER\r\n  *            @arg TIM_DMABASE_SR\r\n  *            @arg TIM_DMABASE_EGR\r\n  *            @arg TIM_DMABASE_CCMR1\r\n  *            @arg TIM_DMABASE_CCMR2\r\n  *            @arg TIM_DMABASE_CCER\r\n  *            @arg TIM_DMABASE_CNT\r\n  *            @arg TIM_DMABASE_PSC\r\n  *            @arg TIM_DMABASE_ARR\r\n  *            @arg TIM_DMABASE_RCR\r\n  *            @arg TIM_DMABASE_CCR1\r\n  *            @arg TIM_DMABASE_CCR2\r\n  *            @arg TIM_DMABASE_CCR3\r\n  *            @arg TIM_DMABASE_CCR4\r\n  *            @arg TIM_DMABASE_BDTR\r\n  *            @arg TIM_DMABASE_CCMR3\r\n  *            @arg TIM_DMABASE_CCR5\r\n  *            @arg TIM_DMABASE_CCR6\r\n  *            @arg TIM_DMABASE_AF1\r\n  *            @arg TIM_DMABASE_AF2\r\n  *            @arg TIM_DMABASE_TISEL\r\n  *\r\n  * @param  BurstRequestSrc TIM DMA Request sources\r\n  *         This parameter can be one of the following values:\r\n  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source\r\n  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source\r\n  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source\r\n  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source\r\n  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source\r\n  *            @arg TIM_DMA_COM: TIM Commutation DMA source\r\n  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source\r\n  * @param  BurstBuffer The Buffer address.\r\n  * @param  BurstLength DMA Burst length. This parameter can be one value\r\n  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.\r\n  * @param  DataLength Data length. This parameter can be one value\r\n  *         between 1 and 0xFFFF.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,\r\n                                                  uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,\r\n                                                  uint32_t  BurstLength, uint32_t  DataLength)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n  assert_param(IS_TIM_DMA_LENGTH(BurstLength));\r\n  assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));\r\n\r\n  if (htim->DMABurstState == HAL_DMA_BURST_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (htim->DMABurstState == HAL_DMA_BURST_STATE_READY)\r\n  {\r\n    if ((BurstBuffer == NULL) && (BurstLength > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      htim->DMABurstState = HAL_DMA_BURST_STATE_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      /* Set the DMA Period elapsed callbacks */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      /* Set the DMA capture callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      /* Set the DMA commutation callbacks */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      /* Set the DMA trigger callbacks */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,\r\n                           DataLength) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Configure the DMA Burst Mode */\r\n    htim->Instance->DCR = (BurstBaseAddress | BurstLength);\r\n\r\n    /* Enable the TIM DMA Request */\r\n    __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stop the DMA burst reading\r\n  * @param  htim TIM handle\r\n  * @param  BurstRequestSrc TIM DMA Request sources to disable.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));\r\n\r\n  /* Abort the DMA transfer (at least disable the DMA stream) */\r\n  switch (BurstRequestSrc)\r\n  {\r\n    case TIM_DMA_UPDATE:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC1:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC2:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC3:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n    case TIM_DMA_CC4:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);\r\n      break;\r\n    }\r\n    case TIM_DMA_COM:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);\r\n      break;\r\n    }\r\n    case TIM_DMA_TRIGGER:\r\n    {\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the TIM Update DMA request */\r\n    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);\r\n\r\n    /* Change the DMA burst operation state */\r\n    htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Generate a software event\r\n  * @param  htim TIM handle\r\n  * @param  EventSource specifies the event source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source\r\n  *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source\r\n  *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source\r\n  *            @arg TIM_EVENTSOURCE_COM: Timer COM event source\r\n  *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source\r\n  *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source\r\n  *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source\r\n  * @note   Basic timers can only generate an update event.\r\n  * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.\r\n  * @note   TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are relevant\r\n  *         only for timer instances supporting break input(s).\r\n  * @retval HAL status\r\n  */\r\n\r\nHAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_EVENT_SOURCE(EventSource));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Change the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Set the event sources */\r\n  htim->Instance->EGR = EventSource;\r\n\r\n  /* Change the TIM state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the OCRef clear feature\r\n  * @param  htim TIM handle\r\n  * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that\r\n  *         contains the OCREF clear feature and parameters for the TIM peripheral.\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,\r\n                                           TIM_ClearInputConfigTypeDef *sClearInputConfig,\r\n                                           uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  switch (sClearInputConfig->ClearInputSource)\r\n  {\r\n    case TIM_CLEARINPUTSOURCE_NONE:\r\n    {\r\n      /* Clear the OCREF clear selection bit and the the ETR Bits */\r\n      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));\r\n      break;\r\n    }\r\n\r\n    case TIM_CLEARINPUTSOURCE_ETR:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));\r\n      assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));\r\n      assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));\r\n\r\n      /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */\r\n      if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)\r\n      {\r\n        htim->State = HAL_TIM_STATE_READY;\r\n        __HAL_UNLOCK(htim);\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClearInputConfig->ClearInputPrescaler,\r\n                        sClearInputConfig->ClearInputPolarity,\r\n                        sClearInputConfig->ClearInputFilter);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    switch (Channel)\r\n    {\r\n      case TIM_CHANNEL_1:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 1 */\r\n          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 1 */\r\n          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_2:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 2 */\r\n          SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 2 */\r\n          CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_3:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 3 */\r\n          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 3 */\r\n          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_4:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 4 */\r\n          SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 4 */\r\n          CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_5:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 5 */\r\n          SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 5 */\r\n          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);\r\n        }\r\n        break;\r\n      }\r\n      case TIM_CHANNEL_6:\r\n      {\r\n        if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)\r\n        {\r\n          /* Enable the OCREF clear feature for Channel 6 */\r\n          SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);\r\n        }\r\n        else\r\n        {\r\n          /* Disable the OCREF clear feature for Channel 6 */\r\n          CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief   Configures the clock source to be used\r\n  * @param  htim TIM handle\r\n  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that\r\n  *         contains the clock source information for the TIM peripheral.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));\r\n\r\n  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);\r\n  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  switch (sClockSourceConfig->ClockSource)\r\n  {\r\n    case TIM_CLOCKSOURCE_INTERNAL:\r\n    {\r\n      assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ETRMODE1:\r\n    {\r\n      /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));\r\n\r\n      /* Check ETR input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      /* Configure the ETR Clock source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClockSourceConfig->ClockPrescaler,\r\n                        sClockSourceConfig->ClockPolarity,\r\n                        sClockSourceConfig->ClockFilter);\r\n\r\n      /* Select the External clock mode1 and the ETRF trigger */\r\n      tmpsmcr = htim->Instance->SMCR;\r\n      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);\r\n      /* Write to TIMx SMCR */\r\n      htim->Instance->SMCR = tmpsmcr;\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ETRMODE2:\r\n    {\r\n      /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));\r\n\r\n      /* Check ETR input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      /* Configure the ETR Clock source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sClockSourceConfig->ClockPrescaler,\r\n                        sClockSourceConfig->ClockPolarity,\r\n                        sClockSourceConfig->ClockFilter);\r\n      /* Enable the External clock mode2 */\r\n      htim->Instance->SMCR |= TIM_SMCR_ECE;\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI1:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 */\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI1 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI2:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI2 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI2_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_TI1ED:\r\n    {\r\n      /* Check whether or not the timer instance supports external clock mode 1 */\r\n      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));\r\n\r\n      /* Check TI1 input conditioning related parameters */\r\n      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));\r\n      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));\r\n\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sClockSourceConfig->ClockPolarity,\r\n                               sClockSourceConfig->ClockFilter);\r\n      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);\r\n      break;\r\n    }\r\n\r\n    case TIM_CLOCKSOURCE_ITR0:\r\n    case TIM_CLOCKSOURCE_ITR1:\r\n    case TIM_CLOCKSOURCE_ITR2:\r\n    case TIM_CLOCKSOURCE_ITR3:\r\n    case TIM_CLOCKSOURCE_ITR4:\r\n    case TIM_CLOCKSOURCE_ITR5:\r\n    case TIM_CLOCKSOURCE_ITR6:\r\n    case TIM_CLOCKSOURCE_ITR7:\r\n    case TIM_CLOCKSOURCE_ITR8:\r\n    {\r\n      /* Check whether or not the timer instance supports internal trigger input */\r\n      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));\r\n\r\n      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Selects the signal connected to the TI1 input: direct from CH1_input\r\n  *         or a XOR combination between CH1_input, CH2_input & CH3_input\r\n  * @param  htim TIM handle.\r\n  * @param  TI1_Selection Indicate whether or not channel 1 is connected to the\r\n  *         output of a XOR gate.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input\r\n  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3\r\n  *            pins are connected to the TI1 input (XOR combination)\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)\r\n{\r\n  uint32_t tmpcr2;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TI1SELECTION(TI1_Selection));\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = htim->Instance->CR2;\r\n\r\n  /* Reset the TI1 selection */\r\n  tmpcr2 &= ~TIM_CR2_TI1S;\r\n\r\n  /* Set the TI1 selection */\r\n  tmpcr2 |= TI1_Selection;\r\n\r\n  /* Write to TIMxCR2 */\r\n  htim->Instance->CR2 = tmpcr2;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in Slave mode\r\n  * @param  htim TIM handle.\r\n  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that\r\n  *         contains the selected trigger (internal trigger input, filtered\r\n  *         timer input or external trigger input) and the Slave mode\r\n  *         (Disable, Reset, Gated, Trigger, External clock mode 1).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\r\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n    __HAL_UNLOCK(htim);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Disable Trigger Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);\r\n\r\n  /* Disable Trigger DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in Slave mode in interrupt mode\r\n  * @param  htim TIM handle.\r\n  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that\r\n  *         contains the selected trigger (internal trigger input, filtered\r\n  *         timer input or external trigger input) and the Slave mode\r\n  *         (Disable, Reset, Gated, Trigger, External clock mode 1).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,\r\n                                                TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));\r\n  assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n    __HAL_UNLOCK(htim);\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable Trigger Interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);\r\n\r\n  /* Disable Trigger DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);\r\n\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Read the captured value from Capture Compare unit\r\n  * @param  htim TIM handle.\r\n  * @param  Channel TIM Channels to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected\r\n  * @retval Captured value\r\n  */\r\nuint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpreg = 0U;\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 1 value */\r\n      tmpreg =  htim->Instance->CCR1;\r\n\r\n      break;\r\n    }\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 2 value */\r\n      tmpreg =   htim->Instance->CCR2;\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 3 value */\r\n      tmpreg =   htim->Instance->CCR3;\r\n\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_4:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));\r\n\r\n      /* Return the capture 4 value */\r\n      tmpreg =   htim->Instance->CCR4;\r\n\r\n      break;\r\n    }\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return tmpreg;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions\r\n  *  @brief    TIM Callbacks functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### TIM Callbacks functions #####\r\n  ==============================================================================\r\n [..]\r\n   This section provides TIM callback functions:\r\n   (+) TIM Period elapsed callback\r\n   (+) TIM Output Compare callback\r\n   (+) TIM Input capture callback\r\n   (+) TIM Trigger callback\r\n   (+) TIM Error callback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Period elapsed callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Period elapsed half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Output Compare callback in non-blocking mode\r\n  * @param  htim TIM OC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Input Capture callback in non-blocking mode\r\n  * @param  htim TIM IC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_CaptureCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Input Capture half complete callback in non-blocking mode\r\n  * @param  htim TIM IC handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  PWM Pulse finished callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  PWM Pulse finished half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Trigger detection callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_TriggerCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Trigger detection half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Timer error callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIM_ErrorCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Register a User TIM callback to be used instead of the weak predefined callback\r\n  * @param htim tim handle\r\n  * @param CallbackID ID of the callback to be registered\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID\r\n  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID\r\n  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID\r\n  *          @param pCallback pointer to the callback function\r\n  *          @retval status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,\r\n                                           pTIM_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  /* Process locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        htim->Base_MspInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        htim->Base_MspDeInitCallback               = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        htim->IC_MspInitCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        htim->IC_MspDeInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        htim->OC_MspInitCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        htim->OC_MspDeInitCallback                 = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        htim->PWM_MspInitCallback                  = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        htim->PWM_MspDeInitCallback                = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        htim->OnePulse_MspInitCallback             = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        htim->OnePulse_MspDeInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        htim->Encoder_MspInitCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        htim->Encoder_MspDeInitCallback            = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        htim->HallSensor_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        htim->HallSensor_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_CB_ID :\r\n        htim->PeriodElapsedCallback                = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :\r\n        htim->PeriodElapsedHalfCpltCallback        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_CB_ID :\r\n        htim->TriggerCallback                      = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_HALF_CB_ID :\r\n        htim->TriggerHalfCpltCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_CB_ID :\r\n        htim->IC_CaptureCallback                   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_HALF_CB_ID :\r\n        htim->IC_CaptureHalfCpltCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :\r\n        htim->OC_DelayElapsedCallback              = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :\r\n        htim->PWM_PulseFinishedCallback            = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :\r\n        htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ERROR_CB_ID :\r\n        htim->ErrorCallback                        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_CB_ID :\r\n        htim->CommutationCallback                  = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_HALF_CB_ID :\r\n        htim->CommutationHalfCpltCallback          = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK_CB_ID :\r\n        htim->BreakCallback                        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK2_CB_ID :\r\n        htim->Break2Callback                       = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        htim->Base_MspInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        htim->Base_MspDeInitCallback       = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        htim->IC_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        htim->IC_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        htim->OC_MspInitCallback           = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        htim->OC_MspDeInitCallback         = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        htim->PWM_MspInitCallback          = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        htim->PWM_MspDeInitCallback        = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        htim->OnePulse_MspInitCallback     = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        htim->OnePulse_MspDeInitCallback   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        htim->Encoder_MspInitCallback      = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        htim->Encoder_MspDeInitCallback    = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        htim->HallSensor_MspInitCallback   = pCallback;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        htim->HallSensor_MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister a TIM callback\r\n  *         TIM callback is redirected to the weak predefined callback\r\n  * @param htim tim handle\r\n  * @param CallbackID ID of the callback to be unregistered\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID\r\n  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID\r\n  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID\r\n  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID\r\n  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID\r\n  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID\r\n  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID\r\n  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID\r\n  *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID\r\n  *          @retval status\r\n  */\r\nHAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  if (htim->State == HAL_TIM_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        /* Legacy weak Base MspInit Callback */\r\n        htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Base Msp DeInit Callback */\r\n        htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        /* Legacy weak IC Msp Init Callback */\r\n        htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak IC Msp DeInit Callback */\r\n        htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        /* Legacy weak OC Msp Init Callback */\r\n        htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak OC Msp DeInit Callback */\r\n        htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        /* Legacy weak PWM Msp Init Callback */\r\n        htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        /* Legacy weak PWM Msp DeInit Callback */\r\n        htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp Init Callback */\r\n        htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp DeInit Callback */\r\n        htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp Init Callback */\r\n        htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp DeInit Callback */\r\n        htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp Init Callback */\r\n        htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp DeInit Callback */\r\n        htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_CB_ID :\r\n        /* Legacy weak Period Elapsed Callback */\r\n        htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :\r\n        /* Legacy weak Period Elapsed half complete Callback */\r\n        htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_CB_ID :\r\n        /* Legacy weak Trigger Callback */\r\n        htim->TriggerCallback                   = HAL_TIM_TriggerCallback;\r\n        break;\r\n\r\n      case HAL_TIM_TRIGGER_HALF_CB_ID :\r\n        /* Legacy weak Trigger half complete Callback */\r\n        htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_CB_ID :\r\n        /* Legacy weak IC Capture Callback */\r\n        htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;\r\n        break;\r\n\r\n      case HAL_TIM_IC_CAPTURE_HALF_CB_ID :\r\n        /* Legacy weak IC Capture half complete Callback */\r\n        htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :\r\n        /* Legacy weak OC Delay Elapsed Callback */\r\n        htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :\r\n        /* Legacy weak PWM Pulse Finished Callback */\r\n        htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :\r\n        /* Legacy weak PWM Pulse Finished half complete Callback */\r\n        htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_ERROR_CB_ID :\r\n        /* Legacy weak Error Callback */\r\n        htim->ErrorCallback                     = HAL_TIM_ErrorCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_CB_ID :\r\n        /* Legacy weak Commutation Callback */\r\n        htim->CommutationCallback               = HAL_TIMEx_CommutCallback;\r\n        break;\r\n\r\n      case HAL_TIM_COMMUTATION_HALF_CB_ID :\r\n        /* Legacy weak Commutation half complete Callback */\r\n        htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK_CB_ID :\r\n        /* Legacy weak Break Callback */\r\n        htim->BreakCallback                     = HAL_TIMEx_BreakCallback;\r\n        break;\r\n\r\n      case HAL_TIM_BREAK2_CB_ID :\r\n        /* Legacy weak Break2 Callback */\r\n        htim->Break2Callback                    = HAL_TIMEx_Break2Callback;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_TIM_BASE_MSPINIT_CB_ID :\r\n        /* Legacy weak Base MspInit Callback */\r\n        htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_BASE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Base Msp DeInit Callback */\r\n        htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPINIT_CB_ID :\r\n        /* Legacy weak IC Msp Init Callback */\r\n        htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_IC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak IC Msp DeInit Callback */\r\n        htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPINIT_CB_ID :\r\n        /* Legacy weak OC Msp Init Callback */\r\n        htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_OC_MSPDEINIT_CB_ID :\r\n        /* Legacy weak OC Msp DeInit Callback */\r\n        htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPINIT_CB_ID :\r\n        /* Legacy weak PWM Msp Init Callback */\r\n        htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_PWM_MSPDEINIT_CB_ID :\r\n        /* Legacy weak PWM Msp DeInit Callback */\r\n        htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp Init Callback */\r\n        htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :\r\n        /* Legacy weak One Pulse Msp DeInit Callback */\r\n        htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp Init Callback */\r\n        htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Encoder Msp DeInit Callback */\r\n        htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp Init Callback */\r\n        htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;\r\n        break;\r\n\r\n      case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :\r\n        /* Legacy weak Hall Sensor Msp DeInit Callback */\r\n        htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        /* Return error status */\r\n        status = HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Return error status */\r\n    status = HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions\r\n  *  @brief   TIM Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                        ##### Peripheral State functions #####\r\n  ==============================================================================\r\n    [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the TIM Base handle state.\r\n  * @param  htim TIM Base handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM OC handle state.\r\n  * @param  htim TIM Output Compare handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM PWM handle state.\r\n  * @param  htim TIM handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Input Capture handle state.\r\n  * @param  htim TIM IC handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM One Pulse Mode handle state.\r\n  * @param  htim TIM OPM handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Encoder Mode handle state.\r\n  * @param  htim TIM Encoder Interface handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return the TIM Encoder Mode handle state.\r\n  * @param  htim TIM handle\r\n  * @retval Active channel\r\n  */\r\nHAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->Channel;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of the TIM channel.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6\r\n  * @retval TIM Channel state\r\n  */\r\nHAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(TIM_HandleTypeDef *htim,  uint32_t Channel)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_state;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));\r\n\r\n  channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);\r\n\r\n  return channel_state;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of a DMA burst operation.\r\n  * @param  htim TIM handle\r\n  * @retval DMA burst state\r\n  */\r\nHAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));\r\n\r\n  return htim->DMABurstState;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIM_Private_Functions TIM Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  TIM DMA error callback\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n    TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->ErrorCallback(htim);\r\n#else\r\n  HAL_TIM_ErrorCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Capture complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->IC_CaptureCallback(htim);\r\n#else\r\n  HAL_TIM_IC_CaptureCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Capture half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->IC_CaptureHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_IC_CaptureHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Period Elapse complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (htim->hdma[TIM_DMA_ID_UPDATE]->Init.Mode == DMA_NORMAL)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PeriodElapsedCallback(htim);\r\n#else\r\n  HAL_TIM_PeriodElapsedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Period Elapse half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PeriodElapsedHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_PeriodElapsedHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Trigger callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (htim->hdma[TIM_DMA_ID_TRIGGER]->Init.Mode == DMA_NORMAL)\r\n  {\r\n    htim->State = HAL_TIM_STATE_READY;\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->TriggerCallback(htim);\r\n#else\r\n  HAL_TIM_TriggerCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Trigger half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->TriggerHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIM_TriggerHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  Time Base configuration\r\n  * @param  TIMx TIM peripheral\r\n  * @param  Structure TIM Base configuration structure\r\n  * @retval None\r\n  */\r\nvoid TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)\r\n{\r\n  uint32_t tmpcr1;\r\n  tmpcr1 = TIMx->CR1;\r\n\r\n  /* Set TIM Time Base Unit parameters ---------------------------------------*/\r\n  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))\r\n  {\r\n    /* Select the Counter Mode */\r\n    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);\r\n    tmpcr1 |= Structure->CounterMode;\r\n  }\r\n\r\n  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))\r\n  {\r\n    /* Set the clock division */\r\n    tmpcr1 &= ~TIM_CR1_CKD;\r\n    tmpcr1 |= (uint32_t)Structure->ClockDivision;\r\n  }\r\n\r\n  /* Set the auto-reload preload */\r\n  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);\r\n\r\n  TIMx->CR1 = tmpcr1;\r\n\r\n  /* Set the Autoreload value */\r\n  TIMx->ARR = (uint32_t)Structure->Period ;\r\n\r\n  /* Set the Prescaler value */\r\n  TIMx->PSC = Structure->Prescaler;\r\n\r\n  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))\r\n  {\r\n    /* Set the Repetition Counter value */\r\n    TIMx->RCR = Structure->RepetitionCounter;\r\n  }\r\n\r\n  /* Generate an update event to reload the Prescaler\r\n     and the repetition counter (only for advanced timer) value immediately */\r\n  TIMx->EGR = TIM_EGR_UG;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 1 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR1;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~TIM_CCMR1_OC1M;\r\n  tmpccmrx &= ~TIM_CCMR1_CC1S;\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC1P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= OC_Config->OCPolarity;\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC1NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= OC_Config->OCNPolarity;\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC1NE;\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS1;\r\n    tmpcr2 &= ~TIM_CR2_OIS1N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= OC_Config->OCIdleState;\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= OC_Config->OCNIdleState;\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  TIMx->CCMR1 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR1 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 2 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nvoid TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR1;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR1_OC2M;\r\n  tmpccmrx &= ~TIM_CCMR1_CC2S;\r\n\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC2P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 4U);\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))\r\n  {\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC2NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= (OC_Config->OCNPolarity << 4U);\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC2NE;\r\n\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS2;\r\n    tmpcr2 &= ~TIM_CR2_OIS2N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 2U);\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= (OC_Config->OCNIdleState << 2U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR1 */\r\n  TIMx->CCMR1 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR2 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 3 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 3: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC3E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmrx = TIMx->CCMR2;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR2_OC3M;\r\n  tmpccmrx &= ~TIM_CCMR2_CC3S;\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC3P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 8U);\r\n\r\n  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))\r\n  {\r\n    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));\r\n\r\n    /* Reset the Output N Polarity level */\r\n    tmpccer &= ~TIM_CCER_CC3NP;\r\n    /* Set the Output N Polarity */\r\n    tmpccer |= (OC_Config->OCNPolarity << 8U);\r\n    /* Reset the Output N State */\r\n    tmpccer &= ~TIM_CCER_CC3NE;\r\n  }\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare and Output Compare N IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS3;\r\n    tmpcr2 &= ~TIM_CR2_OIS3N;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 4U);\r\n    /* Set the Output N Idle state */\r\n    tmpcr2 |= (OC_Config->OCNIdleState << 4U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  TIMx->CCMR2 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR3 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 4 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC4E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n\r\n  /* Get the TIMx CCMR2 register value */\r\n  tmpccmrx = TIMx->CCMR2;\r\n\r\n  /* Reset the Output Compare mode and Capture/Compare selection Bits */\r\n  tmpccmrx &= ~TIM_CCMR2_OC4M;\r\n  tmpccmrx &= ~TIM_CCMR2_CC4S;\r\n\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC4P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 12U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Check parameters */\r\n    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));\r\n\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS4;\r\n\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 6U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR2 */\r\n  TIMx->CCMR2 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR4 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 5 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,\r\n                              TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the output: Reset the CCxE Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC5E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR3;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~(TIM_CCMR3_OC5M);\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= OC_Config->OCMode;\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= ~TIM_CCER_CC5P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 16U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS5;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 8U);\r\n  }\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR3 */\r\n  TIMx->CCMR3 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR5 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Timer Output Compare 6 configuration\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  OC_Config The output configuration structure\r\n  * @retval None\r\n  */\r\nstatic void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,\r\n                              TIM_OC_InitTypeDef *OC_Config)\r\n{\r\n  uint32_t tmpccmrx;\r\n  uint32_t tmpccer;\r\n  uint32_t tmpcr2;\r\n\r\n  /* Disable the output: Reset the CCxE Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC6E;\r\n\r\n  /* Get the TIMx CCER register value */\r\n  tmpccer = TIMx->CCER;\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 =  TIMx->CR2;\r\n  /* Get the TIMx CCMR1 register value */\r\n  tmpccmrx = TIMx->CCMR3;\r\n\r\n  /* Reset the Output Compare Mode Bits */\r\n  tmpccmrx &= ~(TIM_CCMR3_OC6M);\r\n  /* Select the Output Compare Mode */\r\n  tmpccmrx |= (OC_Config->OCMode << 8U);\r\n\r\n  /* Reset the Output Polarity level */\r\n  tmpccer &= (uint32_t)~TIM_CCER_CC6P;\r\n  /* Set the Output Compare Polarity */\r\n  tmpccer |= (OC_Config->OCPolarity << 20U);\r\n\r\n  if (IS_TIM_BREAK_INSTANCE(TIMx))\r\n  {\r\n    /* Reset the Output Compare IDLE State */\r\n    tmpcr2 &= ~TIM_CR2_OIS6;\r\n    /* Set the Output Idle state */\r\n    tmpcr2 |= (OC_Config->OCIdleState << 10U);\r\n  }\r\n\r\n  /* Write to TIMx CR2 */\r\n  TIMx->CR2 = tmpcr2;\r\n\r\n  /* Write to TIMx CCMR3 */\r\n  TIMx->CCMR3 = tmpccmrx;\r\n\r\n  /* Set the Capture Compare Register value */\r\n  TIMx->CCR6 = OC_Config->Pulse;\r\n\r\n  /* Write to TIMx CCER */\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Slave Timer configuration function\r\n  * @param  htim TIM handle\r\n  * @param  sSlaveConfig Slave timer configuration\r\n  * @retval None\r\n  */\r\nstatic HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,\r\n                                                  TIM_SlaveConfigTypeDef *sSlaveConfig)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* Reset the Trigger Selection Bits */\r\n  tmpsmcr &= ~TIM_SMCR_TS;\r\n  /* Set the Input Trigger source */\r\n  tmpsmcr |= sSlaveConfig->InputTrigger;\r\n\r\n  /* Reset the slave mode Bits */\r\n  tmpsmcr &= ~TIM_SMCR_SMS;\r\n  /* Set the slave mode */\r\n  tmpsmcr |= sSlaveConfig->SlaveMode;\r\n\r\n  /* Write to TIMx SMCR */\r\n  htim->Instance->SMCR = tmpsmcr;\r\n\r\n  /* Configure the trigger prescaler, filter, and polarity */\r\n  switch (sSlaveConfig->InputTrigger)\r\n  {\r\n    case TIM_TS_ETRF:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n      /* Configure the ETR Trigger source */\r\n      TIM_ETR_SetConfig(htim->Instance,\r\n                        sSlaveConfig->TriggerPrescaler,\r\n                        sSlaveConfig->TriggerPolarity,\r\n                        sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI1F_ED:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      if (sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)\r\n      {\r\n        return HAL_ERROR;\r\n      }\r\n\r\n      /* Disable the Channel 1: Reset the CC1E Bit */\r\n      tmpccer = htim->Instance->CCER;\r\n      htim->Instance->CCER &= ~TIM_CCER_CC1E;\r\n      tmpccmr1 = htim->Instance->CCMR1;\r\n\r\n      /* Set the filter */\r\n      tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);\r\n\r\n      /* Write to TIMx CCMR1 and CCER registers */\r\n      htim->Instance->CCMR1 = tmpccmr1;\r\n      htim->Instance->CCER = tmpccer;\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI1FP1:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      /* Configure TI1 Filter and Polarity */\r\n      TIM_TI1_ConfigInputStage(htim->Instance,\r\n                               sSlaveConfig->TriggerPolarity,\r\n                               sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_TI2FP2:\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n      assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));\r\n      assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));\r\n\r\n      /* Configure TI2 Filter and Polarity */\r\n      TIM_TI2_ConfigInputStage(htim->Instance,\r\n                               sSlaveConfig->TriggerPolarity,\r\n                               sSlaveConfig->TriggerFilter);\r\n      break;\r\n    }\r\n\r\n    case TIM_TS_ITR0:\r\n    case TIM_TS_ITR1:\r\n    case TIM_TS_ITR2:\r\n    case TIM_TS_ITR3:\r\n    case TIM_TS_ITR4:\r\n    case TIM_TS_ITR5:\r\n    case TIM_TS_ITR6:\r\n    case TIM_TS_ITR7:\r\n    case TIM_TS_ITR8:\r\n    case TIM_TS_ITR9:\r\n    case TIM_TS_ITR10:\r\n    case TIM_TS_ITR11:\r\n    case TIM_TS_ITR12:\r\n    case TIM_TS_ITR13:\r\n    {\r\n      /* Check the parameter */\r\n      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI1 as Input.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1\r\n  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nvoid TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                       uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)\r\n  {\r\n    tmpccmr1 &= ~TIM_CCMR1_CC1S;\r\n    tmpccmr1 |= TIM_ICSelection;\r\n  }\r\n  else\r\n  {\r\n    tmpccmr1 |= TIM_CCMR1_CC1S_0;\r\n  }\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);\r\n  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Polarity and Filter for TI1.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 1: Reset the CC1E Bit */\r\n  tmpccer = TIMx->CCER;\r\n  TIMx->CCER &= ~TIM_CCER_CC1E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC1F;\r\n  tmpccmr1 |= (TIM_ICFilter << 4U);\r\n\r\n  /* Select the Polarity and set the CC1E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);\r\n  tmpccer |= TIM_ICPolarity;\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI2 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nstatic void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr1 &= ~TIM_CCMR1_CC2S;\r\n  tmpccmr1 |= (TIM_ICSelection << 8U);\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC2F;\r\n  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1 ;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the Polarity and Filter for TI2.\r\n  * @param  TIMx to select the TIM peripheral.\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr1;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 2: Reset the CC2E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC2E;\r\n  tmpccmr1 = TIMx->CCMR1;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Set the filter */\r\n  tmpccmr1 &= ~TIM_CCMR1_IC2F;\r\n  tmpccmr1 |= (TIM_ICFilter << 12U);\r\n\r\n  /* Select the Polarity and set the CC2E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);\r\n  tmpccer |= (TIM_ICPolarity << 4U);\r\n\r\n  /* Write to TIMx CCMR1 and CCER registers */\r\n  TIMx->CCMR1 = tmpccmr1 ;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI3 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @retval None\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  */\r\nstatic void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 3: Reset the CC3E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC3E;\r\n  tmpccmr2 = TIMx->CCMR2;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr2 &= ~TIM_CCMR2_CC3S;\r\n  tmpccmr2 |= TIM_ICSelection;\r\n\r\n  /* Set the filter */\r\n  tmpccmr2 &= ~TIM_CCMR2_IC3F;\r\n  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);\r\n\r\n  /* Select the Polarity and set the CC3E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);\r\n  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));\r\n\r\n  /* Write to TIMx CCMR2 and CCER registers */\r\n  TIMx->CCMR2 = tmpccmr2;\r\n  TIMx->CCER = tmpccer;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TI4 as Input.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ICPolarity The Input Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICPOLARITY_RISING\r\n  *            @arg TIM_ICPOLARITY_FALLING\r\n  *            @arg TIM_ICPOLARITY_BOTHEDGE\r\n  * @param  TIM_ICSelection specifies the input to be used.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.\r\n  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.\r\n  *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.\r\n  * @param  TIM_ICFilter Specifies the Input Capture Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F.\r\n  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3\r\n  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be\r\n  *        protected against un-initialized filter and polarity values.\r\n  * @retval None\r\n  */\r\nstatic void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,\r\n                              uint32_t TIM_ICFilter)\r\n{\r\n  uint32_t tmpccmr2;\r\n  uint32_t tmpccer;\r\n\r\n  /* Disable the Channel 4: Reset the CC4E Bit */\r\n  TIMx->CCER &= ~TIM_CCER_CC4E;\r\n  tmpccmr2 = TIMx->CCMR2;\r\n  tmpccer = TIMx->CCER;\r\n\r\n  /* Select the Input */\r\n  tmpccmr2 &= ~TIM_CCMR2_CC4S;\r\n  tmpccmr2 |= (TIM_ICSelection << 8U);\r\n\r\n  /* Set the filter */\r\n  tmpccmr2 &= ~TIM_CCMR2_IC4F;\r\n  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);\r\n\r\n  /* Select the Polarity and set the CC4E Bit */\r\n  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);\r\n  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));\r\n\r\n  /* Write to TIMx CCMR2 and CCER registers */\r\n  TIMx->CCMR2 = tmpccmr2;\r\n  TIMx->CCER = tmpccer ;\r\n}\r\n\r\n/**\r\n  * @brief  Selects the Input Trigger source\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  InputTriggerSource The Input Trigger source.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal Trigger 0\r\n  *            @arg TIM_TS_ITR1: Internal Trigger 1\r\n  *            @arg TIM_TS_ITR2: Internal Trigger 2\r\n  *            @arg TIM_TS_ITR3: Internal Trigger 3\r\n  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector\r\n  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1\r\n  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2\r\n  *            @arg TIM_TS_ETRF: External Trigger input\r\n  *            @arg TIM_TS_ITR4: Internal Trigger 4  (*)\r\n  *            @arg TIM_TS_ITR5: Internal Trigger 5\r\n  *            @arg TIM_TS_ITR6: Internal Trigger 6\r\n  *            @arg TIM_TS_ITR7: Internal Trigger 7\r\n  *            @arg TIM_TS_ITR8: Internal Trigger 8  (*)\r\n  *            @arg TIM_TS_ITR9: Internal Trigger 9  (*)\r\n  *            @arg TIM_TS_ITR10: Internal Trigger 10 (*)\r\n  *            @arg TIM_TS_ITR11: Internal Trigger 11 (*)\r\n  *            @arg TIM_TS_ITR12: Internal Trigger 12 (*)\r\n  *            @arg TIM_TS_ITR13: Internal Trigger 13 (*)\r\n  *\r\n  *       (*)  Value not defined in all devices.\r\n  *\r\n  * @retval None\r\n  */\r\nstatic void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = TIMx->SMCR;\r\n  /* Reset the TS Bits */\r\n  tmpsmcr &= ~TIM_SMCR_TS;\r\n  /* Set the Input Trigger source and the slave mode*/\r\n  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);\r\n  /* Write to TIMx SMCR */\r\n  TIMx->SMCR = tmpsmcr;\r\n}\r\n/**\r\n  * @brief  Configures the TIMx External Trigger (ETR).\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.\r\n  *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.\r\n  *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.\r\n  *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.\r\n  * @param  TIM_ExtTRGPolarity The external Trigger Polarity.\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.\r\n  *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.\r\n  * @param  ExtTRGFilter External Trigger Filter.\r\n  *          This parameter must be a value between 0x00 and 0x0F\r\n  * @retval None\r\n  */\r\nvoid TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,\r\n                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  tmpsmcr = TIMx->SMCR;\r\n\r\n  /* Reset the ETR Bits */\r\n  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);\r\n\r\n  /* Set the Prescaler, the Filter value and the Polarity */\r\n  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));\r\n\r\n  /* Write to TIMx SMCR */\r\n  TIMx->SMCR = tmpsmcr;\r\n}\r\n\r\n/**\r\n  * @brief  Enables or disables the TIM Capture Compare Channel x.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected\r\n  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected\r\n  * @param  ChannelState specifies the TIM Channel CCxE bit new state.\r\n  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.\r\n  * @retval None\r\n  */\r\nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)\r\n{\r\n  uint32_t tmp;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CC1_INSTANCE(TIMx));\r\n  assert_param(IS_TIM_CHANNELS(Channel));\r\n\r\n  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */\r\n\r\n  /* Reset the CCxE Bit */\r\n  TIMx->CCER &= ~tmp;\r\n\r\n  /* Set or reset the CCxE Bit */\r\n  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */\r\n}\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Reset interrupt callbacks to the legacy weak callbacks.\r\n  * @param  htim pointer to a TIM_HandleTypeDef structure that contains\r\n  *                the configuration information for TIM module.\r\n  * @retval None\r\n  */\r\nvoid TIM_ResetCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Reset the TIM callback to the legacy weak callbacks */\r\n  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;\r\n  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;\r\n  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;\r\n  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;\r\n  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;\r\n  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;\r\n  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;\r\n  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;\r\n  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback;\r\n  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;\r\n  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;\r\n  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;\r\n  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;\r\n  htim->Break2Callback                    = HAL_TIMEx_Break2Callback;\r\n}\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_TIM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_tim_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_tim_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   TIM HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Timer Extended peripheral:\r\n  *           + Time Hall Sensor Interface Initialization\r\n  *           + Time Hall Sensor Interface Start\r\n  *           + Time Complementary signal break and dead time configuration\r\n  *           + Time Master and Slave synchronization configuration\r\n  *           + Time Output Compare/PWM Channel Configuration (for channels 5 and 6)\r\n  *           + Timer remapping capabilities configuration\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n                      ##### TIMER Extended features #####\r\n  ==============================================================================\r\n  [..]\r\n    The Timer Extended features include:\r\n    (#) Complementary outputs with programmable dead-time for :\r\n        (++) Output Compare\r\n        (++) PWM generation (Edge and Center-aligned Mode)\r\n        (++) One-pulse mode output\r\n    (#) Synchronization circuit to control the timer with external signals and to\r\n        interconnect several timers together.\r\n    (#) Break input to put the timer output signals in reset state or in a known state.\r\n    (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for\r\n        positioning purposes\r\n\r\n            ##### How to use this driver #####\r\n  ==============================================================================\r\n    [..]\r\n     (#) Initialize the TIM low level resources by implementing the following functions\r\n         depending on the selected feature:\r\n           (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()\r\n\r\n     (#) Initialize the TIM low level resources :\r\n        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();\r\n        (##) TIM pins configuration\r\n            (+++) Enable the clock for the TIM GPIOs using the following function:\r\n              __HAL_RCC_GPIOx_CLK_ENABLE();\r\n            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();\r\n\r\n     (#) The external Clock can be configured, if needed (the default clock is the\r\n         internal clock from the APBx), using the following function:\r\n         HAL_TIM_ConfigClockSource, the clock configuration should be done before\r\n         any start function.\r\n\r\n     (#) Configure the TIM in the desired functioning mode using one of the\r\n         initialization function of this driver:\r\n          (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the\r\n               Timer Hall Sensor Interface and the commutation event with the corresponding\r\n               Interrupt and DMA request if needed (Note that One Timer is used to interface\r\n               with the Hall sensor Interface and another Timer should be used to use\r\n               the commutation event).\r\n\r\n     (#) Activate the TIM peripheral using one of the start functions:\r\n           (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(),\r\n                HAL_TIMEx_OCN_Start_IT()\r\n           (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(),\r\n                HAL_TIMEx_PWMN_Start_IT()\r\n           (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()\r\n           (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(),\r\n                HAL_TIMEx_HallSensor_Start_IT().\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIMEx TIMEx\r\n  * @brief TIM Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_TIM_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n#if defined(TIM_BDTR_BKBID)\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @defgroup TIMEx_Private_Constants TIM Extended Private Constants\r\n  * @{\r\n  */\r\n/* Timeout for break input rearm */\r\n#define TIM_BREAKINPUT_REARM_TIMEOUT    5UL /* 5 milliseconds */\r\n/**\r\n  * @}\r\n  */\r\n/* End of private constants --------------------------------------------------*/\r\n\r\n#endif /* TIM_BDTR_BKBID */\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\nstatic void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma);\r\nstatic void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState);\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions\r\n  * @brief    Timer Hall Sensor functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                      ##### Timer Hall Sensor functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Initialize and configure TIM HAL Sensor.\r\n    (+) De-initialize TIM HAL Sensor.\r\n    (+) Start the Hall Sensor Interface.\r\n    (+) Stop the Hall Sensor Interface.\r\n    (+) Start the Hall Sensor Interface and enable interrupts.\r\n    (+) Stop the Hall Sensor Interface and disable interrupts.\r\n    (+) Start the Hall Sensor Interface and enable DMA transfers.\r\n    (+) Stop the Hall Sensor Interface and disable DMA transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.\r\n  * @note   When the timer instance is initialized in Hall Sensor Interface mode,\r\n  *         timer channels 1 and channel 2 are reserved and cannot be used for\r\n  *         other purpose.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @param  sConfig TIM Hall Sensor configuration structure\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)\r\n{\r\n  TIM_OC_InitTypeDef OC_Config;\r\n\r\n  /* Check the TIM handle allocation */\r\n  if (htim == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));\r\n  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));\r\n  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));\r\n  assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));\r\n  assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));\r\n  assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));\r\n\r\n  if (htim->State == HAL_TIM_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    htim->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n    /* Reset interrupt callbacks to legacy week callbacks */\r\n    TIM_ResetCallback(htim);\r\n\r\n    if (htim->HallSensor_MspInitCallback == NULL)\r\n    {\r\n      htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;\r\n    }\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC */\r\n    htim->HallSensor_MspInitCallback(htim);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */\r\n    HAL_TIMEx_HallSensor_MspInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  /* Set the TIM state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Configure the Time base in the Encoder Mode */\r\n  TIM_Base_SetConfig(htim->Instance, &htim->Init);\r\n\r\n  /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */\r\n  TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);\r\n\r\n  /* Reset the IC1PSC Bits */\r\n  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;\r\n  /* Set the IC1PSC value */\r\n  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;\r\n\r\n  /* Enable the Hall sensor interface (XOR function of the three inputs) */\r\n  htim->Instance->CR2 |= TIM_CR2_TI1S;\r\n\r\n  /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */\r\n  htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n  htim->Instance->SMCR |= TIM_TS_TI1F_ED;\r\n\r\n  /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */\r\n  htim->Instance->SMCR &= ~TIM_SMCR_SMS;\r\n  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;\r\n\r\n  /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/\r\n  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;\r\n  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;\r\n  OC_Config.OCMode = TIM_OCMODE_PWM2;\r\n  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\r\n  OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\r\n  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;\r\n  OC_Config.Pulse = sConfig->Commutation_Delay;\r\n\r\n  TIM_OC2_SetConfig(htim->Instance, &OC_Config);\r\n\r\n  /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2\r\n    register to 101 */\r\n  htim->Instance->CR2 &= ~TIM_CR2_MMS;\r\n  htim->Instance->CR2 |= TIM_TRGO_OC2REF;\r\n\r\n  /* Initialize the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;\r\n\r\n  /* Initialize the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Initialize the TIM state*/\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the TIM Hall Sensor interface\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_INSTANCE(htim->Instance));\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Disable the TIM Peripheral Clock */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  if (htim->HallSensor_MspDeInitCallback == NULL)\r\n  {\r\n    htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  htim->HallSensor_MspDeInitCallback(htim);\r\n#else\r\n  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */\r\n  HAL_TIMEx_HallSensor_MspDeInit(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  /* Change the DMA burst operation state */\r\n  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;\r\n\r\n  /* Change the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);\r\n\r\n  /* Change TIM state */\r\n  htim->State = HAL_TIM_STATE_RESET;\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the TIM Hall Sensor MSP.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes TIM Hall Sensor MSP.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall sensor Interface.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channels 1, 2 and 3\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the capture compare Interrupts 1 event */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the capture compare Interrupts event */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Hall Sensor Interface in DMA mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @param  pData The destination Buffer address.\r\n  * @param  Length The length of data to be transferred from TIM peripheral to memory.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)\r\n{\r\n  uint32_t tmpsmcr;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Set the TIM channel state */\r\n  if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)\r\n      || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)\r\n           && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);\r\n\r\n  /* Set the DMA Input Capture 1 Callbacks */\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;\r\n\r\n  /* Enable the DMA stream for Capture 1*/\r\n  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)\r\n  {\r\n    /* Return error status */\r\n    return HAL_ERROR;\r\n  }\r\n  /* Enable the capture compare 1 Interrupt */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Hall Sensor Interface in DMA mode.\r\n  * @param  htim TIM Hall Sensor Interface handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));\r\n\r\n  /* Disable the Input Capture channel 1\r\n  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,\r\n  TIM_CHANNEL_2 and TIM_CHANNEL_3) */\r\n  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);\r\n\r\n\r\n  /* Disable the capture compare Interrupts 1 event */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n\r\n  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM channel state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions\r\n  *  @brief   Timer Complementary Output Compare functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n              ##### Timer Complementary Output Compare functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary Output Compare/PWM.\r\n    (+) Stop the Complementary Output Compare/PWM.\r\n    (+) Start the Complementary Output Compare/PWM and enable interrupts.\r\n    (+) Stop the Complementary Output Compare/PWM and disable interrupts.\r\n    (+) Start the Complementary Output Compare/PWM and enable DMA transfers.\r\n    (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation on the complementary\r\n  *         output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the Capture compare channel N */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation on the complementary\r\n  *         output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the Capture compare channel N */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in interrupt mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM OC handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Output Compare interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the TIM Break interrupt */\r\n    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);\r\n\r\n    /* Enable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in interrupt mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Output Compare interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the TIM Break interrupt (only if no more channel is active) */\r\n    tmpccer = htim->Instance->CCER;\r\n    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)\r\n    {\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);\r\n    }\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM Output Compare signal generation in DMA mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Output Compare DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM Output Compare signal generation in DMA mode\r\n  *         on the complementary output.\r\n  * @param  htim TIM Output Compare handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Output Compare DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the Capture compare channel N */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions\r\n  * @brief    Timer Complementary PWM functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                 ##### Timer Complementary PWM functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary PWM.\r\n    (+) Stop the Complementary PWM.\r\n    (+) Start the Complementary PWM and enable interrupts.\r\n    (+) Stop the Complementary PWM and disable interrupts.\r\n    (+) Start the Complementary PWM and enable DMA transfers.\r\n    (+) Stop the Complementary PWM and disable DMA transfers.\r\n    (+) Start the Complementary Input Capture measurement.\r\n    (+) Stop the Complementary Input Capture.\r\n    (+) Start the Complementary Input Capture and enable interrupts.\r\n    (+) Stop the Complementary Input Capture and disable interrupts.\r\n    (+) Start the Complementary Input Capture and enable DMA transfers.\r\n    (+) Stop the Complementary Input Capture and disable DMA transfers.\r\n    (+) Start the Complementary One Pulse generation.\r\n    (+) Stop the Complementary One Pulse.\r\n    (+) Start the Complementary One Pulse and enable interrupts.\r\n    (+) Stop the Complementary One Pulse and disable interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation on the complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the complementary PWM output  */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    __HAL_TIM_ENABLE(htim);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation on the complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Disable the complementary PWM output  */\r\n  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the PWM signal generation in interrupt mode on the\r\n  *         complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Check the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM complementary channel state */\r\n  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Enable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Enable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Enable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the TIM Break interrupt */\r\n    __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);\r\n\r\n    /* Enable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the PWM signal generation in interrupt mode on the\r\n  *         complementary output.\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpccer;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 interrupt */\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the TIM Break interrupt (only if no more channel is active) */\r\n    tmpccer = htim->Instance->CCER;\r\n    if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)\r\n    {\r\n      __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);\r\n    }\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM PWM signal generation in DMA mode on the\r\n  *         complementary output\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be enabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @param  pData The source Buffer address.\r\n  * @param  Length The length of data to be transferred from memory to TIM peripheral\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  /* Set the TIM complementary channel state */\r\n  if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n  else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)\r\n  {\r\n    if ((pData == NULL) && (Length > 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n    else\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Set the DMA compare callbacks */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;\r\n\r\n      /* Enable the DMA stream */\r\n      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,\r\n                           Length) != HAL_OK)\r\n      {\r\n        /* Return error status */\r\n        return HAL_ERROR;\r\n      }\r\n      /* Enable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Enable the complementary PWM output  */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);\r\n\r\n    /* Enable the Main Output */\r\n    __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n    /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */\r\n    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n    {\r\n      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;\r\n      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))\r\n      {\r\n        __HAL_TIM_ENABLE(htim);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      __HAL_TIM_ENABLE(htim);\r\n    }\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary\r\n  *         output\r\n  * @param  htim TIM handle\r\n  * @param  Channel TIM Channel to be disabled\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n    {\r\n      /* Disable the TIM Capture/Compare 1 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_2:\r\n    {\r\n      /* Disable the TIM Capture/Compare 2 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);\r\n      break;\r\n    }\r\n\r\n    case TIM_CHANNEL_3:\r\n    {\r\n      /* Disable the TIM Capture/Compare 3 DMA request */\r\n      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);\r\n      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);\r\n      break;\r\n    }\r\n\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  if (status == HAL_OK)\r\n  {\r\n    /* Disable the complementary PWM output */\r\n    TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);\r\n\r\n    /* Disable the Main Output */\r\n    __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n    /* Disable the Peripheral */\r\n    __HAL_TIM_DISABLE(htim);\r\n\r\n    /* Set the TIM complementary channel state */\r\n    TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n\r\n  /* Return function status */\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions\r\n  * @brief    Timer Complementary One Pulse functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                ##### Timer Complementary One Pulse functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n    (+) Start the Complementary One Pulse generation.\r\n    (+) Stop the Complementary One Pulse.\r\n    (+) Start the Complementary One Pulse and enable interrupts.\r\n    (+) Stop the Complementary One Pulse and disable interrupts.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation on the complementary\r\n  *         output.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to enable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation on the complementary\r\n  *         output.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to disable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Disable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM  channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the\r\n  *         complementary channel.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to enable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n  HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);\r\n  HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Check the TIM channels state */\r\n  if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)\r\n      || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Set the TIM channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);\r\n\r\n  /* Enable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Enable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Enable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);\r\n\r\n  /* Enable the Main Output */\r\n  __HAL_TIM_MOE_ENABLE(htim);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the\r\n  *         complementary channel.\r\n  * @note OutputChannel must match the pulse output channel chosen when calling\r\n  *       @ref HAL_TIM_OnePulse_ConfigChannel().\r\n  * @param  htim TIM One Pulse handle\r\n  * @param  OutputChannel pulse output channel to disable\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)\r\n{\r\n  uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));\r\n\r\n  /* Disable the TIM Capture/Compare 1 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);\r\n\r\n  /* Disable the TIM Capture/Compare 2 interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);\r\n\r\n  /* Disable the complementary One Pulse output channel and the Input Capture channel */\r\n  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);\r\n  TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);\r\n\r\n  /* Disable the Main Output */\r\n  __HAL_TIM_MOE_DISABLE(htim);\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_TIM_DISABLE(htim);\r\n\r\n  /* Set the TIM  channels state */\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n\r\n  /* Return function status */\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions\r\n  * @brief    Peripheral Control functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                    ##### Peripheral Control functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides functions allowing to:\r\n      (+) Configure the commutation event in case of use of the Hall sensor interface.\r\n      (+) Configure Output channels for OC and PWM mode.\r\n\r\n      (+) Configure Complementary channels, break features and dead time.\r\n      (+) Configure Master synchronization.\r\n      (+) Configure timer remapping capabilities.\r\n      (+) Select timer input source.\r\n      (+) Enable or disable channel grouping.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_ITR12: Internal trigger 12 selected (*)\r\n  *            @arg TIM_TS_ITR13: Internal trigger 13 selected (*)\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                              uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||\r\n      (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Disable Commutation Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);\r\n\r\n  /* Disable Commutation DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence with interrupt.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 12 selected (*)\r\n  *            @arg TIM_TS_ITR3: Internal trigger 13 selected (*)\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                                 uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||\r\n      (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Disable Commutation DMA request */\r\n  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  /* Enable the Commutation Interrupt */\r\n  __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the TIM commutation event sequence with DMA.\r\n  * @note  This function is mandatory to use the commutation event in order to\r\n  *        update the configuration at each commutation detection on the TRGI input of the Timer,\r\n  *        the typical use of this feature is with the use of another Timer(interface Timer)\r\n  *        configured in Hall sensor interface, this interface Timer will generate the\r\n  *        commutation at its TRGO output (connected to Timer used in this function) each time\r\n  *        the TI1 of the Interface Timer detect a commutation at its input TI1.\r\n  * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set\r\n  * @param  htim TIM handle\r\n  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_TS_ITR0: Internal trigger 0 selected\r\n  *            @arg TIM_TS_ITR1: Internal trigger 1 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 2 selected\r\n  *            @arg TIM_TS_ITR3: Internal trigger 3 selected\r\n  *            @arg TIM_TS_ITR2: Internal trigger 12 selected (*)\r\n  *            @arg TIM_TS_ITR3: Internal trigger 13 selected (*)\r\n  *            @arg TIM_TS_NONE: No trigger is needed\r\n  *\r\n  *         (*)  Value not defined in all devices.\r\n  *\r\n  * @param  CommutationSource the Commutation Event source\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer\r\n  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,\r\n                                                  uint32_t  CommutationSource)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||\r\n      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||\r\n      (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))\r\n  {\r\n    /* Select the Input trigger */\r\n    htim->Instance->SMCR &= ~TIM_SMCR_TS;\r\n    htim->Instance->SMCR |= InputTrigger;\r\n  }\r\n\r\n  /* Select the Capture Compare preload feature */\r\n  htim->Instance->CR2 |= TIM_CR2_CCPC;\r\n  /* Select the Commutation event source */\r\n  htim->Instance->CR2 &= ~TIM_CR2_CCUS;\r\n  htim->Instance->CR2 |= CommutationSource;\r\n\r\n  /* Enable the Commutation DMA Request */\r\n  /* Set the DMA Commutation Callback */\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;\r\n  /* Set the DMA error callback */\r\n  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;\r\n\r\n  /* Disable Commutation Interrupt */\r\n  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);\r\n\r\n  /* Enable the Commutation DMA Request */\r\n  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the TIM in master mode.\r\n  * @param  htim TIM handle.\r\n  * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that\r\n  *         contains the selected trigger output (TRGO) and the Master/Slave\r\n  *         mode.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,\r\n                                                        TIM_MasterConfigTypeDef *sMasterConfig)\r\n{\r\n  uint32_t tmpcr2;\r\n  uint32_t tmpsmcr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));\r\n  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Change the handler state */\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Get the TIMx CR2 register value */\r\n  tmpcr2 = htim->Instance->CR2;\r\n\r\n  /* Get the TIMx SMCR register value */\r\n  tmpsmcr = htim->Instance->SMCR;\r\n\r\n  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */\r\n  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));\r\n\r\n    /* Clear the MMS2 bits */\r\n    tmpcr2 &= ~TIM_CR2_MMS2;\r\n    /* Select the TRGO2 source*/\r\n    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;\r\n  }\r\n\r\n  /* Reset the MMS Bits */\r\n  tmpcr2 &= ~TIM_CR2_MMS;\r\n  /* Select the TRGO source */\r\n  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;\r\n\r\n  /* Update TIMx CR2 */\r\n  htim->Instance->CR2 = tmpcr2;\r\n\r\n  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))\r\n  {\r\n    /* Reset the MSM Bit */\r\n    tmpsmcr &= ~TIM_SMCR_MSM;\r\n    /* Set master mode */\r\n    tmpsmcr |= sMasterConfig->MasterSlaveMode;\r\n\r\n    /* Update TIMx SMCR */\r\n    htim->Instance->SMCR = tmpsmcr;\r\n  }\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State\r\n  *         and the AOE(automatic output enable).\r\n  * @param  htim TIM handle\r\n  * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that\r\n  *         contains the BDTR Register configuration  information for the TIM peripheral.\r\n  * @note   Interrupts can be generated when an active level is detected on the\r\n  *         break input, the break 2 input or the system break input. Break\r\n  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,\r\n                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)\r\n{\r\n  /* Keep this variable initialized to 0 as it is used to configure BDTR register */\r\n  uint32_t tmpbdtr = 0U;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));\r\n  assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));\r\n  assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));\r\n  assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));\r\n  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));\r\n  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));\r\n  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));\r\n  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,\r\n     the OSSI State, the dead time value and the Automatic Output Enable Bit */\r\n\r\n  /* Set the BDTR bits */\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);\r\n  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));\r\n\r\n#if defined(TIM_BDTR_BKBID)\r\n  if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));\r\n\r\n    /* Set BREAK AF mode */\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);\r\n  }\r\n\r\n#endif /* TIM_BDTR_BKBID */\r\n  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));\r\n    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));\r\n    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));\r\n\r\n    /* Set the BREAK2 input related BDTR bits */\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);\r\n    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);\r\n#if defined(TIM_BDTR_BKBID)\r\n\r\n    if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))\r\n    {\r\n      /* Check the parameters */\r\n      assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));\r\n\r\n      /* Set BREAK2 AF mode */\r\n      MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);\r\n    }\r\n#endif /* TIM_BDTR_BKBID */\r\n  }\r\n\r\n  /* Set TIMx_BDTR */\r\n  htim->Instance->BDTR = tmpbdtr;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n#if defined(TIM_BREAK_INPUT_SUPPORT)\r\n\r\n/**\r\n  * @brief  Configures the break input source.\r\n  * @param  htim TIM handle.\r\n  * @param  BreakInput Break input to configure\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_BREAKINPUT_BRK: Timer break input\r\n  *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input\r\n  * @param  sBreakInputConfig Break input source configuration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,\r\n                                             uint32_t BreakInput,\r\n                                             TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)\r\n\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmporx;\r\n  uint32_t bkin_enable_mask;\r\n  uint32_t bkin_polarity_mask;\r\n  uint32_t bkin_enable_bitpos;\r\n  uint32_t bkin_polarity_bitpos;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_BREAKINPUT(BreakInput));\r\n  assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));\r\n  assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));\r\n  if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)\r\n  {\r\n    assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));\r\n  }\r\n\r\n  /* Check input state */\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (sBreakInputConfig->Source)\r\n  {\r\n    case TIM_BREAKINPUTSOURCE_BKIN:\r\n    {\r\n      bkin_enable_mask = TIM1_AF1_BKINE;\r\n      bkin_enable_bitpos = TIM1_AF1_BKINE_Pos;\r\n      bkin_polarity_mask = TIM1_AF1_BKINP;\r\n      bkin_polarity_bitpos = TIM1_AF1_BKINP_Pos;\r\n      break;\r\n    }\r\n    case TIM_BREAKINPUTSOURCE_COMP1:\r\n    {\r\n      bkin_enable_mask = TIM1_AF1_BKCMP1E;\r\n      bkin_enable_bitpos = TIM1_AF1_BKCMP1E_Pos;\r\n      bkin_polarity_mask = TIM1_AF1_BKCMP1P;\r\n      bkin_polarity_bitpos = TIM1_AF1_BKCMP1P_Pos;\r\n      break;\r\n    }\r\n    case TIM_BREAKINPUTSOURCE_COMP2:\r\n    {\r\n      bkin_enable_mask = TIM1_AF1_BKCMP2E;\r\n      bkin_enable_bitpos = TIM1_AF1_BKCMP2E_Pos;\r\n      bkin_polarity_mask = TIM1_AF1_BKCMP2P;\r\n      bkin_polarity_bitpos = TIM1_AF1_BKCMP2P_Pos;\r\n      break;\r\n    }\r\n    case TIM_BREAKINPUTSOURCE_DFSDM1:\r\n    {\r\n      bkin_enable_mask = TIM1_AF1_BKDF1BK0E;\r\n      bkin_enable_bitpos = TIM1_AF1_BKDF1BK0E_Pos;\r\n      bkin_polarity_mask = 0U;\r\n      bkin_polarity_bitpos = 0U;\r\n      break;\r\n    }\r\n\r\n    default:\r\n    {\r\n      bkin_enable_mask = 0U;\r\n      bkin_polarity_mask = 0U;\r\n      bkin_enable_bitpos = 0U;\r\n      bkin_polarity_bitpos = 0U;\r\n      break;\r\n    }\r\n  }\r\n\r\n  switch (BreakInput)\r\n  {\r\n    case TIM_BREAKINPUT_BRK:\r\n    {\r\n      /* Get the TIMx_AF1 register value */\r\n      tmporx = htim->Instance->AF1;\r\n\r\n      /* Enable the break input */\r\n      tmporx &= ~bkin_enable_mask;\r\n      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;\r\n\r\n      /* Set the break input polarity */\r\n      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)\r\n      {\r\n        tmporx &= ~bkin_polarity_mask;\r\n        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;\r\n      }\r\n\r\n      /* Set TIMx_AF1 */\r\n      htim->Instance->AF1 = tmporx;\r\n      break;\r\n    }\r\n    case TIM_BREAKINPUT_BRK2:\r\n    {\r\n      /* Get the TIMx_AF2 register value */\r\n      tmporx = htim->Instance->AF2;\r\n\r\n      /* Enable the break input */\r\n      tmporx &= ~bkin_enable_mask;\r\n      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;\r\n\r\n      /* Set the break input polarity */\r\n      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)\r\n      {\r\n        tmporx &= ~bkin_polarity_mask;\r\n        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;\r\n      }\r\n\r\n      /* Set TIMx_AF2 */\r\n      htim->Instance->AF2 = tmporx;\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n#endif /*TIM_BREAK_INPUT_SUPPORT */\r\n\r\n/**\r\n  * @brief  Configures the TIMx Remapping input capabilities.\r\n  * @param  htim TIM handle.\r\n  * @param  Remap specifies the TIM remapping source.\r\n  *         For TIM1, the parameter is one of the following values:\r\n  *            @arg TIM_TIM1_ETR_GPIO:               TIM1_ETR is connected to GPIO\r\n  *            @arg TIM_TIM1_ETR_COMP1:              TIM1_ETR is connected to COMP1 output\r\n  *            @arg TIM_TIM1_ETR_COMP2:              TIM1_ETR is connected to COMP2 output\r\n  *            @arg TIM_TIM1_ETR_ADC1_AWD1:          TIM1_ETR is connected to ADC1 AWD1\r\n  *            @arg TIM_TIM1_ETR_ADC1_AWD2:          TIM1_ETR is connected to ADC1 AWD2\r\n  *            @arg TIM_TIM1_ETR_ADC1_AWD3:          TIM1_ETR is connected to ADC1 AWD3\r\n  *            @arg TIM_TIM1_ETR_ADC3_AWD1:          TIM1_ETR is connected to ADC3 AWD1\r\n  *            @arg TIM_TIM1_ETR_ADC3_AWD2:          TIM1_ETR is connected to ADC3 AWD2\r\n  *            @arg TIM_TIM1_ETR_ADC3_AWD3:          TIM1_ETR is connected to ADC3 AWD3\r\n  *\r\n  *         For TIM2, the parameter is one of the following values:\r\n  *            @arg TIM_TIM2_ETR_GPIO:               TIM2_ETR is connected to GPIO\r\n  *            @arg TIM_TIM2_ETR_COMP1:              TIM2_ETR is connected to COMP1 output\r\n  *            @arg TIM_TIM2_ETR_COMP2:              TIM2_ETR is connected to COMP2 output\r\n  *            @arg TIM_TIM2_ETR_LSE:                TIM2_ETR is connected to LSE\r\n  *            @arg TIM_TIM2_ETR_SAI1_FSA:           TIM2_ETR is connected to SAI1 FS_A\r\n  *            @arg TIM_TIM2_ETR_SAI1_FSB:           TIM2_ETR is connected to SAI1 FS_B\r\n  *\r\n  *         For TIM3, the parameter is one of the following values:\r\n  *            @arg TIM_TIM3_ETR_GPIO:               TIM3_ETR is connected to GPIO\r\n  *            @arg TIM_TIM3_ETR_COMP1:              TIM3_ETR is connected to COMP1 output\r\n  *\r\n  *         For TIM5, the parameter is one of the following values:\r\n  *            @arg TIM_TIM5_ETR_GPIO:               TIM5_ETR is connected to GPIO\r\n  *            @arg TIM_TIM5_ETR_SAI2_FSA:           TIM5_ETR is connected to SAI2 FS_A (*)\r\n  *            @arg TIM_TIM5_ETR_SAI2_FSB:           TIM5_ETR is connected to SAI2 FS_B (*)\r\n  *            @arg TIM_TIM5_ETR_SAI4_FSA:           TIM5_ETR is connected to SAI2 FS_A (*)\r\n  *            @arg TIM_TIM5_ETR_SAI4_FSB:           TIM5_ETR is connected to SAI2 FS_B (*)\r\n  *\r\n  *         For TIM8, the parameter is one of the following values:\r\n  *            @arg TIM_TIM8_ETR_GPIO:               TIM8_ETR is connected to GPIO\r\n  *            @arg TIM_TIM8_ETR_COMP1:              TIM8_ETR is connected to COMP1 output\r\n  *            @arg TIM_TIM8_ETR_COMP2:              TIM8_ETR is connected to COMP2 output\r\n  *            @arg TIM_TIM8_ETR_ADC2_AWD1:          TIM8_ETR is connected to ADC2 AWD1\r\n  *            @arg TIM_TIM8_ETR_ADC2_AWD2:          TIM8_ETR is connected to ADC2 AWD2\r\n  *            @arg TIM_TIM8_ETR_ADC2_AWD3:          TIM8_ETR is connected to ADC2 AWD3\r\n  *            @arg TIM_TIM8_ETR_ADC3_AWD1:          TIM8_ETR is connected to ADC3 AWD1\r\n  *            @arg TIM_TIM8_ETR_ADC3_AWD2:          TIM8_ETR is connected to ADC3 AWD2\r\n  *            @arg TIM_TIM8_ETR_ADC3_AWD3:          TIM8_ETR is connected to ADC3 AWD3\r\n  *\r\n  *         For TIM23, the parameter is one of the following values: (*)\r\n  *            @arg TIM_TIM23_ETR_GPIO               TIM23_ETR is connected to GPIO\r\n  *            @arg TIM_TIM23_ETR_COMP1              TIM23_ETR is connected to COMP1 output\r\n  *            @arg TIM_TIM23_ETR_COMP2              TIM23_ETR is connected to COMP2 output\r\n  *\r\n  *         For TIM24, the parameter is one of the following values: (*)\r\n  *           @arg TIM_TIM24_ETR_GPIO                TIM24_ETR is connected to GPIO\r\n  *           @arg TIM_TIM24_ETR_SAI4_FSA            TIM24_ETR is connected to SAI4 FS_A\r\n  *           @arg TIM_TIM24_ETR_SAI4_FSB            TIM24_ETR is connected to SAI4 FS_B\r\n  *           @arg TIM_TIM24_ETR_SAI1_FSA            TIM24_ETR is connected to SAI1 FS_A\r\n  *           @arg TIM_TIM24_ETR_SAI1_FSB            TIM24_ETR is connected to SAI1 FS_B\r\n  *\r\n  *         (*)  Value not defined in all devices.\r\n  *\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)\r\n{\r\n  /* Check parameters */\r\n  assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_REMAP(Remap));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  MODIFY_REG(htim->Instance->AF1, TIM1_AF1_ETRSEL_Msk, Remap);\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Select the timer input source\r\n  * @param  htim TIM handle.\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TI1 input channel\r\n  *            @arg TIM_CHANNEL_2: TI2 input channel\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  *            @arg TIM_CHANNEL_4: TIM Channel 4\r\n  * @param  TISelection parameter of the TIM_TISelectionStruct structure is detailed as follows:\r\n  *         For TIM1, the parameter is one of the following values:\r\n  *            @arg TIM_TIM1_TI1_GPIO:                TIM1 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM1_TI1_COMP1:               TIM1 TI1 is connected to COMP1 output\r\n  *\r\n  *         For TIM2, the parameter is one of the following values:\r\n  *            @arg TIM_TIM2_TI4_GPIO:                TIM2 TI4 is connected to GPIO\r\n  *            @arg TIM_TIM2_TI4_COMP1:               TIM2 TI4 is connected to COMP1 output\r\n  *            @arg TIM_TIM2_TI4_COMP2:               TIM2 TI4 is connected to COMP2 output\r\n  *            @arg TIM_TIM2_TI4_COMP1_COMP2:         TIM2 TI4 is connected to logical OR between COMP1 and COMP2 output\r\n  *\r\n  *         For TIM3, the parameter is one of the following values:\r\n  *            @arg TIM_TIM3_TI1_GPIO:                TIM3 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM3_TI1_COMP1:               TIM3 TI1 is connected to COMP1 output\r\n  *            @arg TIM_TIM3_TI1_COMP2:               TIM3 TI1 is connected to COMP2 output\r\n  *            @arg TIM_TIM3_TI1_COMP1_COMP2:         TIM3 TI1 is connected to logical OR between COMP1 and COMP2 output\r\n  *\r\n  *         For TIM5, the parameter is one of the following values:\r\n  *            @arg TIM_TIM5_TI1_GPIO:                TIM5 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM5_TI1_CAN_TMP:             TIM5 TI1 is connected to CAN TMP\r\n  *            @arg TIM_TIM5_TI1_CAN_RTP:             TIM5 TI1 is connected to CAN RTP\r\n  *\r\n  *         For TIM8, the parameter is one of the following values:\r\n  *            @arg TIM_TIM8_TI1_GPIO:               TIM8 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM8_TI1_COMP2:              TIM8 TI1 is connected to COMP2 output\r\n  *\r\n  *         For TIM12, the parameter can have the following values: (*)\r\n  *            @arg TIM_TIM12_TI1_GPIO:              TIM12 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM12_TI1_SPDIF_FS:          TIM12 TI1 is connected to SPDIF FS\r\n  *\r\n  *         For TIM15, the parameter is one of the following values:\r\n  *            @arg TIM_TIM15_TI1_GPIO:              TIM15 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM15_TI1_TIM2:              TIM15 TI1 is connected to TIM2 CH1\r\n  *            @arg TIM_TIM15_TI1_TIM3:              TIM15 TI1 is connected to TIM3 CH1\r\n  *            @arg TIM_TIM15_TI1_TIM4:              TIM15 TI1 is connected to TIM4 CH1\r\n  *            @arg TIM_TIM15_TI1_LSE:               TIM15 TI1 is connected to LSE\r\n  *            @arg TIM_TIM15_TI1_CSI:               TIM15 TI1 is connected to CSI\r\n  *            @arg TIM_TIM15_TI1_MCO2:              TIM15 TI1 is connected to MCO2\r\n  *            @arg TIM_TIM15_TI2_GPIO:              TIM15 TI2 is connected to GPIO\r\n  *            @arg TIM_TIM15_TI2_TIM2:              TIM15 TI2 is connected to TIM2 CH2\r\n  *            @arg TIM_TIM15_TI2_TIM3:              TIM15 TI2 is connected to TIM3 CH2\r\n  *            @arg TIM_TIM15_TI2_TIM4:              TIM15 TI2 is connected to TIM4 CH2\r\n  *\r\n  *         For TIM16, the parameter can have the following values:\r\n  *            @arg TIM_TIM16_TI1_GPIO:              TIM16 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM16_TI1_LSI:               TIM16 TI1 is connected to LSI\r\n  *            @arg TIM_TIM16_TI1_LSE:               TIM16 TI1 is connected to LSE\r\n  *            @arg TIM_TIM16_TI1_RTC:               TIM16 TI1 is connected to RTC wakeup interrupt\r\n  *\r\n  *         For TIM17, the parameter can have the following values:\r\n  *            @arg TIM_TIM17_TI1_GPIO:              TIM17 TI1 is connected to GPIO\r\n  *            @arg TIM_TIM17_TI1_SPDIF_FS:          TIM17 TI1 is connected to SPDIF FS (*)\r\n  *            @arg TIM_TIM17_TI1_HSE_1MHZ:          TIM17 TI1 is connected to HSE 1MHz\r\n  *            @arg TIM_TIM17_TI1_MCO1:              TIM17 TI1 is connected to MCO1\r\n  *\r\n  *         For TIM23, the parameter can have the following values: (*)\r\n  *            @arg TIM_TIM23_TI4_GPIO               TIM23_TI4 is connected to GPIO\r\n  *            @arg TIM_TIM23_TI4_COMP1              TIM23_TI4 is connected to COMP1 output\r\n  *            @arg TIM_TIM23_TI4_COMP2              TIM23_TI4 is connected to COMP2 output\r\n  *            @arg TIM_TIM23_TI4_COMP1_COMP2        TIM23_TI4 is connected to COMP2 output\r\n  *\r\n  *         For TIM24, the parameter can have the following values: (*)\r\n  *            @arg TIM_TIM24_TI1_GPIO               TIM24_TI1 is connected to GPIO\r\n  *            @arg TIM_TIM24_TI1_CAN_TMP            TIM24_TI1 is connected to CAN_TMP\r\n  *            @arg TIM_TIM24_TI1_CAN_RTP            TIM24_TI1 is connected to CAN_RTP\r\n  *            @arg TIM_TIM24_TI1_CAN_SOC            TIM24_TI1 is connected to CAN_SOC\r\n  *\r\n  *         (*)  Value not defined in all devices. \\n\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef  HAL_TIMEx_TISelection(TIM_HandleTypeDef *htim, uint32_t TISelection, uint32_t Channel)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_TIM_TISEL_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_TISEL(TISelection));\r\n\r\n  __HAL_LOCK(htim);\r\n\r\n  switch (Channel)\r\n  {\r\n    case TIM_CHANNEL_1:\r\n      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI1SEL, TISelection);\r\n      break;\r\n    case TIM_CHANNEL_2:\r\n      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI2SEL, TISelection);\r\n      break;\r\n    case TIM_CHANNEL_3:\r\n      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI3SEL, TISelection);\r\n      break;\r\n    case TIM_CHANNEL_4:\r\n      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI4SEL, TISelection);\r\n      break;\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Group channel 5 and channel 1, 2 or 3\r\n  * @param  htim TIM handle.\r\n  * @param  Channels specifies the reference signal(s) the OC5REF is combined with.\r\n  *         This parameter can be any combination of the following values:\r\n  *         TIM_GROUPCH5_NONE: No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC\r\n  *         TIM_GROUPCH5_OC1REFC: OC1REFC is the logical AND of OC1REFC and OC5REF\r\n  *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF\r\n  *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels)\r\n{\r\n  /* Check parameters */\r\n  assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_GROUPCH5(Channels));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(htim);\r\n\r\n  htim->State = HAL_TIM_STATE_BUSY;\r\n\r\n  /* Clear GC5Cx bit fields */\r\n  htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);\r\n\r\n  /* Set GC5Cx bit fields */\r\n  htim->Instance->CCR5 |= Channels;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n  __HAL_UNLOCK(htim);\r\n\r\n  return HAL_OK;\r\n}\r\n#if defined(TIM_BDTR_BKBID)\r\n\r\n/**\r\n  * @brief  Disarm the designated break input (when it operates in bidirectional mode).\r\n  * @param  htim TIM handle.\r\n  * @param  BreakInput Break input to disarm\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_BREAKINPUT_BRK: Timer break input\r\n  *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input\r\n  * @note  The break input can be disarmed only when it is configured in\r\n  *        bidirectional mode and when when MOE is reset.\r\n  * @note  Purpose is to be able to have the input voltage back to high-state,\r\n  *        whatever the time constant on the output .\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_DisarmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tmpbdtr;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_BREAKINPUT(BreakInput));\r\n\r\n  switch (BreakInput)\r\n  {\r\n    case TIM_BREAKINPUT_BRK:\r\n    {\r\n      /* Check initial conditions */\r\n      tmpbdtr = READ_REG(htim->Instance->BDTR);\r\n      if ((READ_BIT(tmpbdtr, TIM_BDTR_BKBID) == TIM_BDTR_BKBID) &&\r\n          (READ_BIT(tmpbdtr, TIM_BDTR_MOE) == 0U))\r\n      {\r\n        /* Break input BRK is disarmed */\r\n        SET_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM);\r\n      }\r\n      break;\r\n    }\r\n\r\n    case TIM_BREAKINPUT_BRK2:\r\n    {\r\n      /* Check initial conditions */\r\n      tmpbdtr = READ_REG(htim->Instance->BDTR);\r\n      if ((READ_BIT(tmpbdtr, TIM_BDTR_BK2BID) == TIM_BDTR_BK2BID) &&\r\n          (READ_BIT(tmpbdtr, TIM_BDTR_MOE) == 0U))\r\n      {\r\n        /* Break input BRK is disarmed */\r\n        SET_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM);\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Arm the designated break input (when it operates in bidirectional mode).\r\n  * @param  htim TIM handle.\r\n  * @param  BreakInput Break input to arm\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_BREAKINPUT_BRK: Timer break input\r\n  *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input\r\n  * @note  Arming is possible at anytime, even if fault is present.\r\n  * @note  Break input is automatically armed as soon as MOE bit is set.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_TIMEx_ReArmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tickstart;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));\r\n  assert_param(IS_TIM_BREAKINPUT(BreakInput));\r\n\r\n  switch (BreakInput)\r\n  {\r\n    case TIM_BREAKINPUT_BRK:\r\n    {\r\n      /* Check initial conditions */\r\n      if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKBID) == TIM_BDTR_BKBID)\r\n      {\r\n        /* Break input BRK is re-armed automatically by hardware. Poll to check whether fault condition disappeared */\r\n        /* Init tickstart for timeout management */\r\n        tickstart = HAL_GetTick();\r\n        while (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM) != 0UL)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > TIM_BREAKINPUT_REARM_TIMEOUT)\r\n          {\r\n            /* New check to avoid false timeout detection in case of preemption */\r\n            if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM) != 0UL)\r\n            {\r\n              return HAL_TIMEOUT;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    }\r\n\r\n    case TIM_BREAKINPUT_BRK2:\r\n    {\r\n      /* Check initial conditions */\r\n      if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2BID) == TIM_BDTR_BK2BID)\r\n      {\r\n        /* Break input BRK2 is re-armed automatically by hardware. Poll to check whether fault condition disappeared */\r\n        /* Init tickstart for timeout management */\r\n        tickstart = HAL_GetTick();\r\n        while (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM) != 0UL)\r\n        {\r\n          if ((HAL_GetTick() - tickstart) > TIM_BREAKINPUT_REARM_TIMEOUT)\r\n          {\r\n            /* New check to avoid false timeout detection in case of preemption */\r\n            if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM) != 0UL)\r\n            {\r\n              return HAL_TIMEOUT;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      status = HAL_ERROR;\r\n      break;\r\n  }\r\n\r\n  return status;\r\n}\r\n#endif /* TIM_BDTR_BKBID */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions\r\n  * @brief    Extended Callbacks functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                    ##### Extended Callbacks functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This section provides Extended TIM callback functions:\r\n    (+) Timer Commutation callback\r\n    (+) Timer Break callback\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Hall commutation changed callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_CommutCallback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @brief  Hall commutation changed half complete callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Break detection callback in non-blocking mode\r\n  * @param  htim TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_BreakCallback could be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Hall Break2 detection callback in non blocking mode\r\n  * @param  htim: TIM handle\r\n  * @retval None\r\n  */\r\n__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(htim);\r\n\r\n  /* NOTE : This function Should not be modified, when the callback is needed,\r\n            the HAL_TIMEx_Break2Callback could be implemented in the user file\r\n   */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions\r\n  * @brief    Extended Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n                ##### Extended Peripheral State functions #####\r\n  ==============================================================================\r\n  [..]\r\n    This subsection permits to get in run-time the status of the peripheral\r\n    and the data flow.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the TIM Hall Sensor interface handle state.\r\n  * @param  htim TIM Hall Sensor handle\r\n  * @retval HAL state\r\n  */\r\nHAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)\r\n{\r\n  return htim->State;\r\n}\r\n\r\n/**\r\n  * @brief  Return actual state of the TIM complementary channel.\r\n  * @param  htim TIM handle\r\n  * @param  ChannelN TIM Complementary channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  * @retval TIM Complementary channel state\r\n  */\r\nHAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(TIM_HandleTypeDef *htim,  uint32_t ChannelN)\r\n{\r\n  HAL_TIM_ChannelStateTypeDef channel_state;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN));\r\n\r\n  channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);\r\n\r\n  return channel_state;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private functions ---------------------------------------------------------*/\r\n/** @defgroup TIMEx_Private_Functions TIM Extended Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  TIM DMA Commutation callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->CommutationCallback(htim);\r\n#else\r\n  HAL_TIMEx_CommutCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA Commutation half complete callback.\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nvoid TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  /* Change the htim state */\r\n  htim->State = HAL_TIM_STATE_READY;\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->CommutationHalfCpltCallback(htim);\r\n#else\r\n  HAL_TIMEx_CommutHalfCpltCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  TIM DMA Delay Pulse complete callback (complementary channel).\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\r\n\r\n    if (hdma->Init.Mode == DMA_NORMAL)\r\n    {\r\n      TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->PWM_PulseFinishedCallback(htim);\r\n#else\r\n  HAL_TIM_PWM_PulseFinishedCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  TIM DMA error callback (complementary channel)\r\n  * @param  hdma pointer to DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma)\r\n{\r\n  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  if (hdma == htim->hdma[TIM_DMA_ID_CC1])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])\r\n  {\r\n    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\r\n    TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);\r\n  }\r\n  else\r\n  {\r\n    /* nothing to do */\r\n  }\r\n\r\n#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)\r\n  htim->ErrorCallback(htim);\r\n#else\r\n  HAL_TIM_ErrorCallback(htim);\r\n#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */\r\n\r\n  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\r\n}\r\n\r\n/**\r\n  * @brief  Enables or disables the TIM Capture Compare Channel xN.\r\n  * @param  TIMx to select the TIM peripheral\r\n  * @param  Channel specifies the TIM Channel\r\n  *          This parameter can be one of the following values:\r\n  *            @arg TIM_CHANNEL_1: TIM Channel 1\r\n  *            @arg TIM_CHANNEL_2: TIM Channel 2\r\n  *            @arg TIM_CHANNEL_3: TIM Channel 3\r\n  * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.\r\n  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.\r\n  * @retval None\r\n  */\r\nstatic void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)\r\n{\r\n  uint32_t tmp;\r\n\r\n  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */\r\n\r\n  /* Reset the CCxNE Bit */\r\n  TIMx->CCER &=  ~tmp;\r\n\r\n  /* Set or reset the CCxNE Bit */\r\n  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_TIM_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"},{"name":"stm32h7xx_hal_timebase_tim.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_timebase_TIM.c\r\n  * @brief   HAL time base based on the hardware TIM.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2026 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n#include \"stm32h7xx_hal_tim.h\"\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/* Private macro -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\nTIM_HandleTypeDef        htim1;\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* Private functions ---------------------------------------------------------*/\r\n\r\n/**\r\n  * @brief  This function configures the TIM1 as a time base source.\r\n  *         The time source is configured  to have 1ms time base with a dedicated\r\n  *         Tick interrupt priority.\r\n  * @note   This function is called  automatically at the beginning of program after\r\n  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().\r\n  * @param  TickPriority: Tick interrupt priority.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\r\n{\r\n  RCC_ClkInitTypeDef    clkconfig;\r\n  uint32_t              uwTimclock;\r\n\r\n  uint32_t              uwPrescalerValue;\r\n  uint32_t              pFLatency;\r\n/*Configure the TIM1 IRQ priority */\r\n  if (TickPriority < (1UL << __NVIC_PRIO_BITS))\r\n  {\r\n  HAL_NVIC_SetPriority(TIM1_UP_IRQn, TickPriority ,0U);\r\n\r\n  /* Enable the TIM1 global Interrupt */\r\n  HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);\r\n    uwTickPrio = TickPriority;\r\n    }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Enable TIM1 clock */\r\n  __HAL_RCC_TIM1_CLK_ENABLE();\r\n\r\n  /* Get clock configuration */\r\n  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);\r\n\r\n  /* Compute TIM1 clock */\r\n\r\n  uwTimclock = HAL_RCC_GetPCLK2Freq();\r\n\r\n  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */\r\n  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);\r\n\r\n  /* Initialize TIM1 */\r\n  htim1.Instance = TIM1;\r\n\r\n  /* Initialize TIMx peripheral as follow:\r\n  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.\r\n  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.\r\n  + ClockDivision = 0\r\n  + Counter direction = Up\r\n  */\r\n  htim1.Init.Period = (1000000U / 1000U) - 1U;\r\n  htim1.Init.Prescaler = uwPrescalerValue;\r\n  htim1.Init.ClockDivision = 0;\r\n  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;\r\n\r\n  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)\r\n  {\r\n    /* Start the TIM time Base generation in interrupt mode */\r\n    return HAL_TIM_Base_Start_IT(&htim1);\r\n  }\r\n\r\n  /* Return function status */\r\n  return HAL_ERROR;\r\n}\r\n\r\n/**\r\n  * @brief  Suspend Tick increment.\r\n  * @note   Disable the tick increment by disabling TIM1 update interrupt.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid HAL_SuspendTick(void)\r\n{\r\n  /* Disable TIM1 update Interrupt */\r\n  __HAL_TIM_DISABLE_IT(&htim1, TIM_IT_UPDATE);\r\n}\r\n\r\n/**\r\n  * @brief  Resume Tick increment.\r\n  * @note   Enable the tick increment by Enabling TIM1 update interrupt.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid HAL_ResumeTick(void)\r\n{\r\n  /* Enable TIM1 Update interrupt */\r\n  __HAL_TIM_ENABLE_IT(&htim1, TIM_IT_UPDATE);\r\n}\r\n\r\n"},{"name":"stm32h7xx_hal_uart.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_uart.c\r\n  * @author  MCD Application Team\r\n  * @brief   UART HAL module driver.\r\n  *          This file provides firmware functions to manage the following\r\n  *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).\r\n  *           + Initialization and de-initialization functions\r\n  *           + IO operation functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n ===============================================================================\r\n                        ##### How to use this driver #####\r\n ===============================================================================\r\n  [..]\r\n    The UART HAL driver can be used as follows:\r\n\r\n    (#) Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart).\r\n    (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:\r\n        (++) Enable the USARTx interface clock.\r\n        (++) UART pins configuration:\r\n            (+++) Enable the clock for the UART GPIOs.\r\n            (+++) Configure these UART pins as alternate function pull-up.\r\n        (++) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()\r\n             and HAL_UART_Receive_IT() APIs):\r\n            (+++) Configure the USARTx interrupt priority.\r\n            (+++) Enable the NVIC USART IRQ handle.\r\n        (++) UART interrupts handling:\r\n              -@@-  The specific UART interrupts (Transmission complete interrupt,\r\n                RXNE interrupt, RX/TX FIFOs related interrupts and Error Interrupts)\r\n                are managed using the macros __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT()\r\n                inside the transmit and receive processes.\r\n        (++) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()\r\n             and HAL_UART_Receive_DMA() APIs):\r\n            (+++) Declare a DMA handle structure for the Tx/Rx channel.\r\n            (+++) Enable the DMAx interface clock.\r\n            (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.\r\n            (+++) Configure the DMA Tx/Rx channel.\r\n            (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.\r\n            (+++) Configure the priority and enable the NVIC for the transfer complete\r\n                  interrupt on the DMA Tx/Rx channel.\r\n\r\n    (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Prescaler value , Hardware\r\n        flow control and Mode (Receiver/Transmitter) in the huart handle Init structure.\r\n\r\n    (#) If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,...)\r\n        in the huart handle AdvancedInit structure.\r\n\r\n    (#) For the UART asynchronous mode, initialize the UART registers by calling\r\n        the HAL_UART_Init() API.\r\n\r\n    (#) For the UART Half duplex mode, initialize the UART registers by calling\r\n        the HAL_HalfDuplex_Init() API.\r\n\r\n    (#) For the UART LIN (Local Interconnection Network) mode, initialize the UART registers\r\n        by calling the HAL_LIN_Init() API.\r\n\r\n    (#) For the UART Multiprocessor mode, initialize the UART registers\r\n        by calling the HAL_MultiProcessor_Init() API.\r\n\r\n    (#) For the UART RS485 Driver Enabled mode, initialize the UART registers\r\n        by calling the HAL_RS485Ex_Init() API.\r\n\r\n    [..]\r\n    (@) These API's (HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init(), HAL_MultiProcessor_Init(),\r\n        also configure the low level Hardware GPIO, CLOCK, CORTEX...etc) by\r\n        calling the customized HAL_UART_MspInit() API.\r\n\r\n    ##### Callback registration #####\r\n    ==================================\r\n\r\n    [..]\r\n    The compilation define USE_HAL_UART_REGISTER_CALLBACKS when set to 1\r\n    allows the user to configure dynamically the driver callbacks.\r\n\r\n    [..]\r\n    Use Function HAL_UART_RegisterCallback() to register a user callback.\r\n    Function HAL_UART_RegisterCallback() allows to register following callbacks:\r\n    (+) TxHalfCpltCallback        : Tx Half Complete Callback.\r\n    (+) TxCpltCallback            : Tx Complete Callback.\r\n    (+) RxHalfCpltCallback        : Rx Half Complete Callback.\r\n    (+) RxCpltCallback            : Rx Complete Callback.\r\n    (+) ErrorCallback             : Error Callback.\r\n    (+) AbortCpltCallback         : Abort Complete Callback.\r\n    (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.\r\n    (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.\r\n    (+) WakeupCallback            : Wakeup Callback.\r\n    (+) RxFifoFullCallback        : Rx Fifo Full Callback.\r\n    (+) TxFifoEmptyCallback       : Tx Fifo Empty Callback.\r\n    (+) MspInitCallback           : UART MspInit.\r\n    (+) MspDeInitCallback         : UART MspDeInit.\r\n    This function takes as parameters the HAL peripheral handle, the Callback ID\r\n    and a pointer to the user callback function.\r\n\r\n    [..]\r\n    Use function HAL_UART_UnRegisterCallback() to reset a callback to the default\r\n    weak (surcharged) function.\r\n    HAL_UART_UnRegisterCallback() takes as parameters the HAL peripheral handle,\r\n    and the Callback ID.\r\n    This function allows to reset following callbacks:\r\n    (+) TxHalfCpltCallback        : Tx Half Complete Callback.\r\n    (+) TxCpltCallback            : Tx Complete Callback.\r\n    (+) RxHalfCpltCallback        : Rx Half Complete Callback.\r\n    (+) RxCpltCallback            : Rx Complete Callback.\r\n    (+) ErrorCallback             : Error Callback.\r\n    (+) AbortCpltCallback         : Abort Complete Callback.\r\n    (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.\r\n    (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.\r\n    (+) WakeupCallback            : Wakeup Callback.\r\n    (+) RxFifoFullCallback        : Rx Fifo Full Callback.\r\n    (+) TxFifoEmptyCallback       : Tx Fifo Empty Callback.\r\n    (+) MspInitCallback           : UART MspInit.\r\n    (+) MspDeInitCallback         : UART MspDeInit.\r\n\r\n    [..]\r\n    For specific callback RxEventCallback, use dedicated registration/reset functions:\r\n    respectively HAL_UART_RegisterRxEventCallback() , HAL_UART_UnRegisterRxEventCallback().\r\n\r\n    [..]\r\n    By default, after the HAL_UART_Init() and when the state is HAL_UART_STATE_RESET\r\n    all callbacks are set to the corresponding weak (surcharged) functions:\r\n    examples HAL_UART_TxCpltCallback(), HAL_UART_RxHalfCpltCallback().\r\n    Exception done for MspInit and MspDeInit functions that are respectively\r\n    reset to the legacy weak (surcharged) functions in the HAL_UART_Init()\r\n    and HAL_UART_DeInit() only when these callbacks are null (not registered beforehand).\r\n    If not, MspInit or MspDeInit are not null, the HAL_UART_Init() and HAL_UART_DeInit()\r\n    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).\r\n\r\n    [..]\r\n    Callbacks can be registered/unregistered in HAL_UART_STATE_READY state only.\r\n    Exception done MspInit/MspDeInit that can be registered/unregistered\r\n    in HAL_UART_STATE_READY or HAL_UART_STATE_RESET state, thus registered (user)\r\n    MspInit/DeInit callbacks can be used during the Init/DeInit.\r\n    In that case first register the MspInit/MspDeInit user callbacks\r\n    using HAL_UART_RegisterCallback() before calling HAL_UART_DeInit()\r\n    or HAL_UART_Init() function.\r\n\r\n    [..]\r\n    When The compilation define USE_HAL_UART_REGISTER_CALLBACKS is set to 0 or\r\n    not defined, the callback registration feature is not available\r\n    and weak (surcharged) callbacks are used.\r\n\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup UART UART\r\n  * @brief HAL UART module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_UART_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @defgroup UART_Private_Constants UART Private Constants\r\n  * @{\r\n  */\r\n#define USART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | \\\r\n                                      USART_CR1_OVER8 | USART_CR1_FIFOEN)) /*!< UART or USART CR1 fields of parameters set by UART_SetConfig API */\r\n\r\n#define USART_CR3_FIELDS  ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT | USART_CR3_TXFTCFG | \\\r\n                                      USART_CR3_RXFTCFG)) /*!< UART or USART CR3 fields of parameters set by UART_SetConfig API */\r\n\r\n#define LPUART_BRR_MIN  0x00000300U  /* LPUART BRR minimum authorized value */\r\n#define LPUART_BRR_MAX  0x000FFFFFU  /* LPUART BRR maximum authorized value */\r\n\r\n#define UART_BRR_MIN    0x10U        /* UART BRR minimum authorized value */\r\n#define UART_BRR_MAX    0x0000FFFFU  /* UART BRR maximum authorized value */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @addtogroup UART_Private_Functions\r\n  * @{\r\n  */\r\nstatic void UART_EndTxTransfer(UART_HandleTypeDef *huart);\r\nstatic void UART_EndRxTransfer(UART_HandleTypeDef *huart);\r\nstatic void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMAError(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma);\r\nstatic void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma);\r\nstatic void UART_TxISR_8BIT(UART_HandleTypeDef *huart);\r\nstatic void UART_TxISR_16BIT(UART_HandleTypeDef *huart);\r\nstatic void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart);\r\nstatic void UART_TxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart);\r\nstatic void UART_EndTransmit_IT(UART_HandleTypeDef *huart);\r\nstatic void UART_RxISR_8BIT(UART_HandleTypeDef *huart);\r\nstatic void UART_RxISR_16BIT(UART_HandleTypeDef *huart);\r\nstatic void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart);\r\nstatic void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/** @addtogroup UART_Private_variables\r\n  * @{\r\n  */\r\nconst uint16_t UARTPrescTable[12] = {1U, 2U, 4U, 6U, 8U, 10U, 12U, 16U, 32U, 64U, 128U, 256U};\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported Constants --------------------------------------------------------*/\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup UART_Exported_Functions UART Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  *  @brief    Initialization and Configuration functions\r\n  *\r\n@verbatim\r\n===============================================================================\r\n            ##### Initialization and Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to initialize the USARTx or the UARTy\r\n    in asynchronous mode.\r\n      (+) For the asynchronous mode the parameters below can be configured:\r\n        (++) Baud Rate\r\n        (++) Word Length\r\n        (++) Stop Bit\r\n        (++) Parity: If the parity is enabled, then the MSB bit of the data written\r\n             in the data register is transmitted but is changed by the parity bit.\r\n        (++) Hardware flow control\r\n        (++) Receiver/transmitter modes\r\n        (++) Over Sampling Method\r\n        (++) One-Bit Sampling Method\r\n      (+) For the asynchronous mode, the following advanced features can be configured as well:\r\n        (++) TX and/or RX pin level inversion\r\n        (++) data logical level inversion\r\n        (++) RX and TX pins swap\r\n        (++) RX overrun detection disabling\r\n        (++) DMA disabling on RX error\r\n        (++) MSB first on communication line\r\n        (++) auto Baud rate detection\r\n    [..]\r\n    The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init()and HAL_MultiProcessor_Init()API\r\n    follow respectively the UART asynchronous, UART Half duplex, UART LIN mode\r\n    and UART multiprocessor mode configuration procedures (details for the procedures\r\n    are available in reference manual).\r\n\r\n@endverbatim\r\n\r\n  Depending on the frame length defined by the M1 and M0 bits (7-bit,\r\n  8-bit or 9-bit), the possible UART formats are listed in the\r\n  following table.\r\n\r\n  Table 1. UART frame format.\r\n    +-----------------------------------------------------------------------+\r\n    |  M1 bit |  M0 bit |  PCE bit  |             UART frame                |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |\r\n    +-----------------------------------------------------------------------+\r\n\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Initialize the UART mode according to the specified\r\n  *        parameters in the UART_InitTypeDef and initialize the associated handle.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)\r\n{\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)\r\n  {\r\n    /* Check the parameters */\r\n    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));\r\n  }\r\n  else\r\n  {\r\n    /* Check the parameters */\r\n    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));\r\n  }\r\n\r\n  if (huart->gState == HAL_UART_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    huart->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    UART_InitCallbacksToDefault(huart);\r\n\r\n    if (huart->MspInitCallback == NULL)\r\n    {\r\n      huart->MspInitCallback = HAL_UART_MspInit;\r\n    }\r\n\r\n    /* Init the low level hardware */\r\n    huart->MspInitCallback(huart);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK */\r\n    HAL_UART_MspInit(huart);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n  }\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the UART Communication parameters */\r\n  if (UART_SetConfig(huart) == HAL_ERROR)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)\r\n  {\r\n    UART_AdvFeatureConfig(huart);\r\n  }\r\n\r\n  /* In asynchronous mode, the following bits must be kept cleared:\r\n  - LINEN and CLKEN bits in the USART_CR2 register,\r\n  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/\r\n  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));\r\n  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));\r\n\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n/**\r\n  * @brief Initialize the half-duplex mode according to the specified\r\n  *        parameters in the UART_InitTypeDef and creates the associated handle.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)\r\n{\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check UART instance */\r\n  assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));\r\n\r\n  if (huart->gState == HAL_UART_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    huart->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    UART_InitCallbacksToDefault(huart);\r\n\r\n    if (huart->MspInitCallback == NULL)\r\n    {\r\n      huart->MspInitCallback = HAL_UART_MspInit;\r\n    }\r\n\r\n    /* Init the low level hardware */\r\n    huart->MspInitCallback(huart);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK */\r\n    HAL_UART_MspInit(huart);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n  }\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the UART Communication parameters */\r\n  if (UART_SetConfig(huart) == HAL_ERROR)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)\r\n  {\r\n    UART_AdvFeatureConfig(huart);\r\n  }\r\n\r\n  /* In half-duplex mode, the following bits must be kept cleared:\r\n  - LINEN and CLKEN bits in the USART_CR2 register,\r\n  - SCEN and IREN bits in the USART_CR3 register.*/\r\n  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));\r\n  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));\r\n\r\n  /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */\r\n  SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);\r\n\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n\r\n/**\r\n  * @brief Initialize the LIN mode according to the specified\r\n  *        parameters in the UART_InitTypeDef and creates the associated handle.\r\n  * @param huart             UART handle.\r\n  * @param BreakDetectLength Specifies the LIN break detection length.\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref UART_LINBREAKDETECTLENGTH_10B 10-bit break detection\r\n  *          @arg @ref UART_LINBREAKDETECTLENGTH_11B 11-bit break detection\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)\r\n{\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the LIN UART instance */\r\n  assert_param(IS_UART_LIN_INSTANCE(huart->Instance));\r\n  /* Check the Break detection length parameter */\r\n  assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));\r\n\r\n  /* LIN mode limited to 16-bit oversampling only */\r\n  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  /* LIN mode limited to 8-bit data length */\r\n  if (huart->Init.WordLength != UART_WORDLENGTH_8B)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->gState == HAL_UART_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    huart->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    UART_InitCallbacksToDefault(huart);\r\n\r\n    if (huart->MspInitCallback == NULL)\r\n    {\r\n      huart->MspInitCallback = HAL_UART_MspInit;\r\n    }\r\n\r\n    /* Init the low level hardware */\r\n    huart->MspInitCallback(huart);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK */\r\n    HAL_UART_MspInit(huart);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n  }\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the UART Communication parameters */\r\n  if (UART_SetConfig(huart) == HAL_ERROR)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)\r\n  {\r\n    UART_AdvFeatureConfig(huart);\r\n  }\r\n\r\n  /* In LIN mode, the following bits must be kept cleared:\r\n  - LINEN and CLKEN bits in the USART_CR2 register,\r\n  - SCEN and IREN bits in the USART_CR3 register.*/\r\n  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);\r\n  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));\r\n\r\n  /* Enable the LIN mode by setting the LINEN bit in the CR2 register */\r\n  SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);\r\n\r\n  /* Set the USART LIN Break detection length. */\r\n  MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);\r\n\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n\r\n/**\r\n  * @brief Initialize the multiprocessor mode according to the specified\r\n  *        parameters in the UART_InitTypeDef and initialize the associated handle.\r\n  * @param huart        UART handle.\r\n  * @param Address      UART node address (4-, 6-, 7- or 8-bit long).\r\n  * @param WakeUpMethod Specifies the UART wakeup method.\r\n  *        This parameter can be one of the following values:\r\n  *          @arg @ref UART_WAKEUPMETHOD_IDLELINE WakeUp by an idle line detection\r\n  *          @arg @ref UART_WAKEUPMETHOD_ADDRESSMARK WakeUp by an address mark\r\n  * @note  If the user resorts to idle line detection wake up, the Address parameter\r\n  *        is useless and ignored by the initialization function.\r\n  * @note  If the user resorts to address mark wake up, the address length detection\r\n  *        is configured by default to 4 bits only. For the UART to be able to\r\n  *        manage 6-, 7- or 8-bit long addresses detection, the API\r\n  *        HAL_MultiProcessorEx_AddressLength_Set() must be called after\r\n  *        HAL_MultiProcessor_Init().\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)\r\n{\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the wake up method parameter */\r\n  assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));\r\n\r\n  if (huart->gState == HAL_UART_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    huart->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    UART_InitCallbacksToDefault(huart);\r\n\r\n    if (huart->MspInitCallback == NULL)\r\n    {\r\n      huart->MspInitCallback = HAL_UART_MspInit;\r\n    }\r\n\r\n    /* Init the low level hardware */\r\n    huart->MspInitCallback(huart);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK */\r\n    HAL_UART_MspInit(huart);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n  }\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the UART Communication parameters */\r\n  if (UART_SetConfig(huart) == HAL_ERROR)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)\r\n  {\r\n    UART_AdvFeatureConfig(huart);\r\n  }\r\n\r\n  /* In multiprocessor mode, the following bits must be kept cleared:\r\n  - LINEN and CLKEN bits in the USART_CR2 register,\r\n  - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */\r\n  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));\r\n  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));\r\n\r\n  if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)\r\n  {\r\n    /* If address mark wake up method is chosen, set the USART address node */\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));\r\n  }\r\n\r\n  /* Set the wake up method by setting the WAKE bit in the CR1 register */\r\n  MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);\r\n\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n\r\n/**\r\n  * @brief DeInitialize the UART peripheral.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)\r\n{\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the parameters */\r\n  assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  huart->Instance->CR1 = 0x0U;\r\n  huart->Instance->CR2 = 0x0U;\r\n  huart->Instance->CR3 = 0x0U;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  if (huart->MspDeInitCallback == NULL)\r\n  {\r\n    huart->MspDeInitCallback = HAL_UART_MspDeInit;\r\n  }\r\n  /* DeInit the low level hardware */\r\n  huart->MspDeInitCallback(huart);\r\n#else\r\n  /* DeInit the low level hardware */\r\n  HAL_UART_MspDeInit(huart);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n  huart->gState = HAL_UART_STATE_RESET;\r\n  huart->RxState = HAL_UART_STATE_RESET;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Initialize the UART MSP.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_MspInit can be implemented in the user file\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief DeInitialize the UART MSP.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_MspDeInit can be implemented in the user file\r\n   */\r\n}\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n/**\r\n  * @brief  Register a User UART Callback\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  huart uart handle\r\n  * @param  CallbackID ID of the callback to be registered\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID\r\n  *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID\r\n  *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID\r\n  *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID\r\n  *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID\r\n  *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID\r\n  *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID\r\n  *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID\r\n  *           @arg @ref HAL_UART_WAKEUP_CB_ID Wakeup Callback ID\r\n  *           @arg @ref HAL_UART_RX_FIFO_FULL_CB_ID Rx Fifo Full Callback ID\r\n  *           @arg @ref HAL_UART_TX_FIFO_EMPTY_CB_ID Tx Fifo Empty Callback ID\r\n  *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID\r\n  *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID\r\n  * @param  pCallback pointer to the Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_RegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID,\r\n                                            pUART_CallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  __HAL_LOCK(huart);\r\n\r\n  if (huart->gState == HAL_UART_STATE_READY)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_UART_TX_HALFCOMPLETE_CB_ID :\r\n        huart->TxHalfCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_TX_COMPLETE_CB_ID :\r\n        huart->TxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_RX_HALFCOMPLETE_CB_ID :\r\n        huart->RxHalfCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_RX_COMPLETE_CB_ID :\r\n        huart->RxCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_ERROR_CB_ID :\r\n        huart->ErrorCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_ABORT_COMPLETE_CB_ID :\r\n        huart->AbortCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :\r\n        huart->AbortTransmitCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :\r\n        huart->AbortReceiveCpltCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_WAKEUP_CB_ID :\r\n        huart->WakeupCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_RX_FIFO_FULL_CB_ID :\r\n        huart->RxFifoFullCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_TX_FIFO_EMPTY_CB_ID :\r\n        huart->TxFifoEmptyCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_MSPINIT_CB_ID :\r\n        huart->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_MSPDEINIT_CB_ID :\r\n        huart->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (huart->gState == HAL_UART_STATE_RESET)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_UART_MSPINIT_CB_ID :\r\n        huart->MspInitCallback = pCallback;\r\n        break;\r\n\r\n      case HAL_UART_MSPDEINIT_CB_ID :\r\n        huart->MspDeInitCallback = pCallback;\r\n        break;\r\n\r\n      default :\r\n        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Unregister an UART Callback\r\n  *         UART callaback is redirected to the weak predefined callback\r\n  * @param  huart uart handle\r\n  * @param  CallbackID ID of the callback to be unregistered\r\n  *         This parameter can be one of the following values:\r\n  *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID\r\n  *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID\r\n  *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID\r\n  *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID\r\n  *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID\r\n  *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID\r\n  *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID\r\n  *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID\r\n  *           @arg @ref HAL_UART_WAKEUP_CB_ID Wakeup Callback ID\r\n  *           @arg @ref HAL_UART_RX_FIFO_FULL_CB_ID Rx Fifo Full Callback ID\r\n  *           @arg @ref HAL_UART_TX_FIFO_EMPTY_CB_ID Tx Fifo Empty Callback ID\r\n  *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID\r\n  *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_UnRegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  __HAL_LOCK(huart);\r\n\r\n  if (HAL_UART_STATE_READY == huart->gState)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_UART_TX_HALFCOMPLETE_CB_ID :\r\n        huart->TxHalfCpltCallback = HAL_UART_TxHalfCpltCallback;               /* Legacy weak  TxHalfCpltCallback    */\r\n        break;\r\n\r\n      case HAL_UART_TX_COMPLETE_CB_ID :\r\n        huart->TxCpltCallback = HAL_UART_TxCpltCallback;                       /* Legacy weak TxCpltCallback         */\r\n        break;\r\n\r\n      case HAL_UART_RX_HALFCOMPLETE_CB_ID :\r\n        huart->RxHalfCpltCallback = HAL_UART_RxHalfCpltCallback;               /* Legacy weak RxHalfCpltCallback     */\r\n        break;\r\n\r\n      case HAL_UART_RX_COMPLETE_CB_ID :\r\n        huart->RxCpltCallback = HAL_UART_RxCpltCallback;                       /* Legacy weak RxCpltCallback         */\r\n        break;\r\n\r\n      case HAL_UART_ERROR_CB_ID :\r\n        huart->ErrorCallback = HAL_UART_ErrorCallback;                         /* Legacy weak ErrorCallback          */\r\n        break;\r\n\r\n      case HAL_UART_ABORT_COMPLETE_CB_ID :\r\n        huart->AbortCpltCallback = HAL_UART_AbortCpltCallback;                 /* Legacy weak AbortCpltCallback      */\r\n        break;\r\n\r\n      case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :\r\n        huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak\r\n                                                                                  AbortTransmitCpltCallback          */\r\n        break;\r\n\r\n      case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :\r\n        huart->AbortReceiveCpltCallback = HAL_UART_AbortReceiveCpltCallback;   /* Legacy weak\r\n                                                                                  AbortReceiveCpltCallback           */\r\n        break;\r\n\r\n      case HAL_UART_WAKEUP_CB_ID :\r\n        huart->WakeupCallback = HAL_UARTEx_WakeupCallback;                     /* Legacy weak WakeupCallback         */\r\n        break;\r\n\r\n      case HAL_UART_RX_FIFO_FULL_CB_ID :\r\n        huart->RxFifoFullCallback = HAL_UARTEx_RxFifoFullCallback;             /* Legacy weak RxFifoFullCallback     */\r\n        break;\r\n\r\n      case HAL_UART_TX_FIFO_EMPTY_CB_ID :\r\n        huart->TxFifoEmptyCallback = HAL_UARTEx_TxFifoEmptyCallback;           /* Legacy weak TxFifoEmptyCallback    */\r\n        break;\r\n\r\n      case HAL_UART_MSPINIT_CB_ID :\r\n        huart->MspInitCallback = HAL_UART_MspInit;                             /* Legacy weak MspInitCallback        */\r\n        break;\r\n\r\n      case HAL_UART_MSPDEINIT_CB_ID :\r\n        huart->MspDeInitCallback = HAL_UART_MspDeInit;                         /* Legacy weak MspDeInitCallback      */\r\n        break;\r\n\r\n      default :\r\n        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else if (HAL_UART_STATE_RESET == huart->gState)\r\n  {\r\n    switch (CallbackID)\r\n    {\r\n      case HAL_UART_MSPINIT_CB_ID :\r\n        huart->MspInitCallback = HAL_UART_MspInit;\r\n        break;\r\n\r\n      case HAL_UART_MSPDEINIT_CB_ID :\r\n        huart->MspDeInitCallback = HAL_UART_MspDeInit;\r\n        break;\r\n\r\n      default :\r\n        huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n        status =  HAL_ERROR;\r\n        break;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Register a User UART Rx Event Callback\r\n  *         To be used instead of the weak predefined callback\r\n  * @param  huart     Uart handle\r\n  * @param  pCallback Pointer to the Rx Event Callback function\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_RegisterRxEventCallback(UART_HandleTypeDef *huart, pUART_RxEventCallbackTypeDef pCallback)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  if (pCallback == NULL)\r\n  {\r\n    huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  if (huart->gState == HAL_UART_STATE_READY)\r\n  {\r\n    huart->RxEventCallback = pCallback;\r\n  }\r\n  else\r\n  {\r\n    huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  UnRegister the UART Rx Event Callback\r\n  *         UART Rx Event Callback is redirected to the weak HAL_UARTEx_RxEventCallback() predefined callback\r\n  * @param  huart     Uart handle\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_UnRegisterRxEventCallback(UART_HandleTypeDef *huart)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n\r\n  /* Process locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  if (huart->gState == HAL_UART_STATE_READY)\r\n  {\r\n    huart->RxEventCallback = HAL_UARTEx_RxEventCallback; /* Legacy weak UART Rx Event Callback  */\r\n  }\r\n  else\r\n  {\r\n    huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;\r\n\r\n    status =  HAL_ERROR;\r\n  }\r\n\r\n  /* Release Lock */\r\n  __HAL_UNLOCK(huart);\r\n  return status;\r\n}\r\n\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup UART_Exported_Functions_Group2 IO operation functions\r\n  * @brief UART Transmit/Receive functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n    This subsection provides a set of functions allowing to manage the UART asynchronous\r\n    and Half duplex data transfers.\r\n\r\n    (#) There are two mode of transfer:\r\n       (+) Blocking mode: The communication is performed in polling mode.\r\n           The HAL status of all data processing is returned by the same function\r\n           after finishing transfer.\r\n       (+) Non-Blocking mode: The communication is performed using Interrupts\r\n           or DMA, These API's return the HAL status.\r\n           The end of the data processing will be indicated through the\r\n           dedicated UART IRQ when using Interrupt mode or the DMA IRQ when\r\n           using DMA mode.\r\n           The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks\r\n           will be executed respectively at the end of the transmit or Receive process\r\n           The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected\r\n\r\n    (#) Blocking mode API's are :\r\n        (+) HAL_UART_Transmit()\r\n        (+) HAL_UART_Receive()\r\n\r\n    (#) Non-Blocking mode API's with Interrupt are :\r\n        (+) HAL_UART_Transmit_IT()\r\n        (+) HAL_UART_Receive_IT()\r\n        (+) HAL_UART_IRQHandler()\r\n\r\n    (#) Non-Blocking mode API's with DMA are :\r\n        (+) HAL_UART_Transmit_DMA()\r\n        (+) HAL_UART_Receive_DMA()\r\n        (+) HAL_UART_DMAPause()\r\n        (+) HAL_UART_DMAResume()\r\n        (+) HAL_UART_DMAStop()\r\n\r\n    (#) A set of Transfer Complete Callbacks are provided in Non_Blocking mode:\r\n        (+) HAL_UART_TxHalfCpltCallback()\r\n        (+) HAL_UART_TxCpltCallback()\r\n        (+) HAL_UART_RxHalfCpltCallback()\r\n        (+) HAL_UART_RxCpltCallback()\r\n        (+) HAL_UART_ErrorCallback()\r\n\r\n    (#) Non-Blocking mode transfers could be aborted using Abort API's :\r\n        (+) HAL_UART_Abort()\r\n        (+) HAL_UART_AbortTransmit()\r\n        (+) HAL_UART_AbortReceive()\r\n        (+) HAL_UART_Abort_IT()\r\n        (+) HAL_UART_AbortTransmit_IT()\r\n        (+) HAL_UART_AbortReceive_IT()\r\n\r\n    (#) For Abort services based on interrupts (HAL_UART_Abortxxx_IT), a set of Abort Complete Callbacks are provided:\r\n        (+) HAL_UART_AbortCpltCallback()\r\n        (+) HAL_UART_AbortTransmitCpltCallback()\r\n        (+) HAL_UART_AbortReceiveCpltCallback()\r\n\r\n    (#) A Rx Event Reception Callback (Rx event notification) is available for Non_Blocking modes of enhanced\r\n        reception services:\r\n        (+) HAL_UARTEx_RxEventCallback()\r\n\r\n    (#) In Non-Blocking mode transfers, possible errors are split into 2 categories.\r\n        Errors are handled as follows :\r\n       (+) Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is\r\n           to be evaluated by user : this concerns Frame Error, Parity Error or Noise Error\r\n           in Interrupt mode reception .\r\n           Received character is then retrieved and stored in Rx buffer, Error code is set to allow user\r\n           to identify error type, and HAL_UART_ErrorCallback() user callback is executed.\r\n           Transfer is kept ongoing on UART side.\r\n           If user wants to abort it, Abort services should be called by user.\r\n       (+) Error is considered as Blocking : Transfer could not be completed properly and is aborted.\r\n           This concerns Overrun Error In Interrupt mode reception and all errors in DMA mode.\r\n           Error code is set to allow user to identify error type, and HAL_UART_ErrorCallback()\r\n           user callback is executed.\r\n\r\n    -@- In the Half duplex communication, it is forbidden to run the transmit\r\n        and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Send an amount of data in blocking mode.\r\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *         the sent data is handled as a set of u16. In this case, Size must indicate the number\r\n  *         of u16 provided through pData.\r\n  * @note When FIFO mode is enabled, writing a data in the TDR register adds one\r\n  *       data to the TXFIFO. Write operations to the TDR register are performed\r\n  *       when TXFNF flag is set. From hardware perspective, TXFNF flag and\r\n  *       TXE are mapped on the same bit-field.\r\n  * @param huart   UART handle.\r\n  * @param pData   Pointer to data buffer (u8 or u16 data elements).\r\n  * @param Size    Amount of data elements (u8 or u16) to be sent.\r\n  * @param Timeout Timeout duration.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  const uint8_t  *pdata8bits;\r\n  const uint16_t *pdata16bits;\r\n  uint32_t tickstart;\r\n\r\n  /* Check that a Tx process is not already ongoing */\r\n  if (huart->gState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n    huart->gState = HAL_UART_STATE_BUSY_TX;\r\n\r\n    /* Init tickstart for timeout management */\r\n    tickstart = HAL_GetTick();\r\n\r\n    huart->TxXferSize  = Size;\r\n    huart->TxXferCount = Size;\r\n\r\n    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */\r\n    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n    {\r\n      pdata8bits  = NULL;\r\n      pdata16bits = (const uint16_t *) pData;\r\n    }\r\n    else\r\n    {\r\n      pdata8bits  = pData;\r\n      pdata16bits = NULL;\r\n    }\r\n\r\n    __HAL_UNLOCK(huart);\r\n\r\n    while (huart->TxXferCount > 0U)\r\n    {\r\n      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n      if (pdata8bits == NULL)\r\n      {\r\n        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);\r\n        pdata16bits++;\r\n      }\r\n      else\r\n      {\r\n        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);\r\n        pdata8bits++;\r\n      }\r\n      huart->TxXferCount--;\r\n    }\r\n\r\n    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)\r\n    {\r\n      return HAL_TIMEOUT;\r\n    }\r\n\r\n    /* At end of Tx process, restore huart->gState to Ready */\r\n    huart->gState = HAL_UART_STATE_READY;\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Receive an amount of data in blocking mode.\r\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *         the received data is handled as a set of u16. In this case, Size must indicate the number\r\n  *         of u16 available through pData.\r\n  * @note When FIFO mode is enabled, the RXFNE flag is set as long as the RXFIFO\r\n  *       is not empty. Read operations from the RDR register are performed when\r\n  *       RXFNE flag is set. From hardware perspective, RXFNE flag and\r\n  *       RXNE are mapped on the same bit-field.\r\n  * @param huart   UART handle.\r\n  * @param pData   Pointer to data buffer (u8 or u16 data elements).\r\n  * @param Size    Amount of data elements (u8 or u16) to be received.\r\n  * @param Timeout Timeout duration.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)\r\n{\r\n  uint8_t  *pdata8bits;\r\n  uint16_t *pdata16bits;\r\n  uint16_t uhMask;\r\n  uint32_t tickstart;\r\n\r\n  /* Check that a Rx process is not already ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n    huart->RxState = HAL_UART_STATE_BUSY_RX;\r\n    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n    /* Init tickstart for timeout management */\r\n    tickstart = HAL_GetTick();\r\n\r\n    huart->RxXferSize  = Size;\r\n    huart->RxXferCount = Size;\r\n\r\n    /* Computation of UART mask to apply to RDR register */\r\n    UART_MASK_COMPUTATION(huart);\r\n    uhMask = huart->Mask;\r\n\r\n    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */\r\n    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n    {\r\n      pdata8bits  = NULL;\r\n      pdata16bits = (uint16_t *) pData;\r\n    }\r\n    else\r\n    {\r\n      pdata8bits  = pData;\r\n      pdata16bits = NULL;\r\n    }\r\n\r\n    __HAL_UNLOCK(huart);\r\n\r\n    /* as long as data have to be received */\r\n    while (huart->RxXferCount > 0U)\r\n    {\r\n      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)\r\n      {\r\n        return HAL_TIMEOUT;\r\n      }\r\n      if (pdata8bits == NULL)\r\n      {\r\n        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);\r\n        pdata16bits++;\r\n      }\r\n      else\r\n      {\r\n        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);\r\n        pdata8bits++;\r\n      }\r\n      huart->RxXferCount--;\r\n    }\r\n\r\n    /* At end of Rx process, restore huart->RxState to Ready */\r\n    huart->RxState = HAL_UART_STATE_READY;\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Send an amount of data in interrupt mode.\r\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *         the sent data is handled as a set of u16. In this case, Size must indicate the number\r\n  *         of u16 provided through pData.\r\n  * @param huart UART handle.\r\n  * @param pData Pointer to data buffer (u8 or u16 data elements).\r\n  * @param Size  Amount of data elements (u8 or u16) to be sent.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)\r\n{\r\n  /* Check that a Tx process is not already ongoing */\r\n  if (huart->gState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    huart->pTxBuffPtr  = pData;\r\n    huart->TxXferSize  = Size;\r\n    huart->TxXferCount = Size;\r\n    huart->TxISR       = NULL;\r\n\r\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n    huart->gState = HAL_UART_STATE_BUSY_TX;\r\n\r\n    /* Configure Tx interrupt processing */\r\n    if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n    {\r\n      /* Set the Tx ISR function pointer according to the data word length */\r\n      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n      {\r\n        huart->TxISR = UART_TxISR_16BIT_FIFOEN;\r\n      }\r\n      else\r\n      {\r\n        huart->TxISR = UART_TxISR_8BIT_FIFOEN;\r\n      }\r\n\r\n      __HAL_UNLOCK(huart);\r\n\r\n      /* Enable the TX FIFO threshold interrupt */\r\n      ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\r\n    }\r\n    else\r\n    {\r\n      /* Set the Tx ISR function pointer according to the data word length */\r\n      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n      {\r\n        huart->TxISR = UART_TxISR_16BIT;\r\n      }\r\n      else\r\n      {\r\n        huart->TxISR = UART_TxISR_8BIT;\r\n      }\r\n\r\n      __HAL_UNLOCK(huart);\r\n\r\n      /* Enable the Transmit Data Register Empty interrupt */\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);\r\n    }\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Receive an amount of data in interrupt mode.\r\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *         the received data is handled as a set of u16. In this case, Size must indicate the number\r\n  *         of u16 available through pData.\r\n  * @param huart UART handle.\r\n  * @param pData Pointer to data buffer (u8 or u16 data elements).\r\n  * @param Size  Amount of data elements (u8 or u16) to be received.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\r\n{\r\n  /* Check that a Rx process is not already ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    /* Set Reception type to Standard reception */\r\n    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n    if (!(IS_LPUART_INSTANCE(huart->Instance)))\r\n    {\r\n      /* Check that USART RTOEN bit is set */\r\n      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)\r\n      {\r\n        /* Enable the UART Receiver Timeout Interrupt */\r\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);\r\n      }\r\n    }\r\n\r\n    return (UART_Start_Receive_IT(huart, pData, Size));\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Send an amount of data in DMA mode.\r\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *         the sent data is handled as a set of u16. In this case, Size must indicate the number\r\n  *         of u16 provided through pData.\r\n  * @param huart UART handle.\r\n  * @param pData Pointer to data buffer (u8 or u16 data elements).\r\n  * @param Size  Amount of data elements (u8 or u16) to be sent.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)\r\n{\r\n  /* Check that a Tx process is not already ongoing */\r\n  if (huart->gState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    huart->pTxBuffPtr  = pData;\r\n    huart->TxXferSize  = Size;\r\n    huart->TxXferCount = Size;\r\n\r\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n    huart->gState = HAL_UART_STATE_BUSY_TX;\r\n\r\n    if (huart->hdmatx != NULL)\r\n    {\r\n      /* Set the UART DMA transfer complete callback */\r\n      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;\r\n\r\n      /* Set the UART DMA Half transfer complete callback */\r\n      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;\r\n\r\n      /* Set the DMA error callback */\r\n      huart->hdmatx->XferErrorCallback = UART_DMAError;\r\n\r\n      /* Set the DMA abort callback */\r\n      huart->hdmatx->XferAbortCallback = NULL;\r\n\r\n      /* Enable the UART transmit DMA channel */\r\n      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)\r\n      {\r\n        /* Set error code to DMA */\r\n        huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n        __HAL_UNLOCK(huart);\r\n\r\n        /* Restore huart->gState to ready */\r\n        huart->gState = HAL_UART_STATE_READY;\r\n\r\n        return HAL_ERROR;\r\n      }\r\n    }\r\n    /* Clear the TC flag in the ICR register */\r\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);\r\n\r\n    __HAL_UNLOCK(huart);\r\n\r\n    /* Enable the DMA transfer for transmit request by setting the DMAT bit\r\n    in the UART CR3 register */\r\n    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Receive an amount of data in DMA mode.\r\n  * @note   When the UART parity is enabled (PCE = 1), the received data contain\r\n  *         the parity bit (MSB position).\r\n  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *         the received data is handled as a set of u16. In this case, Size must indicate the number\r\n  *         of u16 available through pData.\r\n  * @param huart UART handle.\r\n  * @param pData Pointer to data buffer (u8 or u16 data elements).\r\n  * @param Size  Amount of data elements (u8 or u16) to be received.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\r\n{\r\n  /* Check that a Rx process is not already ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    /* Set Reception type to Standard reception */\r\n    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n    if (!(IS_LPUART_INSTANCE(huart->Instance)))\r\n    {\r\n      /* Check that USART RTOEN bit is set */\r\n      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)\r\n      {\r\n        /* Enable the UART Receiver Timeout Interrupt */\r\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);\r\n      }\r\n    }\r\n\r\n    return (UART_Start_Receive_DMA(huart, pData, Size));\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Pause the DMA Transfer.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)\r\n{\r\n  const HAL_UART_StateTypeDef gstate = huart->gState;\r\n  const HAL_UART_StateTypeDef rxstate = huart->RxState;\r\n\r\n  __HAL_LOCK(huart);\r\n\r\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&\r\n      (gstate == HAL_UART_STATE_BUSY_TX))\r\n  {\r\n    /* Disable the UART DMA Tx request */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n  }\r\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&\r\n      (rxstate == HAL_UART_STATE_BUSY_RX))\r\n  {\r\n    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n    /* Disable the UART DMA Rx request */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n  }\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Resume the DMA Transfer.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)\r\n{\r\n  __HAL_LOCK(huart);\r\n\r\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\r\n  {\r\n    /* Enable the UART DMA Tx request */\r\n    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n  }\r\n  if (huart->RxState == HAL_UART_STATE_BUSY_RX)\r\n  {\r\n    /* Clear the Overrun flag before resuming the Rx transfer */\r\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);\r\n\r\n    /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */\r\n    if (huart->Init.Parity != UART_PARITY_NONE)\r\n    {    \r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n    }\r\n    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n    /* Enable the UART DMA Rx request */\r\n    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n  }\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Stop the DMA Transfer.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)\r\n{\r\n  /* The Lock is not implemented on this API to allow the user application\r\n     to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /\r\n     HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:\r\n     indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete\r\n     interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of\r\n     the stream and the corresponding call back is executed. */\r\n\r\n  const HAL_UART_StateTypeDef gstate = huart->gState;\r\n  const HAL_UART_StateTypeDef rxstate = huart->RxState;\r\n\r\n  /* Stop UART DMA Tx request if ongoing */\r\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&\r\n      (gstate == HAL_UART_STATE_BUSY_TX))\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    /* Abort the UART DMA Tx channel */\r\n    if (huart->hdmatx != NULL)\r\n    {\r\n      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          /* Set error code to DMA */\r\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    UART_EndTxTransfer(huart);\r\n  }\r\n\r\n  /* Stop UART DMA Rx request if ongoing */\r\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&\r\n      (rxstate == HAL_UART_STATE_BUSY_RX))\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n    /* Abort the UART DMA Rx channel */\r\n    if (huart->hdmarx != NULL)\r\n    {\r\n      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          /* Set error code to DMA */\r\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    UART_EndRxTransfer(huart);\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing transfers (blocking mode).\r\n  * @param  huart UART handle.\r\n  * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.\r\n  *         This procedure performs following operations :\r\n  *           - Disable UART Interrupts (Tx and Rx)\r\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\r\n  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)\r\n  *           - Set handle State to READY\r\n  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable TXE, TC, RXNE, PE, RXFT, TXFT and ERR (Frame error, noise error, overrun error) interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |\r\n                                          USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE);\r\n\r\n  /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));\r\n  }\r\n\r\n  /* Abort the UART DMA Tx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\r\n  {\r\n    /* Disable the UART DMA Tx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */\r\n    if (huart->hdmatx != NULL)\r\n    {\r\n      /* Set the UART DMA Abort callback to Null.\r\n         No call back execution at end of DMA abort procedure */\r\n      huart->hdmatx->XferAbortCallback = NULL;\r\n\r\n      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          /* Set error code to DMA */\r\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Abort the UART DMA Rx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n  {\r\n    /* Disable the UART DMA Rx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n    /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */\r\n    if (huart->hdmarx != NULL)\r\n    {\r\n      /* Set the UART DMA Abort callback to Null.\r\n         No call back execution at end of DMA abort procedure */\r\n      huart->hdmarx->XferAbortCallback = NULL;\r\n\r\n      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          /* Set error code to DMA */\r\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Reset Tx and Rx transfer counters */\r\n  huart->TxXferCount = 0U;\r\n  huart->RxXferCount = 0U;\r\n\r\n  /* Clear the Error flags in the ICR register */\r\n  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n  /* Flush the whole TX FIFO (if needed) */\r\n  if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n  {\r\n    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\r\n  }\r\n\r\n  /* Discard the received data */\r\n  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n\r\n  /* Restore huart->gState and huart->RxState to Ready */\r\n  huart->gState  = HAL_UART_STATE_READY;\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing Transmit transfer (blocking mode).\r\n  * @param  huart UART handle.\r\n  * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.\r\n  *         This procedure performs following operations :\r\n  *           - Disable UART Interrupts (Tx)\r\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\r\n  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)\r\n  *           - Set handle State to READY\r\n  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable TCIE, TXEIE and TXFTIE interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\r\n\r\n  /* Abort the UART DMA Tx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\r\n  {\r\n    /* Disable the UART DMA Tx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */\r\n    if (huart->hdmatx != NULL)\r\n    {\r\n      /* Set the UART DMA Abort callback to Null.\r\n         No call back execution at end of DMA abort procedure */\r\n      huart->hdmatx->XferAbortCallback = NULL;\r\n\r\n      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          /* Set error code to DMA */\r\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Reset Tx transfer counter */\r\n  huart->TxXferCount = 0U;\r\n\r\n  /* Flush the whole TX FIFO (if needed) */\r\n  if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n  {\r\n    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\r\n  }\r\n\r\n  /* Restore huart->gState to Ready */\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing Receive transfer (blocking mode).\r\n  * @param  huart UART handle.\r\n  * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.\r\n  *         This procedure performs following operations :\r\n  *           - Disable UART Interrupts (Rx)\r\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\r\n  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)\r\n  *           - Set handle State to READY\r\n  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable PEIE, EIE, RXNEIE and RXFTIE interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE);\r\n\r\n  /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));\r\n  }\r\n\r\n  /* Abort the UART DMA Rx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n  {\r\n    /* Disable the UART DMA Rx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n    /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */\r\n    if (huart->hdmarx != NULL)\r\n    {\r\n      /* Set the UART DMA Abort callback to Null.\r\n         No call back execution at end of DMA abort procedure */\r\n      huart->hdmarx->XferAbortCallback = NULL;\r\n\r\n      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)\r\n      {\r\n        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)\r\n        {\r\n          /* Set error code to DMA */\r\n          huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Reset Rx transfer counter */\r\n  huart->RxXferCount = 0U;\r\n\r\n  /* Clear the Error flags in the ICR register */\r\n  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n  /* Discard the received data */\r\n  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n\r\n  /* Restore huart->RxState to Ready */\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing transfers (Interrupt mode).\r\n  * @param  huart UART handle.\r\n  * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.\r\n  *         This procedure performs following operations :\r\n  *           - Disable UART Interrupts (Tx and Rx)\r\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\r\n  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)\r\n  *           - Set handle State to READY\r\n  *           - At abort completion, call user abort complete callback\r\n  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be\r\n  *         considered as completed only when user abort complete callback is executed (not when exiting function).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t abortcplt = 1U;\r\n\r\n  /* Disable interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_TCIE | USART_CR1_RXNEIE_RXFNEIE |\r\n                                          USART_CR1_TXEIE_TXFNFIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));\r\n\r\n  /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));\r\n  }\r\n\r\n  /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised\r\n     before any call to DMA Abort functions */\r\n  /* DMA Tx Handle is valid */\r\n  if (huart->hdmatx != NULL)\r\n  {\r\n    /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.\r\n       Otherwise, set it to NULL */\r\n    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\r\n    {\r\n      huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;\r\n    }\r\n    else\r\n    {\r\n      huart->hdmatx->XferAbortCallback = NULL;\r\n    }\r\n  }\r\n  /* DMA Rx Handle is valid */\r\n  if (huart->hdmarx != NULL)\r\n  {\r\n    /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.\r\n       Otherwise, set it to NULL */\r\n    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n    {\r\n      huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;\r\n    }\r\n    else\r\n    {\r\n      huart->hdmarx->XferAbortCallback = NULL;\r\n    }\r\n  }\r\n\r\n  /* Abort the UART DMA Tx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\r\n  {\r\n    /* Disable DMA Tx at UART level */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */\r\n    if (huart->hdmatx != NULL)\r\n    {\r\n      /* UART Tx DMA Abort callback has already been initialised :\r\n         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */\r\n\r\n      /* Abort DMA TX */\r\n      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)\r\n      {\r\n        huart->hdmatx->XferAbortCallback = NULL;\r\n      }\r\n      else\r\n      {\r\n        abortcplt = 0U;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Abort the UART DMA Rx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n  {\r\n    /* Disable the UART DMA Rx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n    /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */\r\n    if (huart->hdmarx != NULL)\r\n    {\r\n      /* UART Rx DMA Abort callback has already been initialised :\r\n         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */\r\n\r\n      /* Abort DMA RX */\r\n      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)\r\n      {\r\n        huart->hdmarx->XferAbortCallback = NULL;\r\n        abortcplt = 1U;\r\n      }\r\n      else\r\n      {\r\n        abortcplt = 0U;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* if no DMA abort complete callback execution is required => call user Abort Complete callback */\r\n  if (abortcplt == 1U)\r\n  {\r\n    /* Reset Tx and Rx transfer counters */\r\n    huart->TxXferCount = 0U;\r\n    huart->RxXferCount = 0U;\r\n\r\n    /* Clear ISR function pointers */\r\n    huart->RxISR = NULL;\r\n    huart->TxISR = NULL;\r\n\r\n    /* Reset errorCode */\r\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n\r\n    /* Clear the Error flags in the ICR register */\r\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n    /* Flush the whole TX FIFO (if needed) */\r\n    if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n    {\r\n      __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\r\n    }\r\n\r\n    /* Discard the received data */\r\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n\r\n    /* Restore huart->gState and huart->RxState to Ready */\r\n    huart->gState  = HAL_UART_STATE_READY;\r\n    huart->RxState = HAL_UART_STATE_READY;\r\n    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n    /* As no DMA to be aborted, call directly user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /* Call registered Abort complete callback */\r\n    huart->AbortCpltCallback(huart);\r\n#else\r\n    /* Call legacy weak Abort complete callback */\r\n    HAL_UART_AbortCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing Transmit transfer (Interrupt mode).\r\n  * @param  huart UART handle.\r\n  * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.\r\n  *         This procedure performs following operations :\r\n  *           - Disable UART Interrupts (Tx)\r\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\r\n  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)\r\n  *           - Set handle State to READY\r\n  *           - At abort completion, call user abort complete callback\r\n  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be\r\n  *         considered as completed only when user abort complete callback is executed (not when exiting function).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\r\n\r\n  /* Abort the UART DMA Tx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))\r\n  {\r\n    /* Disable the UART DMA Tx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */\r\n    if (huart->hdmatx != NULL)\r\n    {\r\n      /* Set the UART DMA Abort callback :\r\n         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */\r\n      huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;\r\n\r\n      /* Abort DMA TX */\r\n      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)\r\n      {\r\n        /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */\r\n        huart->hdmatx->XferAbortCallback(huart->hdmatx);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Reset Tx transfer counter */\r\n      huart->TxXferCount = 0U;\r\n\r\n      /* Clear TxISR function pointers */\r\n      huart->TxISR = NULL;\r\n\r\n      /* Restore huart->gState to Ready */\r\n      huart->gState = HAL_UART_STATE_READY;\r\n\r\n      /* As no DMA to be aborted, call directly user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n      /* Call registered Abort Transmit Complete Callback */\r\n      huart->AbortTransmitCpltCallback(huart);\r\n#else\r\n      /* Call legacy weak Abort Transmit Complete Callback */\r\n      HAL_UART_AbortTransmitCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Reset Tx transfer counter */\r\n    huart->TxXferCount = 0U;\r\n\r\n    /* Clear TxISR function pointers */\r\n    huart->TxISR = NULL;\r\n\r\n    /* Flush the whole TX FIFO (if needed) */\r\n    if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n    {\r\n      __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\r\n    }\r\n\r\n    /* Restore huart->gState to Ready */\r\n    huart->gState = HAL_UART_STATE_READY;\r\n\r\n    /* As no DMA to be aborted, call directly user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /* Call registered Abort Transmit Complete Callback */\r\n    huart->AbortTransmitCpltCallback(huart);\r\n#else\r\n    /* Call legacy weak Abort Transmit Complete Callback */\r\n    HAL_UART_AbortTransmitCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Abort ongoing Receive transfer (Interrupt mode).\r\n  * @param  huart UART handle.\r\n  * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.\r\n  *         This procedure performs following operations :\r\n  *           - Disable UART Interrupts (Rx)\r\n  *           - Disable the DMA transfer in the peripheral register (if enabled)\r\n  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)\r\n  *           - Set handle State to READY\r\n  *           - At abort completion, call user abort complete callback\r\n  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be\r\n  *         considered as completed only when user abort complete callback is executed (not when exiting function).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));\r\n\r\n  /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));\r\n  }\r\n\r\n  /* Abort the UART DMA Rx channel if enabled */\r\n  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n  {\r\n    /* Disable the UART DMA Rx request if enabled */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n    /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */\r\n    if (huart->hdmarx != NULL)\r\n    {\r\n      /* Set the UART DMA Abort callback :\r\n         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */\r\n      huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;\r\n\r\n      /* Abort DMA RX */\r\n      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)\r\n      {\r\n        /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */\r\n        huart->hdmarx->XferAbortCallback(huart->hdmarx);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      /* Reset Rx transfer counter */\r\n      huart->RxXferCount = 0U;\r\n\r\n      /* Clear RxISR function pointer */\r\n      huart->pRxBuffPtr = NULL;\r\n\r\n      /* Clear the Error flags in the ICR register */\r\n      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n      /* Discard the received data */\r\n      __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n\r\n      /* Restore huart->RxState to Ready */\r\n      huart->RxState = HAL_UART_STATE_READY;\r\n      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n      /* As no DMA to be aborted, call directly user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n      /* Call registered Abort Receive Complete Callback */\r\n      huart->AbortReceiveCpltCallback(huart);\r\n#else\r\n      /* Call legacy weak Abort Receive Complete Callback */\r\n      HAL_UART_AbortReceiveCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Reset Rx transfer counter */\r\n    huart->RxXferCount = 0U;\r\n\r\n    /* Clear RxISR function pointer */\r\n    huart->pRxBuffPtr = NULL;\r\n\r\n    /* Clear the Error flags in the ICR register */\r\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n    /* Restore huart->RxState to Ready */\r\n    huart->RxState = HAL_UART_STATE_READY;\r\n    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n    /* As no DMA to be aborted, call directly user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /* Call registered Abort Receive Complete Callback */\r\n    huart->AbortReceiveCpltCallback(huart);\r\n#else\r\n    /* Call legacy weak Abort Receive Complete Callback */\r\n    HAL_UART_AbortReceiveCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Handle UART interrupt request.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t isrflags   = READ_REG(huart->Instance->ISR);\r\n  uint32_t cr1its     = READ_REG(huart->Instance->CR1);\r\n  uint32_t cr3its     = READ_REG(huart->Instance->CR3);\r\n\r\n  uint32_t errorflags;\r\n  uint32_t errorcode;\r\n\r\n  /* If no error occurs */\r\n  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));\r\n  if (errorflags == 0U)\r\n  {\r\n    /* UART in mode Receiver ---------------------------------------------------*/\r\n    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)\r\n        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)\r\n            || ((cr3its & USART_CR3_RXFTIE) != 0U)))\r\n    {\r\n      if (huart->RxISR != NULL)\r\n      {\r\n        huart->RxISR(huart);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* If some errors occur */\r\n  if ((errorflags != 0U)\r\n      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)\r\n           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))\r\n  {\r\n    /* UART parity error interrupt occurred -------------------------------------*/\r\n    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))\r\n    {\r\n      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);\r\n\r\n      huart->ErrorCode |= HAL_UART_ERROR_PE;\r\n    }\r\n\r\n    /* UART frame error interrupt occurred --------------------------------------*/\r\n    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))\r\n    {\r\n      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);\r\n\r\n      huart->ErrorCode |= HAL_UART_ERROR_FE;\r\n    }\r\n\r\n    /* UART noise error interrupt occurred --------------------------------------*/\r\n    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))\r\n    {\r\n      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);\r\n\r\n      huart->ErrorCode |= HAL_UART_ERROR_NE;\r\n    }\r\n\r\n    /* UART Over-Run interrupt occurred -----------------------------------------*/\r\n    if (((isrflags & USART_ISR_ORE) != 0U)\r\n        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||\r\n            ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))\r\n    {\r\n      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);\r\n\r\n      huart->ErrorCode |= HAL_UART_ERROR_ORE;\r\n    }\r\n\r\n    /* UART Receiver Timeout interrupt occurred ---------------------------------*/\r\n    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))\r\n    {\r\n      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);\r\n\r\n      huart->ErrorCode |= HAL_UART_ERROR_RTO;\r\n    }\r\n\r\n    /* Call UART Error Call back function if need be ----------------------------*/\r\n    if (huart->ErrorCode != HAL_UART_ERROR_NONE)\r\n    {\r\n      /* UART in mode Receiver --------------------------------------------------*/\r\n      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)\r\n          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)\r\n              || ((cr3its & USART_CR3_RXFTIE) != 0U)))\r\n      {\r\n        if (huart->RxISR != NULL)\r\n        {\r\n          huart->RxISR(huart);\r\n        }\r\n      }\r\n\r\n      /* If Error is to be considered as blocking :\r\n          - Receiver Timeout error in Reception\r\n          - Overrun error in Reception\r\n          - any error occurs in DMA mode reception\r\n      */\r\n      errorcode = huart->ErrorCode;\r\n      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||\r\n          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))\r\n      {\r\n        /* Blocking error : transfer is aborted\r\n           Set the UART state ready to be able to start again the process,\r\n           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */\r\n        UART_EndRxTransfer(huart);\r\n\r\n        /* Abort the UART DMA Rx channel if enabled */\r\n        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n        {\r\n          /* Disable the UART DMA Rx request if enabled */\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n          /* Abort the UART DMA Rx channel */\r\n          if (huart->hdmarx != NULL)\r\n          {\r\n            /* Set the UART DMA Abort callback :\r\n               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */\r\n            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;\r\n\r\n            /* Abort DMA RX */\r\n            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)\r\n            {\r\n              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */\r\n              huart->hdmarx->XferAbortCallback(huart->hdmarx);\r\n            }\r\n          }\r\n          else\r\n          {\r\n            /* Call user error callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n            /*Call registered error callback*/\r\n            huart->ErrorCallback(huart);\r\n#else\r\n            /*Call legacy weak error callback*/\r\n            HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n\r\n          }\r\n        }\r\n        else\r\n        {\r\n          /* Call user error callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered error callback*/\r\n          huart->ErrorCallback(huart);\r\n#else\r\n          /*Call legacy weak error callback*/\r\n          HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n      else\r\n      {\r\n        /* Non Blocking error : transfer could go on.\r\n           Error is notified to user through user error callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered error callback*/\r\n        huart->ErrorCallback(huart);\r\n#else\r\n        /*Call legacy weak error callback*/\r\n        HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n        huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n      }\r\n    }\r\n    return;\r\n\r\n  } /* End if some error occurs */\r\n\r\n  /* Check current reception Mode :\r\n     If Reception till IDLE event has been selected : */\r\n  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n      && ((isrflags & USART_ISR_IDLE) != 0U)\r\n      && ((cr1its & USART_ISR_IDLE) != 0U))\r\n  {\r\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n\r\n    /* Check if DMA mode is enabled in UART */\r\n    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))\r\n    {\r\n      /* DMA mode enabled */\r\n      /* Check received length : If all expected data are received, do nothing,\r\n         (DMA cplt callback will be called).\r\n         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */\r\n      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);\r\n      if ((nb_remaining_rx_data > 0U)\r\n          && (nb_remaining_rx_data < huart->RxXferSize))\r\n      {\r\n        /* Reception is not complete */\r\n        huart->RxXferCount = nb_remaining_rx_data;\r\n\r\n        /* In Normal mode, end DMA xfer and HAL UART Rx process*/\r\n        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)\r\n        {\r\n          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit\r\n             in the UART CR3 register */\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n          /* At end of Rx process, restore huart->RxState to Ready */\r\n          huart->RxState = HAL_UART_STATE_READY;\r\n          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n\r\n          /* Last bytes received, so no need as the abort is immediate */\r\n          (void)HAL_DMA_Abort(huart->hdmarx);\r\n        }\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered Rx Event callback*/\r\n        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));\r\n#else\r\n        /*Call legacy weak Rx Event callback*/\r\n        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n      }\r\n      return;\r\n    }\r\n    else\r\n    {\r\n      /* DMA mode not enabled */\r\n      /* Check received length : If all expected data are received, do nothing.\r\n         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */\r\n      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;\r\n      if ((huart->RxXferCount > 0U)\r\n          && (nb_rx_data > 0U))\r\n      {\r\n        /* Disable the UART Parity Error Interrupt and RXNE interrupts */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));\r\n\r\n        /* Disable the UART Error Interrupt:(Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));\r\n\r\n        /* Rx process is completed, restore huart->RxState to Ready */\r\n        huart->RxState = HAL_UART_STATE_READY;\r\n        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n        /* Clear RxISR function pointer */\r\n        huart->RxISR = NULL;\r\n\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered Rx complete callback*/\r\n        huart->RxEventCallback(huart, nb_rx_data);\r\n#else\r\n        /*Call legacy weak Rx Event callback*/\r\n        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/\r\n  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))\r\n  {\r\n    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);\r\n\r\n    /* UART Rx state is not reset as a reception process might be ongoing.\r\n       If UART handle state fields need to be reset to READY, this could be done in Wakeup callback */\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /* Call registered Wakeup Callback */\r\n    huart->WakeupCallback(huart);\r\n#else\r\n    /* Call legacy weak Wakeup Callback */\r\n    HAL_UARTEx_WakeupCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n    return;\r\n  }\r\n\r\n  /* UART in mode Transmitter ------------------------------------------------*/\r\n  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)\r\n      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)\r\n          || ((cr3its & USART_CR3_TXFTIE) != 0U)))\r\n  {\r\n    if (huart->TxISR != NULL)\r\n    {\r\n      huart->TxISR(huart);\r\n    }\r\n    return;\r\n  }\r\n\r\n  /* UART in mode Transmitter (transmission end) -----------------------------*/\r\n  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))\r\n  {\r\n    UART_EndTransmit_IT(huart);\r\n    return;\r\n  }\r\n\r\n  /* UART TX Fifo Empty occurred ----------------------------------------------*/\r\n  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))\r\n  {\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /* Call registered Tx Fifo Empty Callback */\r\n    huart->TxFifoEmptyCallback(huart);\r\n#else\r\n    /* Call legacy weak Tx Fifo Empty Callback */\r\n    HAL_UARTEx_TxFifoEmptyCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n    return;\r\n  }\r\n\r\n  /* UART RX Fifo Full occurred ----------------------------------------------*/\r\n  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))\r\n  {\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /* Call registered Rx Fifo Full Callback */\r\n    huart->RxFifoFullCallback(huart);\r\n#else\r\n    /* Call legacy weak Rx Fifo Full Callback */\r\n    HAL_UARTEx_RxFifoFullCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Tx Transfer completed callback.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_TxCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Tx Half Transfer completed callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE: This function should not be modified, when the callback is needed,\r\n           the HAL_UART_TxHalfCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Rx Transfer completed callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_RxCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Rx Half Transfer completed callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE: This function should not be modified, when the callback is needed,\r\n           the HAL_UART_RxHalfCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  UART error callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_ErrorCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  UART Abort Complete callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_AbortCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  UART Abort Complete callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  UART Abort Receive Complete callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  Reception Event Callback (Rx event notification called after use of advanced reception service).\r\n  * @param  huart UART handle\r\n  * @param  Size  Number of data available in application reception buffer (indicates a position in\r\n  *               reception buffer until which, data are available)\r\n  * @retval None\r\n  */\r\n__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n  UNUSED(Size);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UARTEx_RxEventCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions\r\n  *  @brief   UART control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to control the UART.\r\n     (+) HAL_UART_ReceiverTimeout_Config() API allows to configure the receiver timeout value on the fly\r\n     (+) HAL_UART_EnableReceiverTimeout() API enables the receiver timeout feature\r\n     (+) HAL_UART_DisableReceiverTimeout() API disables the receiver timeout feature\r\n     (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode\r\n     (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode\r\n     (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode\r\n     (+) UART_SetConfig() API configures the UART peripheral\r\n     (+) UART_AdvFeatureConfig() API optionally configures the UART advanced features\r\n     (+) UART_CheckIdleState() API ensures that TEACK and/or REACK are set after initialization\r\n     (+) HAL_HalfDuplex_EnableTransmitter() API disables receiver and enables transmitter\r\n     (+) HAL_HalfDuplex_EnableReceiver() API disables transmitter and enables receiver\r\n     (+) HAL_LIN_SendBreak() API transmits the break characters\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Update on the fly the receiver timeout value in RTOR register.\r\n  * @param  huart Pointer to a UART_HandleTypeDef structure that contains\r\n  *                    the configuration information for the specified UART module.\r\n  * @param  TimeoutValue receiver timeout value in number of baud blocks. The timeout\r\n  *                     value must be less or equal to 0x0FFFFFFFF.\r\n  * @retval None\r\n  */\r\nvoid HAL_UART_ReceiverTimeout_Config(UART_HandleTypeDef *huart, uint32_t TimeoutValue)\r\n{\r\n  if (!(IS_LPUART_INSTANCE(huart->Instance)))\r\n  {\r\n    assert_param(IS_UART_RECEIVER_TIMEOUT_VALUE(TimeoutValue));\r\n    MODIFY_REG(huart->Instance->RTOR, USART_RTOR_RTO, TimeoutValue);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enable the UART receiver timeout feature.\r\n  * @param  huart Pointer to a UART_HandleTypeDef structure that contains\r\n  *                    the configuration information for the specified UART module.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_EnableReceiverTimeout(UART_HandleTypeDef *huart)\r\n{\r\n  if (!(IS_LPUART_INSTANCE(huart->Instance)))\r\n  {\r\n    if (huart->gState == HAL_UART_STATE_READY)\r\n    {\r\n      /* Process Locked */\r\n      __HAL_LOCK(huart);\r\n\r\n      huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n      /* Set the USART RTOEN bit */\r\n      SET_BIT(huart->Instance->CR2, USART_CR2_RTOEN);\r\n\r\n      huart->gState = HAL_UART_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(huart);\r\n\r\n      return HAL_OK;\r\n    }\r\n    else\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Disable the UART receiver timeout feature.\r\n  * @param  huart Pointer to a UART_HandleTypeDef structure that contains\r\n  *                    the configuration information for the specified UART module.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UART_DisableReceiverTimeout(UART_HandleTypeDef *huart)\r\n{\r\n  if (!(IS_LPUART_INSTANCE(huart->Instance)))\r\n  {\r\n    if (huart->gState == HAL_UART_STATE_READY)\r\n    {\r\n      /* Process Locked */\r\n      __HAL_LOCK(huart);\r\n\r\n      huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n      /* Clear the USART RTOEN bit */\r\n      CLEAR_BIT(huart->Instance->CR2, USART_CR2_RTOEN);\r\n\r\n      huart->gState = HAL_UART_STATE_READY;\r\n\r\n      /* Process Unlocked */\r\n      __HAL_UNLOCK(huart);\r\n\r\n      return HAL_OK;\r\n    }\r\n    else\r\n    {\r\n      return HAL_BUSY;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Enable UART in mute mode (does not mean UART enters mute mode;\r\n  *         to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called).\r\n  * @param  huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)\r\n{\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Enable USART mute mode by setting the MME bit in the CR1 register */\r\n  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_MME);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n/**\r\n  * @brief  Disable UART mute mode (does not mean the UART actually exits mute mode\r\n  *         as it may not have been in mute mode at this very moment).\r\n  * @param  huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)\r\n{\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Disable USART mute mode by clearing the MME bit in the CR1 register */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n/**\r\n  * @brief Enter UART mute mode (means UART actually enters mute mode).\r\n  * @note  To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nvoid HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)\r\n{\r\n  __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);\r\n}\r\n\r\n/**\r\n  * @brief  Enable the UART transmitter and disable the UART receiver.\r\n  * @param  huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)\r\n{\r\n  __HAL_LOCK(huart);\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Clear TE and RE bits */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));\r\n\r\n  /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */\r\n  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TE);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the UART receiver and disable the UART transmitter.\r\n  * @param  huart UART handle.\r\n  * @retval HAL status.\r\n  */\r\nHAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)\r\n{\r\n  __HAL_LOCK(huart);\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Clear TE and RE bits */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));\r\n\r\n  /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */\r\n  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RE);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Transmit break characters.\r\n  * @param  huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)\r\n{\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_LIN_INSTANCE(huart->Instance));\r\n\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Send break characters */\r\n  __HAL_UART_SEND_REQ(huart, UART_SENDBREAK_REQUEST);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup UART_Exported_Functions_Group4 Peripheral State and Error functions\r\n  *  @brief   UART Peripheral State functions\r\n  *\r\n@verbatim\r\n  ==============================================================================\r\n            ##### Peripheral State and Error functions #####\r\n  ==============================================================================\r\n    [..]\r\n    This subsection provides functions allowing to :\r\n      (+) Return the UART handle state.\r\n      (+) Return the UART handle error code\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Return the UART handle state.\r\n  * @param  huart Pointer to a UART_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified UART.\r\n  * @retval HAL state\r\n  */\r\nHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t temp1;\r\n  uint32_t temp2;\r\n  temp1 = huart->gState;\r\n  temp2 = huart->RxState;\r\n\r\n  return (HAL_UART_StateTypeDef)(temp1 | temp2);\r\n}\r\n\r\n/**\r\n  * @brief  Return the UART handle error code.\r\n  * @param  huart Pointer to a UART_HandleTypeDef structure that contains\r\n  *               the configuration information for the specified UART.\r\n  * @retval UART Error Code\r\n  */\r\nuint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)\r\n{\r\n  return huart->ErrorCode;\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup UART_Private_Functions UART Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initialize the callbacks to their default values.\r\n  * @param  huart UART handle.\r\n  * @retval none\r\n  */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\nvoid UART_InitCallbacksToDefault(UART_HandleTypeDef *huart)\r\n{\r\n  /* Init the UART Callback settings */\r\n  huart->TxHalfCpltCallback        = HAL_UART_TxHalfCpltCallback;        /* Legacy weak TxHalfCpltCallback        */\r\n  huart->TxCpltCallback            = HAL_UART_TxCpltCallback;            /* Legacy weak TxCpltCallback            */\r\n  huart->RxHalfCpltCallback        = HAL_UART_RxHalfCpltCallback;        /* Legacy weak RxHalfCpltCallback        */\r\n  huart->RxCpltCallback            = HAL_UART_RxCpltCallback;            /* Legacy weak RxCpltCallback            */\r\n  huart->ErrorCallback             = HAL_UART_ErrorCallback;             /* Legacy weak ErrorCallback             */\r\n  huart->AbortCpltCallback         = HAL_UART_AbortCpltCallback;         /* Legacy weak AbortCpltCallback         */\r\n  huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak AbortTransmitCpltCallback */\r\n  huart->AbortReceiveCpltCallback  = HAL_UART_AbortReceiveCpltCallback;  /* Legacy weak AbortReceiveCpltCallback  */\r\n  huart->WakeupCallback            = HAL_UARTEx_WakeupCallback;          /* Legacy weak WakeupCallback            */\r\n  huart->RxFifoFullCallback        = HAL_UARTEx_RxFifoFullCallback;      /* Legacy weak RxFifoFullCallback        */\r\n  huart->TxFifoEmptyCallback       = HAL_UARTEx_TxFifoEmptyCallback;     /* Legacy weak TxFifoEmptyCallback       */\r\n  huart->RxEventCallback           = HAL_UARTEx_RxEventCallback;         /* Legacy weak RxEventCallback           */\r\n\r\n}\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n\r\n/**\r\n  * @brief Configure the UART peripheral.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t tmpreg;\r\n  uint16_t brrtemp;\r\n  UART_ClockSourceTypeDef clocksource;\r\n  uint32_t usartdiv;\r\n  HAL_StatusTypeDef ret               = HAL_OK;\r\n  uint32_t lpuart_ker_ck_pres;\r\n  PLL2_ClocksTypeDef pll2_clocks;\r\n  PLL3_ClocksTypeDef pll3_clocks;\r\n  uint32_t pclk;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));\r\n  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));\r\n  if (UART_INSTANCE_LOWPOWER(huart))\r\n  {\r\n    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));\r\n  }\r\n  else\r\n  {\r\n    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));\r\n    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));\r\n  }\r\n\r\n  assert_param(IS_UART_PARITY(huart->Init.Parity));\r\n  assert_param(IS_UART_MODE(huart->Init.Mode));\r\n  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));\r\n  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));\r\n  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));\r\n\r\n  /*-------------------------- USART CR1 Configuration -----------------------*/\r\n  /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure\r\n  *  the UART Word Length, Parity, Mode and oversampling:\r\n  *  set the M bits according to huart->Init.WordLength value\r\n  *  set PCE and PS bits according to huart->Init.Parity value\r\n  *  set TE and RE bits according to huart->Init.Mode value\r\n  *  set OVER8 bit according to huart->Init.OverSampling value */\r\n  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;\r\n  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);\r\n\r\n  /*-------------------------- USART CR2 Configuration -----------------------*/\r\n  /* Configure the UART Stop Bits: Set STOP[13:12] bits according\r\n  * to huart->Init.StopBits value */\r\n  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);\r\n\r\n  /*-------------------------- USART CR3 Configuration -----------------------*/\r\n  /* Configure\r\n  * - UART HardWare Flow Control: set CTSE and RTSE bits according\r\n  *   to huart->Init.HwFlowCtl value\r\n  * - one-bit sampling method versus three samples' majority rule according\r\n  *   to huart->Init.OneBitSampling (not applicable to LPUART) */\r\n  tmpreg = (uint32_t)huart->Init.HwFlowCtl;\r\n\r\n  if (!(UART_INSTANCE_LOWPOWER(huart)))\r\n  {\r\n    tmpreg |= huart->Init.OneBitSampling;\r\n  }\r\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);\r\n\r\n  /*-------------------------- USART PRESC Configuration -----------------------*/\r\n  /* Configure\r\n  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */\r\n  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);\r\n\r\n  /*-------------------------- USART BRR Configuration -----------------------*/\r\n  UART_GETCLOCKSOURCE(huart, clocksource);\r\n\r\n  /* Check LPUART instance */\r\n  if (UART_INSTANCE_LOWPOWER(huart))\r\n  {\r\n    /* Retrieve frequency clock */\r\n    switch (clocksource)\r\n    {\r\n      case UART_CLOCKSOURCE_D3PCLK1:\r\n        pclk = HAL_RCCEx_GetD3PCLK1Freq();\r\n        break;\r\n      case UART_CLOCKSOURCE_PLL2:\r\n        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n        pclk = pll2_clocks.PLL2_Q_Frequency;\r\n        break;\r\n      case UART_CLOCKSOURCE_PLL3:\r\n        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n        pclk = pll3_clocks.PLL3_Q_Frequency;\r\n        break;\r\n      case UART_CLOCKSOURCE_HSI:\r\n        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n        {\r\n          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));\r\n        }\r\n        else\r\n        {\r\n          pclk = (uint32_t) HSI_VALUE;\r\n        }\r\n        break;\r\n      case UART_CLOCKSOURCE_CSI:\r\n        pclk = (uint32_t) CSI_VALUE;\r\n        break;\r\n      case UART_CLOCKSOURCE_LSE:\r\n        pclk = (uint32_t) LSE_VALUE;\r\n        break;\r\n      default:\r\n        pclk = 0U;\r\n        ret = HAL_ERROR;\r\n        break;\r\n    }\r\n\r\n    /* If proper clock source reported */\r\n    if (pclk != 0U)\r\n    {\r\n      /* Compute clock after Prescaler */\r\n      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);\r\n\r\n      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */\r\n      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||\r\n          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))\r\n      {\r\n        ret = HAL_ERROR;\r\n      }\r\n      else\r\n      {\r\n        /* Check computed UsartDiv value is in allocated range\r\n           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */\r\n        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));\r\n        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))\r\n        {\r\n          huart->Instance->BRR = usartdiv;\r\n        }\r\n        else\r\n        {\r\n          ret = HAL_ERROR;\r\n        }\r\n      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||\r\n                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */\r\n    } /* if (pclk != 0) */\r\n  }\r\n  /* Check UART Over Sampling to set Baud Rate Register */\r\n  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)\r\n  {\r\n    switch (clocksource)\r\n    {\r\n      case UART_CLOCKSOURCE_D2PCLK1:\r\n        pclk = HAL_RCC_GetPCLK1Freq();\r\n        break;\r\n      case UART_CLOCKSOURCE_D2PCLK2:\r\n        pclk = HAL_RCC_GetPCLK2Freq();\r\n        break;\r\n      case UART_CLOCKSOURCE_PLL2:\r\n        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n        pclk = pll2_clocks.PLL2_Q_Frequency;\r\n        break;\r\n      case UART_CLOCKSOURCE_PLL3:\r\n        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n        pclk = pll3_clocks.PLL3_Q_Frequency;\r\n        break;\r\n      case UART_CLOCKSOURCE_HSI:\r\n        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n        {\r\n          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));\r\n        }\r\n        else\r\n        {\r\n          pclk = (uint32_t) HSI_VALUE;\r\n        }\r\n        break;\r\n      case UART_CLOCKSOURCE_CSI:\r\n        pclk = (uint32_t) CSI_VALUE;\r\n        break;\r\n      case UART_CLOCKSOURCE_LSE:\r\n        pclk = (uint32_t) LSE_VALUE;\r\n        break;\r\n      default:\r\n        pclk = 0U;\r\n        ret = HAL_ERROR;\r\n        break;\r\n    }\r\n\r\n    /* USARTDIV must be greater than or equal to 0d16 */\r\n    if (pclk != 0U)\r\n    {\r\n      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));\r\n      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))\r\n      {\r\n        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);\r\n        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);\r\n        huart->Instance->BRR = brrtemp;\r\n      }\r\n      else\r\n      {\r\n        ret = HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    switch (clocksource)\r\n    {\r\n      case UART_CLOCKSOURCE_D2PCLK1:\r\n        pclk = HAL_RCC_GetPCLK1Freq();\r\n        break;\r\n      case UART_CLOCKSOURCE_D2PCLK2:\r\n        pclk = HAL_RCC_GetPCLK2Freq();\r\n        break;\r\n      case UART_CLOCKSOURCE_PLL2:\r\n        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);\r\n        pclk = pll2_clocks.PLL2_Q_Frequency;\r\n        break;\r\n      case UART_CLOCKSOURCE_PLL3:\r\n        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);\r\n        pclk = pll3_clocks.PLL3_Q_Frequency;\r\n        break;\r\n      case UART_CLOCKSOURCE_HSI:\r\n        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)\r\n        {\r\n          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));\r\n        }\r\n        else\r\n        {\r\n          pclk = (uint32_t) HSI_VALUE;\r\n        }\r\n        break;\r\n      case UART_CLOCKSOURCE_CSI:\r\n        pclk = (uint32_t) CSI_VALUE;\r\n        break;\r\n      case UART_CLOCKSOURCE_LSE:\r\n        pclk = (uint32_t) LSE_VALUE;\r\n        break;\r\n      default:\r\n        pclk = 0U;\r\n        ret = HAL_ERROR;\r\n        break;\r\n    }\r\n\r\n    if (pclk != 0U)\r\n    {\r\n      /* USARTDIV must be greater than or equal to 0d16 */\r\n      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));\r\n      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))\r\n      {\r\n        huart->Instance->BRR = (uint16_t)usartdiv;\r\n      }\r\n      else\r\n      {\r\n        ret = HAL_ERROR;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Initialize the number of data to process during RX/TX ISR execution */\r\n  huart->NbTxDataToProcess = 1;\r\n  huart->NbRxDataToProcess = 1;\r\n\r\n  /* Clear ISR function pointers */\r\n  huart->RxISR = NULL;\r\n  huart->TxISR = NULL;\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief Configure the UART peripheral advanced features.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nvoid UART_AdvFeatureConfig(UART_HandleTypeDef *huart)\r\n{\r\n  /* Check whether the set of advanced features to configure is properly set */\r\n  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));\r\n\r\n  /* if required, configure TX pin active level inversion */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))\r\n  {\r\n    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);\r\n  }\r\n\r\n  /* if required, configure RX pin active level inversion */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))\r\n  {\r\n    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);\r\n  }\r\n\r\n  /* if required, configure data inversion */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))\r\n  {\r\n    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);\r\n  }\r\n\r\n  /* if required, configure RX/TX pins swap */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))\r\n  {\r\n    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);\r\n  }\r\n\r\n  /* if required, configure RX overrun detection disabling */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))\r\n  {\r\n    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));\r\n    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);\r\n  }\r\n\r\n  /* if required, configure DMA disabling on reception error */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))\r\n  {\r\n    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));\r\n    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);\r\n  }\r\n\r\n  /* if required, configure auto Baud rate detection scheme */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))\r\n  {\r\n    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));\r\n    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);\r\n    /* set auto Baudrate detection parameters if detection is enabled */\r\n    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)\r\n    {\r\n      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));\r\n      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);\r\n    }\r\n  }\r\n\r\n  /* if required, configure MSB first on communication line */\r\n  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))\r\n  {\r\n    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));\r\n    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Check the UART Idle State.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t tickstart;\r\n\r\n  /* Initialize the UART ErrorCode */\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n\r\n  /* Init tickstart for timeout management */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Check if the Transmitter is enabled */\r\n  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)\r\n  {\r\n    /* Wait until TEACK flag is set */\r\n    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)\r\n    {\r\n      /* Timeout occurred */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Check if the Receiver is enabled */\r\n  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)\r\n  {\r\n    /* Wait until REACK flag is set */\r\n    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)\r\n    {\r\n      /* Timeout occurred */\r\n      return HAL_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  /* Initialize the UART State */\r\n  huart->gState = HAL_UART_STATE_READY;\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  This function handles UART Communication Timeout. It waits\r\n  *                  until a flag is no longer in the specified status.\r\n  * @param huart     UART handle.\r\n  * @param Flag      Specifies the UART flag to check\r\n  * @param Status    The actual Flag status (SET or RESET)\r\n  * @param Tickstart Tick start value\r\n  * @param Timeout   Timeout duration\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,\r\n                                              uint32_t Tickstart, uint32_t Timeout)\r\n{\r\n  /* Wait until flag is set */\r\n  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)\r\n  {\r\n    /* Check for the Timeout */\r\n    if (Timeout != HAL_MAX_DELAY)\r\n    {\r\n      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))\r\n      {\r\n        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)\r\n           interrupts for the interrupt process */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |\r\n                                                USART_CR1_TXEIE_TXFNFIE));\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n        huart->gState = HAL_UART_STATE_READY;\r\n        huart->RxState = HAL_UART_STATE_READY;\r\n\r\n        __HAL_UNLOCK(huart);\r\n\r\n        return HAL_TIMEOUT;\r\n      }\r\n\r\n      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)\r\n      {\r\n        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)\r\n        {\r\n          /* Clear Receiver Timeout flag*/\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);\r\n\r\n          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)\r\n             interrupts for the interrupt process */\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |\r\n                                                  USART_CR1_TXEIE_TXFNFIE));\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n          huart->gState = HAL_UART_STATE_READY;\r\n          huart->RxState = HAL_UART_STATE_READY;\r\n          huart->ErrorCode = HAL_UART_ERROR_RTO;\r\n\r\n          /* Process Unlocked */\r\n          __HAL_UNLOCK(huart);\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Start Receive operation in interrupt mode.\r\n  * @note   This function could be called by all HAL UART API providing reception in Interrupt mode.\r\n  * @note   When calling this function, parameters validity is considered as already checked,\r\n  *         i.e. Rx State, buffer address, ...\r\n  *         UART Handle is assumed as Locked.\r\n  * @param  huart UART handle.\r\n  * @param  pData Pointer to data buffer (u8 or u16 data elements).\r\n  * @param  Size  Amount of data elements (u8 or u16) to be received.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\r\n{\r\n  huart->pRxBuffPtr  = pData;\r\n  huart->RxXferSize  = Size;\r\n  huart->RxXferCount = Size;\r\n  huart->RxISR       = NULL;\r\n\r\n  /* Computation of UART mask to apply to RDR register */\r\n  UART_MASK_COMPUTATION(huart);\r\n\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n  huart->RxState = HAL_UART_STATE_BUSY_RX;\r\n\r\n  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */\r\n  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n  /* Configure Rx interrupt processing */\r\n  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))\r\n  {\r\n    /* Set the Rx ISR function pointer according to the data word length */\r\n    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n    {\r\n      huart->RxISR = UART_RxISR_16BIT_FIFOEN;\r\n    }\r\n    else\r\n    {\r\n      huart->RxISR = UART_RxISR_8BIT_FIFOEN;\r\n    }\r\n\r\n    __HAL_UNLOCK(huart);\r\n\r\n    /* Enable the UART Parity Error interrupt and RX FIFO Threshold interrupt */\r\n    if (huart->Init.Parity != UART_PARITY_NONE)\r\n    {\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n    }\r\n    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);\r\n  }\r\n  else\r\n  {\r\n    /* Set the Rx ISR function pointer according to the data word length */\r\n    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n    {\r\n      huart->RxISR = UART_RxISR_16BIT;\r\n    }\r\n    else\r\n    {\r\n      huart->RxISR = UART_RxISR_8BIT;\r\n    }\r\n\r\n    __HAL_UNLOCK(huart);\r\n\r\n    /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */\r\n    if (huart->Init.Parity != UART_PARITY_NONE)\r\n    {\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);\r\n    }\r\n    else\r\n    {\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);\r\n    }  \r\n  }\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Start Receive operation in DMA mode.\r\n  * @note   This function could be called by all HAL UART API providing reception in DMA mode.\r\n  * @note   When calling this function, parameters validity is considered as already checked,\r\n  *         i.e. Rx State, buffer address, ...\r\n  *         UART Handle is assumed as Locked.\r\n  * @param  huart UART handle.\r\n  * @param  pData Pointer to data buffer (u8 or u16 data elements).\r\n  * @param  Size  Amount of data elements (u8 or u16) to be received.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\r\n{\r\n  huart->pRxBuffPtr = pData;\r\n  huart->RxXferSize = Size;\r\n\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n  huart->RxState = HAL_UART_STATE_BUSY_RX;\r\n\r\n  if (huart->hdmarx != NULL)\r\n  {\r\n    /* Set the UART DMA transfer complete callback */\r\n    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;\r\n\r\n    /* Set the UART DMA Half transfer complete callback */\r\n    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;\r\n\r\n    /* Set the DMA error callback */\r\n    huart->hdmarx->XferErrorCallback = UART_DMAError;\r\n\r\n    /* Set the DMA abort callback */\r\n    huart->hdmarx->XferAbortCallback = NULL;\r\n\r\n    /* Enable the DMA channel */\r\n    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)\r\n    {\r\n      /* Set error code to DMA */\r\n      huart->ErrorCode = HAL_UART_ERROR_DMA;\r\n\r\n      __HAL_UNLOCK(huart);\r\n\r\n      /* Restore huart->RxState to ready */\r\n      huart->RxState = HAL_UART_STATE_READY;\r\n\r\n      return HAL_ERROR;\r\n    }\r\n  }\r\n  __HAL_UNLOCK(huart);\r\n\r\n  /* Enable the UART Parity Error Interrupt */\r\n  if (huart->Init.Parity != UART_PARITY_NONE)\r\n  {\r\n    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n  }\r\n\r\n  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */\r\n  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n  /* Enable the DMA transfer for the receiver request by setting the DMAR bit\r\n  in the UART CR3 register */\r\n  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_EndTxTransfer(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable TXEIE, TCIE, TXFT interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));\r\n\r\n  /* At end of Tx process, restore huart->gState to Ready */\r\n  huart->gState = HAL_UART_STATE_READY;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_EndRxTransfer(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));\r\n\r\n  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n  }\r\n\r\n  /* At end of Rx process, restore huart->RxState to Ready */\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  /* Reset RxIsr function pointer */\r\n  huart->RxISR = NULL;\r\n}\r\n\r\n\r\n/**\r\n  * @brief DMA UART transmit process complete callback.\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  /* DMA Normal mode */\r\n  if (hdma->Init.Mode != DMA_CIRCULAR)\r\n  {\r\n    huart->TxXferCount = 0U;\r\n\r\n    /* Disable the DMA transfer for transmit request by resetting the DMAT bit\r\n       in the UART CR3 register */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);\r\n\r\n    /* Enable the UART Transmit Complete Interrupt */\r\n    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\r\n  }\r\n  /* DMA Circular mode */\r\n  else\r\n  {\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /*Call registered Tx complete callback*/\r\n    huart->TxCpltCallback(huart);\r\n#else\r\n    /*Call legacy weak Tx complete callback*/\r\n    HAL_UART_TxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA UART transmit process half complete callback.\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /*Call registered Tx Half complete callback*/\r\n  huart->TxHalfCpltCallback(huart);\r\n#else\r\n  /*Call legacy weak Tx Half complete callback*/\r\n  HAL_UART_TxHalfCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief DMA UART receive process complete callback.\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  /* DMA Normal mode */\r\n  if (hdma->Init.Mode != DMA_CIRCULAR)\r\n  {\r\n    huart->RxXferCount = 0U;\r\n\r\n    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit\r\n       in the UART CR3 register */\r\n    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);\r\n\r\n    /* At end of Rx process, restore huart->RxState to Ready */\r\n    huart->RxState = HAL_UART_STATE_READY;\r\n\r\n    /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */\r\n    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n    {\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n    }\r\n  }\r\n\r\n  /* Check current reception Mode :\r\n     If Reception till IDLE event has been selected : use Rx Event callback */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /*Call registered Rx Event callback*/\r\n    huart->RxEventCallback(huart, huart->RxXferSize);\r\n#else\r\n    /*Call legacy weak Rx Event callback*/\r\n    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    /* In other cases : use Rx Complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /*Call registered Rx complete callback*/\r\n    huart->RxCpltCallback(huart);\r\n#else\r\n    /*Call legacy weak Rx complete callback*/\r\n    HAL_UART_RxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA UART receive process half complete callback.\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  /* Check current reception Mode :\r\n     If Reception till IDLE event has been selected : use Rx Event callback */\r\n  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n  {\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /*Call registered Rx Event callback*/\r\n    huart->RxEventCallback(huart, huart->RxXferSize / 2U);\r\n#else\r\n    /*Call legacy weak Rx Event callback*/\r\n    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n  else\r\n  {\r\n    /* In other cases : use Rx Half Complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    /*Call registered Rx Half complete callback*/\r\n    huart->RxHalfCpltCallback(huart);\r\n#else\r\n    /*Call legacy weak Rx Half complete callback*/\r\n    HAL_UART_RxHalfCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief DMA UART communication error callback.\r\n  * @param hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMAError(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  const HAL_UART_StateTypeDef gstate = huart->gState;\r\n  const HAL_UART_StateTypeDef rxstate = huart->RxState;\r\n\r\n  /* Stop UART DMA Tx request if ongoing */\r\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&\r\n      (gstate == HAL_UART_STATE_BUSY_TX))\r\n  {\r\n    huart->TxXferCount = 0U;\r\n    UART_EndTxTransfer(huart);\r\n  }\r\n\r\n  /* Stop UART DMA Rx request if ongoing */\r\n  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&\r\n      (rxstate == HAL_UART_STATE_BUSY_RX))\r\n  {\r\n    huart->RxXferCount = 0U;\r\n    UART_EndRxTransfer(huart);\r\n  }\r\n\r\n  huart->ErrorCode |= HAL_UART_ERROR_DMA;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /*Call registered error callback*/\r\n  huart->ErrorCallback(huart);\r\n#else\r\n  /*Call legacy weak error callback*/\r\n  HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA UART communication abort callback, when initiated by HAL services on Error\r\n  *         (To be called at end of DMA Abort procedure following error occurrence).\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n  huart->RxXferCount = 0U;\r\n  huart->TxXferCount = 0U;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /*Call registered error callback*/\r\n  huart->ErrorCallback(huart);\r\n#else\r\n  /*Call legacy weak error callback*/\r\n  HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA UART Tx communication abort callback, when initiated by user\r\n  *         (To be called at end of DMA Tx Abort procedure following user abort request).\r\n  * @note   When this callback is executed, User Abort complete call back is called only if no\r\n  *         Abort still ongoing for Rx DMA Handle.\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  huart->hdmatx->XferAbortCallback = NULL;\r\n\r\n  /* Check if an Abort process is still ongoing */\r\n  if (huart->hdmarx != NULL)\r\n  {\r\n    if (huart->hdmarx->XferAbortCallback != NULL)\r\n    {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */\r\n  huart->TxXferCount = 0U;\r\n  huart->RxXferCount = 0U;\r\n\r\n  /* Reset errorCode */\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n\r\n  /* Clear the Error flags in the ICR register */\r\n  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n  /* Flush the whole TX FIFO (if needed) */\r\n  if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n  {\r\n    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\r\n  }\r\n\r\n  /* Restore huart->gState and huart->RxState to Ready */\r\n  huart->gState  = HAL_UART_STATE_READY;\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  /* Call user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /* Call registered Abort complete callback */\r\n  huart->AbortCpltCallback(huart);\r\n#else\r\n  /* Call legacy weak Abort complete callback */\r\n  HAL_UART_AbortCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  DMA UART Rx communication abort callback, when initiated by user\r\n  *         (To be called at end of DMA Rx Abort procedure following user abort request).\r\n  * @note   When this callback is executed, User Abort complete call back is called only if no\r\n  *         Abort still ongoing for Tx DMA Handle.\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  huart->hdmarx->XferAbortCallback = NULL;\r\n\r\n  /* Check if an Abort process is still ongoing */\r\n  if (huart->hdmatx != NULL)\r\n  {\r\n    if (huart->hdmatx->XferAbortCallback != NULL)\r\n    {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */\r\n  huart->TxXferCount = 0U;\r\n  huart->RxXferCount = 0U;\r\n\r\n  /* Reset errorCode */\r\n  huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n\r\n  /* Clear the Error flags in the ICR register */\r\n  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n  /* Discard the received data */\r\n  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n\r\n  /* Restore huart->gState and huart->RxState to Ready */\r\n  huart->gState  = HAL_UART_STATE_READY;\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  /* Call user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /* Call registered Abort complete callback */\r\n  huart->AbortCpltCallback(huart);\r\n#else\r\n  /* Call legacy weak Abort complete callback */\r\n  HAL_UART_AbortCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n\r\n/**\r\n  * @brief  DMA UART Tx communication abort callback, when initiated by user by a call to\r\n  *         HAL_UART_AbortTransmit_IT API (Abort only Tx transfer)\r\n  *         (This callback is executed at end of DMA Tx Abort procedure following user abort request,\r\n  *         and leads to user Tx Abort Complete callback execution).\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);\r\n\r\n  huart->TxXferCount = 0U;\r\n\r\n  /* Flush the whole TX FIFO (if needed) */\r\n  if (huart->FifoMode == UART_FIFOMODE_ENABLE)\r\n  {\r\n    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);\r\n  }\r\n\r\n  /* Restore huart->gState to Ready */\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  /* Call user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /* Call registered Abort Transmit Complete Callback */\r\n  huart->AbortTransmitCpltCallback(huart);\r\n#else\r\n  /* Call legacy weak Abort Transmit Complete Callback */\r\n  HAL_UART_AbortTransmitCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief  DMA UART Rx communication abort callback, when initiated by user by a call to\r\n  *         HAL_UART_AbortReceive_IT API (Abort only Rx transfer)\r\n  *         (This callback is executed at end of DMA Rx Abort procedure following user abort request,\r\n  *         and leads to user Rx Abort Complete callback execution).\r\n  * @param  hdma DMA handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)\r\n{\r\n  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;\r\n\r\n  huart->RxXferCount = 0U;\r\n\r\n  /* Clear the Error flags in the ICR register */\r\n  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);\r\n\r\n  /* Discard the received data */\r\n  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n\r\n  /* Restore huart->RxState to Ready */\r\n  huart->RxState = HAL_UART_STATE_READY;\r\n  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n  /* Call user Abort complete callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /* Call registered Abort Receive Complete Callback */\r\n  huart->AbortReceiveCpltCallback(huart);\r\n#else\r\n  /* Call legacy weak Abort Receive Complete Callback */\r\n  HAL_UART_AbortReceiveCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief TX interrupt handler for 7 or 8 bits data word length .\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Transmit_IT().\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_TxISR_8BIT(UART_HandleTypeDef *huart)\r\n{\r\n  /* Check that a Tx process is ongoing */\r\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\r\n  {\r\n    if (huart->TxXferCount == 0U)\r\n    {\r\n      /* Disable the UART Transmit Data Register Empty Interrupt */\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);\r\n\r\n      /* Enable the UART Transmit Complete Interrupt */\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\r\n    }\r\n    else\r\n    {\r\n      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);\r\n      huart->pTxBuffPtr++;\r\n      huart->TxXferCount--;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief TX interrupt handler for 9 bits data word length.\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Transmit_IT().\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_TxISR_16BIT(UART_HandleTypeDef *huart)\r\n{\r\n  const uint16_t *tmp;\r\n\r\n  /* Check that a Tx process is ongoing */\r\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\r\n  {\r\n    if (huart->TxXferCount == 0U)\r\n    {\r\n      /* Disable the UART Transmit Data Register Empty Interrupt */\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);\r\n\r\n      /* Enable the UART Transmit Complete Interrupt */\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\r\n    }\r\n    else\r\n    {\r\n      tmp = (const uint16_t *) huart->pTxBuffPtr;\r\n      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);\r\n      huart->pTxBuffPtr += 2U;\r\n      huart->TxXferCount--;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief TX interrupt handler for 7 or 8 bits data word length and FIFO mode is enabled.\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Transmit_IT().\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)\r\n{\r\n  uint16_t  nb_tx_data;\r\n\r\n  /* Check that a Tx process is ongoing */\r\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\r\n  {\r\n    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)\r\n    {\r\n      if (huart->TxXferCount == 0U)\r\n      {\r\n        /* Disable the TX FIFO threshold interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\r\n\r\n        /* Enable the UART Transmit Complete Interrupt */\r\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\r\n\r\n        break; /* force exit loop */\r\n      }\r\n      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)\r\n      {\r\n        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);\r\n        huart->pTxBuffPtr++;\r\n        huart->TxXferCount--;\r\n      }\r\n      else\r\n      {\r\n        /* Nothing to do */\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief TX interrupt handler for 9 bits data word length and FIFO mode is enabled.\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Transmit_IT().\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_TxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)\r\n{\r\n  const uint16_t *tmp;\r\n  uint16_t  nb_tx_data;\r\n\r\n  /* Check that a Tx process is ongoing */\r\n  if (huart->gState == HAL_UART_STATE_BUSY_TX)\r\n  {\r\n    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)\r\n    {\r\n      if (huart->TxXferCount == 0U)\r\n      {\r\n        /* Disable the TX FIFO threshold interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);\r\n\r\n        /* Enable the UART Transmit Complete Interrupt */\r\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);\r\n\r\n        break; /* force exit loop */\r\n      }\r\n      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)\r\n      {\r\n        tmp = (const uint16_t *) huart->pTxBuffPtr;\r\n        huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);\r\n        huart->pTxBuffPtr += 2U;\r\n        huart->TxXferCount--;\r\n      }\r\n      else\r\n      {\r\n        /* Nothing to do */\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Wrap up transmission in non-blocking mode.\r\n  * @param  huart pointer to a UART_HandleTypeDef structure that contains\r\n  *                the configuration information for the specified UART module.\r\n  * @retval None\r\n  */\r\nstatic void UART_EndTransmit_IT(UART_HandleTypeDef *huart)\r\n{\r\n  /* Disable the UART Transmit Complete Interrupt */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);\r\n\r\n  /* Tx process is ended, restore huart->gState to Ready */\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  /* Cleat TxISR function pointer */\r\n  huart->TxISR = NULL;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n  /*Call registered Tx complete callback*/\r\n  huart->TxCpltCallback(huart);\r\n#else\r\n  /*Call legacy weak Tx complete callback*/\r\n  HAL_UART_TxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n}\r\n\r\n/**\r\n  * @brief RX interrupt handler for 7 or 8 bits data word length .\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_RxISR_8BIT(UART_HandleTypeDef *huart)\r\n{\r\n  uint16_t uhMask = huart->Mask;\r\n  uint16_t  uhdata;\r\n\r\n  /* Check that a Rx process is ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_BUSY_RX)\r\n  {\r\n    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);\r\n    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);\r\n    huart->pRxBuffPtr++;\r\n    huart->RxXferCount--;\r\n\r\n    if (huart->RxXferCount == 0U)\r\n    {\r\n      /* Disable the UART Parity Error Interrupt and RXNE interrupts */\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));\r\n\r\n      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n      /* Rx process is completed, restore huart->RxState to Ready */\r\n      huart->RxState = HAL_UART_STATE_READY;\r\n\r\n      /* Clear RxISR function pointer */\r\n      huart->RxISR = NULL;\r\n\r\n      /* Check current reception Mode :\r\n         If Reception till IDLE event has been selected : */\r\n      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n      {\r\n        /* Set reception type to Standard */\r\n        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n        /* Disable IDLE interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n\r\n        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)\r\n        {\r\n          /* Clear IDLE Flag */\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n        }\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered Rx Event callback*/\r\n        huart->RxEventCallback(huart, huart->RxXferSize);\r\n#else\r\n        /*Call legacy weak Rx Event callback*/\r\n        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n      }\r\n      else\r\n      {\r\n        /* Standard reception API called */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered Rx complete callback*/\r\n        huart->RxCpltCallback(huart);\r\n#else\r\n        /*Call legacy weak Rx complete callback*/\r\n        HAL_UART_RxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Clear RXNE interrupt flag */\r\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief RX interrupt handler for 9 bits data word length .\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Receive_IT()\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_RxISR_16BIT(UART_HandleTypeDef *huart)\r\n{\r\n  uint16_t *tmp;\r\n  uint16_t uhMask = huart->Mask;\r\n  uint16_t  uhdata;\r\n\r\n  /* Check that a Rx process is ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_BUSY_RX)\r\n  {\r\n    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);\r\n    tmp = (uint16_t *) huart->pRxBuffPtr ;\r\n    *tmp = (uint16_t)(uhdata & uhMask);\r\n    huart->pRxBuffPtr += 2U;\r\n    huart->RxXferCount--;\r\n\r\n    if (huart->RxXferCount == 0U)\r\n    {\r\n      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));\r\n\r\n      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);\r\n\r\n      /* Rx process is completed, restore huart->RxState to Ready */\r\n      huart->RxState = HAL_UART_STATE_READY;\r\n\r\n      /* Clear RxISR function pointer */\r\n      huart->RxISR = NULL;\r\n\r\n      /* Check current reception Mode :\r\n         If Reception till IDLE event has been selected : */\r\n      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n      {\r\n        /* Set reception type to Standard */\r\n        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n        /* Disable IDLE interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n\r\n        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)\r\n        {\r\n          /* Clear IDLE Flag */\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n        }\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered Rx Event callback*/\r\n        huart->RxEventCallback(huart, huart->RxXferSize);\r\n#else\r\n        /*Call legacy weak Rx Event callback*/\r\n        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n      }\r\n      else\r\n      {\r\n        /* Standard reception API called */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n        /*Call registered Rx complete callback*/\r\n        huart->RxCpltCallback(huart);\r\n#else\r\n        /*Call legacy weak Rx complete callback*/\r\n        HAL_UART_RxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Clear RXNE interrupt flag */\r\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief RX interrupt handler for 7 or 8  bits data word length and FIFO mode is enabled.\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Receive_IT()\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)\r\n{\r\n  uint16_t  uhMask = huart->Mask;\r\n  uint16_t  uhdata;\r\n  uint16_t  nb_rx_data;\r\n  uint16_t  rxdatacount;\r\n  uint32_t  isrflags = READ_REG(huart->Instance->ISR);\r\n  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);\r\n  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);\r\n\r\n  /* Check that a Rx process is ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_BUSY_RX)\r\n  {\r\n    nb_rx_data = huart->NbRxDataToProcess;\r\n    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))\r\n    {\r\n      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);\r\n      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);\r\n      huart->pRxBuffPtr++;\r\n      huart->RxXferCount--;\r\n      isrflags = READ_REG(huart->Instance->ISR);\r\n\r\n      /* If some non blocking errors occurred */\r\n      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)\r\n      {\r\n        /* UART parity error interrupt occurred -------------------------------------*/\r\n        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))\r\n        {\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);\r\n\r\n          huart->ErrorCode |= HAL_UART_ERROR_PE;\r\n        }\r\n\r\n        /* UART frame error interrupt occurred --------------------------------------*/\r\n        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))\r\n        {\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);\r\n\r\n          huart->ErrorCode |= HAL_UART_ERROR_FE;\r\n        }\r\n\r\n        /* UART noise error interrupt occurred --------------------------------------*/\r\n        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))\r\n        {\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);\r\n\r\n          huart->ErrorCode |= HAL_UART_ERROR_NE;\r\n        }\r\n\r\n        /* Call UART Error Call back function if need be ----------------------------*/\r\n        if (huart->ErrorCode != HAL_UART_ERROR_NONE)\r\n        {\r\n          /* Non Blocking error : transfer could go on.\r\n          Error is notified to user through user error callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered error callback*/\r\n          huart->ErrorCallback(huart);\r\n#else\r\n          /*Call legacy weak error callback*/\r\n          HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n          huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n        }\r\n      }\r\n\r\n      if (huart->RxXferCount == 0U)\r\n      {\r\n        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n\r\n        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)\r\n           and RX FIFO Threshold interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));\r\n\r\n        /* Rx process is completed, restore huart->RxState to Ready */\r\n        huart->RxState = HAL_UART_STATE_READY;\r\n\r\n        /* Clear RxISR function pointer */\r\n        huart->RxISR = NULL;\r\n\r\n        /* Check current reception Mode :\r\n           If Reception till IDLE event has been selected : */\r\n        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n        {\r\n          /* Set reception type to Standard */\r\n          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n          /* Disable IDLE interrupt */\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n\r\n          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)\r\n          {\r\n            /* Clear IDLE Flag */\r\n            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n          }\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered Rx Event callback*/\r\n          huart->RxEventCallback(huart, huart->RxXferSize);\r\n#else\r\n          /*Call legacy weak Rx Event callback*/\r\n          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n        }\r\n        else\r\n        {\r\n          /* Standard reception API called */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered Rx complete callback*/\r\n          huart->RxCpltCallback(huart);\r\n#else\r\n          /*Call legacy weak Rx complete callback*/\r\n          HAL_UART_RxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n    }\r\n\r\n    /* When remaining number of bytes to receive is less than the RX FIFO\r\n    threshold, next incoming frames are processed as if FIFO mode was\r\n    disabled (i.e. one interrupt per received frame).\r\n    */\r\n    rxdatacount = huart->RxXferCount;\r\n    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))\r\n    {\r\n      /* Disable the UART RXFT interrupt*/\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);\r\n\r\n      /* Update the RxISR function pointer */\r\n      huart->RxISR = UART_RxISR_8BIT;\r\n\r\n      /* Enable the UART Data Register Not Empty interrupt */\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Clear RXNE interrupt flag */\r\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief RX interrupt handler for 9 bits data word length and FIFO mode is enabled.\r\n  * @note   Function is called under interruption only, once\r\n  *         interruptions have been enabled by HAL_UART_Receive_IT()\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)\r\n{\r\n  uint16_t *tmp;\r\n  uint16_t  uhMask = huart->Mask;\r\n  uint16_t  uhdata;\r\n  uint16_t  nb_rx_data;\r\n  uint16_t  rxdatacount;\r\n  uint32_t  isrflags = READ_REG(huart->Instance->ISR);\r\n  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);\r\n  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);\r\n\r\n  /* Check that a Rx process is ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_BUSY_RX)\r\n  {\r\n    nb_rx_data = huart->NbRxDataToProcess;\r\n    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))\r\n    {\r\n      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);\r\n      tmp = (uint16_t *) huart->pRxBuffPtr ;\r\n      *tmp = (uint16_t)(uhdata & uhMask);\r\n      huart->pRxBuffPtr += 2U;\r\n      huart->RxXferCount--;\r\n      isrflags = READ_REG(huart->Instance->ISR);\r\n\r\n      /* If some non blocking errors occurred */\r\n      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)\r\n      {\r\n        /* UART parity error interrupt occurred -------------------------------------*/\r\n        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))\r\n        {\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);\r\n\r\n          huart->ErrorCode |= HAL_UART_ERROR_PE;\r\n        }\r\n\r\n        /* UART frame error interrupt occurred --------------------------------------*/\r\n        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))\r\n        {\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);\r\n\r\n          huart->ErrorCode |= HAL_UART_ERROR_FE;\r\n        }\r\n\r\n        /* UART noise error interrupt occurred --------------------------------------*/\r\n        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))\r\n        {\r\n          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);\r\n\r\n          huart->ErrorCode |= HAL_UART_ERROR_NE;\r\n        }\r\n\r\n        /* Call UART Error Call back function if need be ----------------------------*/\r\n        if (huart->ErrorCode != HAL_UART_ERROR_NONE)\r\n        {\r\n          /* Non Blocking error : transfer could go on.\r\n          Error is notified to user through user error callback */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered error callback*/\r\n          huart->ErrorCallback(huart);\r\n#else\r\n          /*Call legacy weak error callback*/\r\n          HAL_UART_ErrorCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n          huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n        }\r\n      }\r\n\r\n      if (huart->RxXferCount == 0U)\r\n      {\r\n        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);\r\n\r\n        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)\r\n           and RX FIFO Threshold interrupt */\r\n        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));\r\n\r\n        /* Rx process is completed, restore huart->RxState to Ready */\r\n        huart->RxState = HAL_UART_STATE_READY;\r\n\r\n        /* Clear RxISR function pointer */\r\n        huart->RxISR = NULL;\r\n\r\n        /* Check current reception Mode :\r\n           If Reception till IDLE event has been selected : */\r\n        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n        {\r\n          /* Set reception type to Standard */\r\n          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;\r\n\r\n          /* Disable IDLE interrupt */\r\n          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n\r\n          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)\r\n          {\r\n            /* Clear IDLE Flag */\r\n            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n          }\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered Rx Event callback*/\r\n          huart->RxEventCallback(huart, huart->RxXferSize);\r\n#else\r\n          /*Call legacy weak Rx Event callback*/\r\n          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n        }\r\n        else\r\n        {\r\n          /* Standard reception API called */\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n          /*Call registered Rx complete callback*/\r\n          huart->RxCpltCallback(huart);\r\n#else\r\n          /*Call legacy weak Rx complete callback*/\r\n          HAL_UART_RxCpltCallback(huart);\r\n#endif /* USE_HAL_UART_REGISTER_CALLBACKS */\r\n        }\r\n      }\r\n    }\r\n\r\n    /* When remaining number of bytes to receive is less than the RX FIFO\r\n    threshold, next incoming frames are processed as if FIFO mode was\r\n    disabled (i.e. one interrupt per received frame).\r\n    */\r\n    rxdatacount = huart->RxXferCount;\r\n    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))\r\n    {\r\n      /* Disable the UART RXFT interrupt*/\r\n      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);\r\n\r\n      /* Update the RxISR function pointer */\r\n      huart->RxISR = UART_RxISR_16BIT;\r\n\r\n      /* Enable the UART Data Register Not Empty interrupt */\r\n      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /* Clear RXNE interrupt flag */\r\n    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_UART_MODULE_ENABLED */\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_hal_uart_ex.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_hal_uart_ex.c\r\n  * @author  MCD Application Team\r\n  * @brief   Extended UART HAL module driver.\r\n  *          This file provides firmware functions to manage the following extended\r\n  *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).\r\n  *           + Initialization and de-initialization functions\r\n  *           + Peripheral Control functions\r\n  *\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  @verbatim\r\n  ==============================================================================\r\n               ##### UART peripheral extended features  #####\r\n  ==============================================================================\r\n\r\n    (#) Declare a UART_HandleTypeDef handle structure.\r\n\r\n    (#) For the UART RS485 Driver Enable mode, initialize the UART registers\r\n        by calling the HAL_RS485Ex_Init() API.\r\n\r\n    (#) FIFO mode enabling/disabling and RX/TX FIFO threshold programming.\r\n\r\n        -@- When UART operates in FIFO mode, FIFO mode must be enabled prior\r\n            starting RX/TX transfers. Also RX/TX FIFO thresholds must be\r\n            configured prior starting RX/TX transfers.\r\n\r\n  @endverbatim\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_hal.h\"\r\n\r\n/** @addtogroup STM32H7xx_HAL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @defgroup UARTEx UARTEx\r\n  * @brief UART Extended HAL module driver\r\n  * @{\r\n  */\r\n\r\n#ifdef HAL_UART_MODULE_ENABLED\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* Private define ------------------------------------------------------------*/\r\n/** @defgroup UARTEX_Private_Constants UARTEx Private Constants\r\n  * @{\r\n  */\r\n/* UART RX FIFO depth */\r\n#define RX_FIFO_DEPTH 16U\r\n\r\n/* UART TX FIFO depth */\r\n#define TX_FIFO_DEPTH 16U\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup UARTEx_Private_Functions UARTEx Private Functions\r\n  * @{\r\n  */\r\nstatic void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection);\r\nstatic void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n\r\n/** @defgroup UARTEx_Exported_Functions  UARTEx Exported Functions\r\n  * @{\r\n  */\r\n\r\n/** @defgroup UARTEx_Exported_Functions_Group1 Initialization and de-initialization functions\r\n  * @brief    Extended Initialization and Configuration Functions\r\n  *\r\n@verbatim\r\n===============================================================================\r\n            ##### Initialization and Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n    This subsection provides a set of functions allowing to initialize the USARTx or the UARTy\r\n    in asynchronous mode.\r\n      (+) For the asynchronous mode the parameters below can be configured:\r\n        (++) Baud Rate\r\n        (++) Word Length\r\n        (++) Stop Bit\r\n        (++) Parity: If the parity is enabled, then the MSB bit of the data written\r\n             in the data register is transmitted but is changed by the parity bit.\r\n        (++) Hardware flow control\r\n        (++) Receiver/transmitter modes\r\n        (++) Over Sampling Method\r\n        (++) One-Bit Sampling Method\r\n      (+) For the asynchronous mode, the following advanced features can be configured as well:\r\n        (++) TX and/or RX pin level inversion\r\n        (++) data logical level inversion\r\n        (++) RX and TX pins swap\r\n        (++) RX overrun detection disabling\r\n        (++) DMA disabling on RX error\r\n        (++) MSB first on communication line\r\n        (++) auto Baud rate detection\r\n    [..]\r\n    The HAL_RS485Ex_Init() API follows the UART RS485 mode configuration\r\n     procedures (details for the procedures are available in reference manual).\r\n\r\n@endverbatim\r\n\r\n  Depending on the frame length defined by the M1 and M0 bits (7-bit,\r\n  8-bit or 9-bit), the possible UART formats are listed in the\r\n  following table.\r\n\r\n    Table 1. UART frame format.\r\n    +-----------------------------------------------------------------------+\r\n    |  M1 bit |  M0 bit |  PCE bit  |             UART frame                |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |\r\n    |---------|---------|-----------|---------------------------------------|\r\n    |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |\r\n    +-----------------------------------------------------------------------+\r\n\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Initialize the RS485 Driver enable feature according to the specified\r\n  *         parameters in the UART_InitTypeDef and creates the associated handle.\r\n  * @param huart            UART handle.\r\n  * @param Polarity         Select the driver enable polarity.\r\n  *          This parameter can be one of the following values:\r\n  *          @arg @ref UART_DE_POLARITY_HIGH DE signal is active high\r\n  *          @arg @ref UART_DE_POLARITY_LOW  DE signal is active low\r\n  * @param AssertionTime    Driver Enable assertion time:\r\n  *       5-bit value defining the time between the activation of the DE (Driver Enable)\r\n  *       signal and the beginning of the start bit. It is expressed in sample time\r\n  *       units (1/8 or 1/16 bit time, depending on the oversampling rate)\r\n  * @param DeassertionTime  Driver Enable deassertion time:\r\n  *       5-bit value defining the time between the end of the last stop bit, in a\r\n  *       transmitted message, and the de-activation of the DE (Driver Enable) signal.\r\n  *       It is expressed in sample time units (1/8 or 1/16 bit time, depending on the\r\n  *       oversampling rate).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime,\r\n                                   uint32_t DeassertionTime)\r\n{\r\n  uint32_t temp;\r\n\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n  /* Check the Driver Enable UART instance */\r\n  assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));\r\n\r\n  /* Check the Driver Enable polarity */\r\n  assert_param(IS_UART_DE_POLARITY(Polarity));\r\n\r\n  /* Check the Driver Enable assertion time */\r\n  assert_param(IS_UART_ASSERTIONTIME(AssertionTime));\r\n\r\n  /* Check the Driver Enable deassertion time */\r\n  assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));\r\n\r\n  if (huart->gState == HAL_UART_STATE_RESET)\r\n  {\r\n    /* Allocate lock resource and initialize it */\r\n    huart->Lock = HAL_UNLOCKED;\r\n\r\n#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)\r\n    UART_InitCallbacksToDefault(huart);\r\n\r\n    if (huart->MspInitCallback == NULL)\r\n    {\r\n      huart->MspInitCallback = HAL_UART_MspInit;\r\n    }\r\n\r\n    /* Init the low level hardware */\r\n    huart->MspInitCallback(huart);\r\n#else\r\n    /* Init the low level hardware : GPIO, CLOCK, CORTEX */\r\n    HAL_UART_MspInit(huart);\r\n#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */\r\n  }\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the UART Communication parameters */\r\n  if (UART_SetConfig(huart) == HAL_ERROR)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)\r\n  {\r\n    UART_AdvFeatureConfig(huart);\r\n  }\r\n\r\n  /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */\r\n  SET_BIT(huart->Instance->CR3, USART_CR3_DEM);\r\n\r\n  /* Set the Driver Enable polarity */\r\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);\r\n\r\n  /* Set the Driver Enable assertion and deassertion times */\r\n  temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);\r\n  temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);\r\n  MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT | USART_CR1_DEAT), temp);\r\n\r\n  /* Enable the Peripheral */\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup UARTEx_Exported_Functions_Group2 IO operation functions\r\n  *  @brief Extended functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### IO operation functions #####\r\n ===============================================================================\r\n    This subsection provides a set of Wakeup and FIFO mode related callback functions.\r\n\r\n    (#) Wakeup from Stop mode Callback:\r\n        (+) HAL_UARTEx_WakeupCallback()\r\n\r\n    (#) TX/RX Fifos Callbacks:\r\n        (+) HAL_UARTEx_RxFifoFullCallback()\r\n        (+) HAL_UARTEx_TxFifoEmptyCallback()\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief UART wakeup from Stop mode callback.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UARTEx_WakeupCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  UART RX Fifo full callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UARTEx_RxFifoFullCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @brief  UART TX Fifo empty callback.\r\n  * @param  huart UART handle.\r\n  * @retval None\r\n  */\r\n__weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)\r\n{\r\n  /* Prevent unused argument(s) compilation warning */\r\n  UNUSED(huart);\r\n\r\n  /* NOTE : This function should not be modified, when the callback is needed,\r\n            the HAL_UARTEx_TxFifoEmptyCallback can be implemented in the user file.\r\n   */\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup UARTEx_Exported_Functions_Group3 Peripheral Control functions\r\n  * @brief    Extended Peripheral Control functions\r\n  *\r\n@verbatim\r\n ===============================================================================\r\n                      ##### Peripheral Control functions #####\r\n ===============================================================================\r\n    [..] This section provides the following functions:\r\n     (+) HAL_MultiProcessorEx_AddressLength_Set() API optionally sets the UART node address\r\n         detection length to more than 4 bits for multiprocessor address mark wake up.\r\n     (+) HAL_UARTEx_StopModeWakeUpSourceConfig() API defines the wake-up from stop mode\r\n         trigger: address match, Start Bit detection or RXNE bit status.\r\n     (+) HAL_UARTEx_EnableStopMode() API enables the UART to wake up the MCU from stop mode\r\n     (+) HAL_UARTEx_DisableStopMode() API disables the above functionality\r\n     (+) HAL_UARTEx_EnableFifoMode() API enables the FIFO mode\r\n     (+) HAL_UARTEx_DisableFifoMode() API disables the FIFO mode\r\n     (+) HAL_UARTEx_SetTxFifoThreshold() API sets the TX FIFO threshold\r\n     (+) HAL_UARTEx_SetRxFifoThreshold() API sets the RX FIFO threshold\r\n\r\n    [..] This subsection also provides a set of additional functions providing enhanced reception\r\n    services to user. (For example, these functions allow application to handle use cases\r\n    where number of data to be received is unknown).\r\n\r\n    (#) Compared to standard reception services which only consider number of received\r\n        data elements as reception completion criteria, these functions also consider additional events\r\n        as triggers for updating reception status to caller :\r\n       (+) Detection of inactivity period (RX line has not been active for a given period).\r\n          (++) RX inactivity detected by IDLE event, i.e. RX line has been in idle state (normally high state)\r\n               for 1 frame time, after last received byte.\r\n          (++) RX inactivity detected by RTO, i.e. line has been in idle state\r\n               for a programmable time, after last received byte.\r\n       (+) Detection that a specific character has been received.\r\n\r\n    (#) There are two mode of transfer:\r\n       (+) Blocking mode: The reception is performed in polling mode, until either expected number of data is received,\r\n           or till IDLE event occurs. Reception is handled only during function execution.\r\n           When function exits, no data reception could occur. HAL status and number of actually received data elements,\r\n           are returned by function after finishing transfer.\r\n       (+) Non-Blocking mode: The reception is performed using Interrupts or DMA.\r\n           These API's return the HAL status.\r\n           The end of the data processing will be indicated through the\r\n           dedicated UART IRQ when using Interrupt mode or the DMA IRQ when using DMA mode.\r\n           The HAL_UARTEx_RxEventCallback() user callback will be executed during Receive process\r\n           The HAL_UART_ErrorCallback()user callback will be executed when a reception error is detected.\r\n\r\n    (#) Blocking mode API:\r\n        (+) HAL_UARTEx_ReceiveToIdle()\r\n\r\n    (#) Non-Blocking mode API with Interrupt:\r\n        (+) HAL_UARTEx_ReceiveToIdle_IT()\r\n\r\n    (#) Non-Blocking mode API with DMA:\r\n        (+) HAL_UARTEx_ReceiveToIdle_DMA()\r\n\r\n@endverbatim\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief By default in multiprocessor mode, when the wake up method is set\r\n  *        to address mark, the UART handles only 4-bit long addresses detection;\r\n  *        this API allows to enable longer addresses detection (6-, 7- or 8-bit\r\n  *        long).\r\n  * @note  Addresses detection lengths are: 6-bit address detection in 7-bit data mode,\r\n  *        7-bit address detection in 8-bit data mode, 8-bit address detection in 9-bit data mode.\r\n  * @param huart         UART handle.\r\n  * @param AddressLength This parameter can be one of the following values:\r\n  *          @arg @ref UART_ADDRESS_DETECT_4B 4-bit long address\r\n  *          @arg @ref UART_ADDRESS_DETECT_7B 6-, 7- or 8-bit long address\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)\r\n{\r\n  /* Check the UART handle allocation */\r\n  if (huart == NULL)\r\n  {\r\n    return HAL_ERROR;\r\n  }\r\n\r\n  /* Check the address length parameter */\r\n  assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the address length */\r\n  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);\r\n\r\n  /* Enable the Peripheral */\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* TEACK and/or REACK to check before moving huart->gState to Ready */\r\n  return (UART_CheckIdleState(huart));\r\n}\r\n\r\n/**\r\n  * @brief Set Wakeup from Stop mode interrupt flag selection.\r\n  * @note It is the application responsibility to enable the interrupt used as\r\n  *       usart_wkup interrupt source before entering low-power mode.\r\n  * @param huart           UART handle.\r\n  * @param WakeUpSelection Address match, Start Bit detection or RXNE/RXFNE bit status.\r\n  *          This parameter can be one of the following values:\r\n  *          @arg @ref UART_WAKEUP_ON_ADDRESS\r\n  *          @arg @ref UART_WAKEUP_ON_STARTBIT\r\n  *          @arg @ref UART_WAKEUP_ON_READDATA_NONEMPTY\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)\r\n{\r\n  HAL_StatusTypeDef status = HAL_OK;\r\n  uint32_t tickstart;\r\n\r\n  /* check the wake-up from stop mode UART instance */\r\n  assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));\r\n  /* check the wake-up selection parameter */\r\n  assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Disable the Peripheral */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Set the wake-up selection scheme */\r\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);\r\n\r\n  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)\r\n  {\r\n    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);\r\n  }\r\n\r\n  /* Enable the Peripheral */\r\n  __HAL_UART_ENABLE(huart);\r\n\r\n  /* Init tickstart for timeout management */\r\n  tickstart = HAL_GetTick();\r\n\r\n  /* Wait until REACK flag is set */\r\n  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)\r\n  {\r\n    status = HAL_TIMEOUT;\r\n  }\r\n  else\r\n  {\r\n    /* Initialize the UART State */\r\n    huart->gState = HAL_UART_STATE_READY;\r\n  }\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief Enable UART Stop Mode.\r\n  * @note The UART is able to wake up the MCU from Stop 1 mode as long as UART clock is HSI or LSE.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart)\r\n{\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  /* Set UESM bit */\r\n  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Disable UART Stop Mode.\r\n  * @param huart UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart)\r\n{\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  /* Clear UESM bit */\r\n  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Enable the FIFO mode.\r\n  * @param huart      UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_EnableFifoMode(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t tmpcr1;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Save actual UART configuration */\r\n  tmpcr1 = READ_REG(huart->Instance->CR1);\r\n\r\n  /* Disable UART */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Enable FIFO mode */\r\n  SET_BIT(tmpcr1, USART_CR1_FIFOEN);\r\n  huart->FifoMode = UART_FIFOMODE_ENABLE;\r\n\r\n  /* Restore UART configuration */\r\n  WRITE_REG(huart->Instance->CR1, tmpcr1);\r\n\r\n  /* Determine the number of data to process during RX/TX ISR execution */\r\n  UARTEx_SetNbDataToProcess(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Disable the FIFO mode.\r\n  * @param huart      UART handle.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)\r\n{\r\n  uint32_t tmpcr1;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Save actual UART configuration */\r\n  tmpcr1 = READ_REG(huart->Instance->CR1);\r\n\r\n  /* Disable UART */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Enable FIFO mode */\r\n  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);\r\n  huart->FifoMode = UART_FIFOMODE_DISABLE;\r\n\r\n  /* Restore UART configuration */\r\n  WRITE_REG(huart->Instance->CR1, tmpcr1);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Set the TXFIFO threshold.\r\n  * @param huart      UART handle.\r\n  * @param Threshold  TX FIFO threshold value\r\n  *          This parameter can be one of the following values:\r\n  *            @arg @ref UART_TXFIFO_THRESHOLD_1_8\r\n  *            @arg @ref UART_TXFIFO_THRESHOLD_1_4\r\n  *            @arg @ref UART_TXFIFO_THRESHOLD_1_2\r\n  *            @arg @ref UART_TXFIFO_THRESHOLD_3_4\r\n  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8\r\n  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)\r\n{\r\n  uint32_t tmpcr1;\r\n\r\n  /* Check parameters */\r\n  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));\r\n  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Save actual UART configuration */\r\n  tmpcr1 = READ_REG(huart->Instance->CR1);\r\n\r\n  /* Disable UART */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Update TX threshold configuration */\r\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);\r\n\r\n  /* Determine the number of data to process during RX/TX ISR execution */\r\n  UARTEx_SetNbDataToProcess(huart);\r\n\r\n  /* Restore UART configuration */\r\n  WRITE_REG(huart->Instance->CR1, tmpcr1);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Set the RXFIFO threshold.\r\n  * @param huart      UART handle.\r\n  * @param Threshold  RX FIFO threshold value\r\n  *          This parameter can be one of the following values:\r\n  *            @arg @ref UART_RXFIFO_THRESHOLD_1_8\r\n  *            @arg @ref UART_RXFIFO_THRESHOLD_1_4\r\n  *            @arg @ref UART_RXFIFO_THRESHOLD_1_2\r\n  *            @arg @ref UART_RXFIFO_THRESHOLD_3_4\r\n  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8\r\n  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)\r\n{\r\n  uint32_t tmpcr1;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));\r\n  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));\r\n\r\n  /* Process Locked */\r\n  __HAL_LOCK(huart);\r\n\r\n  huart->gState = HAL_UART_STATE_BUSY;\r\n\r\n  /* Save actual UART configuration */\r\n  tmpcr1 = READ_REG(huart->Instance->CR1);\r\n\r\n  /* Disable UART */\r\n  __HAL_UART_DISABLE(huart);\r\n\r\n  /* Update RX threshold configuration */\r\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);\r\n\r\n  /* Determine the number of data to process during RX/TX ISR execution */\r\n  UARTEx_SetNbDataToProcess(huart);\r\n\r\n  /* Restore UART configuration */\r\n  WRITE_REG(huart->Instance->CR1, tmpcr1);\r\n\r\n  huart->gState = HAL_UART_STATE_READY;\r\n\r\n  /* Process Unlocked */\r\n  __HAL_UNLOCK(huart);\r\n\r\n  return HAL_OK;\r\n}\r\n\r\n/**\r\n  * @brief Receive an amount of data in blocking mode till either the expected number of data\r\n  *        is received or an IDLE event occurs.\r\n  * @note  HAL_OK is returned if reception is completed (expected number of data has been received)\r\n  *        or if reception is stopped after IDLE event (less than the expected number of data has been received)\r\n  *        In this case, RxLen output parameter indicates number of data available in reception buffer.\r\n  * @note  When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *        the received data is handled as a set of uint16_t. In this case, Size must indicate the number\r\n  *        of uint16_t available through pData.\r\n  * @note When FIFO mode is enabled, the RXFNE flag is set as long as the RXFIFO\r\n  *       is not empty. Read operations from the RDR register are performed when\r\n  *       RXFNE flag is set. From hardware perspective, RXFNE flag and\r\n  *       RXNE are mapped on the same bit-field.\r\n  * @param huart   UART handle.\r\n  * @param pData   Pointer to data buffer (uint8_t or uint16_t data elements).\r\n  * @param Size    Amount of data elements (uint8_t or uint16_t) to be received.\r\n  * @param RxLen   Number of data elements finally received\r\n  *                (could be lower than Size, in case reception ends on IDLE event)\r\n  * @param Timeout Timeout duration expressed in ms (covers the whole reception sequence).\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,\r\n                                           uint32_t Timeout)\r\n{\r\n  uint8_t  *pdata8bits;\r\n  uint16_t *pdata16bits;\r\n  uint16_t uhMask;\r\n  uint32_t tickstart;\r\n\r\n  /* Check that a Rx process is not already ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return  HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    huart->ErrorCode = HAL_UART_ERROR_NONE;\r\n    huart->RxState = HAL_UART_STATE_BUSY_RX;\r\n    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;\r\n\r\n    /* Init tickstart for timeout management */\r\n    tickstart = HAL_GetTick();\r\n\r\n    huart->RxXferSize  = Size;\r\n    huart->RxXferCount = Size;\r\n\r\n    /* Computation of UART mask to apply to RDR register */\r\n    UART_MASK_COMPUTATION(huart);\r\n    uhMask = huart->Mask;\r\n\r\n    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */\r\n    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))\r\n    {\r\n      pdata8bits  = NULL;\r\n      pdata16bits = (uint16_t *) pData;\r\n    }\r\n    else\r\n    {\r\n      pdata8bits  = pData;\r\n      pdata16bits = NULL;\r\n    }\r\n\r\n    __HAL_UNLOCK(huart);\r\n\r\n    /* Initialize output number of received elements */\r\n    *RxLen = 0U;\r\n\r\n    /* as long as data have to be received */\r\n    while (huart->RxXferCount > 0U)\r\n    {\r\n      /* Check if IDLE flag is set */\r\n      if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))\r\n      {\r\n        /* Clear IDLE flag in ISR */\r\n        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n\r\n        /* If Set, but no data ever received, clear flag without exiting loop */\r\n        /* If Set, and data has already been received, this means Idle Event is valid : End reception */\r\n        if (*RxLen > 0U)\r\n        {\r\n          huart->RxState = HAL_UART_STATE_READY;\r\n\r\n          return HAL_OK;\r\n        }\r\n      }\r\n\r\n      /* Check if RXNE flag is set */\r\n      if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))\r\n      {\r\n        if (pdata8bits == NULL)\r\n        {\r\n          *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);\r\n          pdata16bits++;\r\n        }\r\n        else\r\n        {\r\n          *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);\r\n          pdata8bits++;\r\n        }\r\n        /* Increment number of received elements */\r\n        *RxLen += 1U;\r\n        huart->RxXferCount--;\r\n      }\r\n\r\n      /* Check for the Timeout */\r\n      if (Timeout != HAL_MAX_DELAY)\r\n      {\r\n        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\r\n        {\r\n          huart->RxState = HAL_UART_STATE_READY;\r\n\r\n          return HAL_TIMEOUT;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Set number of received elements in output parameter : RxLen */\r\n    *RxLen = huart->RxXferSize - huart->RxXferCount;\r\n    /* At end of Rx process, restore huart->RxState to Ready */\r\n    huart->RxState = HAL_UART_STATE_READY;\r\n\r\n    return HAL_OK;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Receive an amount of data in interrupt mode till either the expected number of data\r\n  *        is received or an IDLE event occurs.\r\n  * @note  Reception is initiated by this function call. Further progress of reception is achieved thanks\r\n  *        to UART interrupts raised by RXNE and IDLE events. Callback is called at end of reception indicating\r\n  *        number of received data elements.\r\n  * @note  When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *        the received data is handled as a set of uint16_t. In this case, Size must indicate the number\r\n  *        of uint16_t available through pData.\r\n  * @param huart UART handle.\r\n  * @param pData Pointer to data buffer (uint8_t or uint16_t data elements).\r\n  * @param Size  Amount of data elements (uint8_t or uint16_t) to be received.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  /* Check that a Rx process is not already ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    /* Set Reception type to reception till IDLE Event*/\r\n    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;\r\n\r\n    status =  UART_Start_Receive_IT(huart, pData, Size);\r\n\r\n    /* Check Rx process has been successfully started */\r\n    if (status == HAL_OK)\r\n    {\r\n      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n      {\r\n        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n      }\r\n      else\r\n      {\r\n        /* In case of errors already pending when reception is started,\r\n           Interrupts may have already been raised and lead to reception abortion.\r\n           (Overrun error for instance).\r\n           In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */\r\n        status = HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    return status;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief Receive an amount of data in DMA mode till either the expected number\r\n  *        of data is received or an IDLE event occurs.\r\n  * @note  Reception is initiated by this function call. Further progress of reception is achieved thanks\r\n  *        to DMA services, transferring automatically received data elements in user reception buffer and\r\n  *        calling registered callbacks at half/end of reception. UART IDLE events are also used to consider\r\n  *        reception phase as ended. In all cases, callback execution will indicate number of received data elements.\r\n  * @note  When the UART parity is enabled (PCE = 1), the received data contain\r\n  *        the parity bit (MSB position).\r\n  * @note  When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),\r\n  *        the received data is handled as a set of uint16_t. In this case, Size must indicate the number\r\n  *        of uint16_t available through pData.\r\n  * @param huart UART handle.\r\n  * @param pData Pointer to data buffer (uint8_t or uint16_t data elements).\r\n  * @param Size  Amount of data elements (uint8_t or uint16_t) to be received.\r\n  * @retval HAL status\r\n  */\r\nHAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\r\n{\r\n  HAL_StatusTypeDef status;\r\n\r\n  /* Check that a Rx process is not already ongoing */\r\n  if (huart->RxState == HAL_UART_STATE_READY)\r\n  {\r\n    if ((pData == NULL) || (Size == 0U))\r\n    {\r\n      return HAL_ERROR;\r\n    }\r\n\r\n    __HAL_LOCK(huart);\r\n\r\n    /* Set Reception type to reception till IDLE Event*/\r\n    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;\r\n\r\n    status =  UART_Start_Receive_DMA(huart, pData, Size);\r\n\r\n    /* Check Rx process has been successfully started */\r\n    if (status == HAL_OK)\r\n    {\r\n      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)\r\n      {\r\n        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);\r\n        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);\r\n      }\r\n      else\r\n      {\r\n        /* In case of errors already pending when reception is started,\r\n           Interrupts may have already been raised and lead to reception abortion.\r\n           (Overrun error for instance).\r\n           In such case Reception Type has been reset to HAL_UART_RECEPTION_STANDARD. */\r\n        status = HAL_ERROR;\r\n      }\r\n    }\r\n\r\n    return status;\r\n  }\r\n  else\r\n  {\r\n    return HAL_BUSY;\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup UARTEx_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief Initialize the UART wake-up from stop mode parameters when triggered by address detection.\r\n  * @param huart           UART handle.\r\n  * @param WakeUpSelection UART wake up from stop mode parameters.\r\n  * @retval None\r\n  */\r\nstatic void UARTEx_Wakeup_AddressConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)\r\n{\r\n  assert_param(IS_UART_ADDRESSLENGTH_DETECT(WakeUpSelection.AddressLength));\r\n\r\n  /* Set the USART address length */\r\n  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);\r\n\r\n  /* Set the USART address node */\r\n  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));\r\n}\r\n\r\n/**\r\n  * @brief Calculate the number of data to process in RX/TX ISR.\r\n  * @note The RX FIFO depth and the TX FIFO depth is extracted from\r\n  *       the UART configuration registers.\r\n  * @param huart UART handle.\r\n  * @retval None\r\n  */\r\nstatic void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)\r\n{\r\n  uint8_t rx_fifo_depth;\r\n  uint8_t tx_fifo_depth;\r\n  uint8_t rx_fifo_threshold;\r\n  uint8_t tx_fifo_threshold;\r\n  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};\r\n  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};\r\n\r\n  if (huart->FifoMode == UART_FIFOMODE_DISABLE)\r\n  {\r\n    huart->NbTxDataToProcess = 1U;\r\n    huart->NbRxDataToProcess = 1U;\r\n  }\r\n  else\r\n  {\r\n    rx_fifo_depth = RX_FIFO_DEPTH;\r\n    tx_fifo_depth = TX_FIFO_DEPTH;\r\n    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);\r\n    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);\r\n    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /\r\n                               (uint16_t)denominator[tx_fifo_threshold];\r\n    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /\r\n                               (uint16_t)denominator[rx_fifo_threshold];\r\n  }\r\n}\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* HAL_UART_MODULE_ENABLED */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"stm32h7xx_it.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_it.c\r\n  * @brief   Interrupt Service Routines.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2026 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"main.h\"\r\n#include \"stm32h7xx_it.h\"\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN TD */\r\n\r\n/* USER CODE END TD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN PV */\r\n\r\n/* USER CODE END PV */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN PFP */\r\n\r\n/* USER CODE END PFP */\r\n\r\n/* Private user code ---------------------------------------------------------*/\r\n/* USER CODE BEGIN 0 */\r\n\r\n/* USER CODE END 0 */\r\n\r\n/* External variables --------------------------------------------------------*/\r\nextern TIM_HandleTypeDef htim13;\r\nextern TIM_HandleTypeDef htim1;\r\n\r\n/* USER CODE BEGIN EV */\r\n\r\n/* USER CODE END EV */\r\n\r\n/******************************************************************************/\r\n/*           Cortex Processor Interruption and Exception Handlers          */\r\n/******************************************************************************/\r\n/**\r\n  * @brief This function handles Non maskable interrupt.\r\n  */\r\nvoid NMI_Handler(void)\r\n{\r\n  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */\r\n\r\n  /* USER CODE END NonMaskableInt_IRQn 0 */\r\n  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */\r\n  while (1)\r\n  {\r\n  }\r\n  /* USER CODE END NonMaskableInt_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Hard fault interrupt.\r\n  */\r\nvoid HardFault_Handler(void)\r\n{\r\n  /* USER CODE BEGIN HardFault_IRQn 0 */\r\n\r\n  /* USER CODE END HardFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\r\n    /* USER CODE END W1_HardFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Memory management fault.\r\n  */\r\nvoid MemManage_Handler(void)\r\n{\r\n  /* USER CODE BEGIN MemoryManagement_IRQn 0 */\r\n\r\n  /* USER CODE END MemoryManagement_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */\r\n    /* USER CODE END W1_MemoryManagement_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Pre-fetch fault, memory access fault.\r\n  */\r\nvoid BusFault_Handler(void)\r\n{\r\n  /* USER CODE BEGIN BusFault_IRQn 0 */\r\n\r\n  /* USER CODE END BusFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\r\n    /* USER CODE END W1_BusFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles Undefined instruction or illegal state.\r\n  */\r\nvoid UsageFault_Handler(void)\r\n{\r\n  /* USER CODE BEGIN UsageFault_IRQn 0 */\r\n\r\n  /* USER CODE END UsageFault_IRQn 0 */\r\n  while (1)\r\n  {\r\n    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */\r\n    /* USER CODE END W1_UsageFault_IRQn 0 */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief This function handles System service call via SWI instruction.\r\n  */\r\n__attribute__((weak)) void SVC_Handler(void)\r\n{\r\n  /* USER CODE BEGIN SVCall_IRQn 0 */\r\n\r\n  /* USER CODE END SVCall_IRQn 0 */\r\n  /* USER CODE BEGIN SVCall_IRQn 1 */\r\n\r\n  /* USER CODE END SVCall_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Debug monitor.\r\n  */\r\nvoid DebugMon_Handler(void)\r\n{\r\n  /* USER CODE BEGIN DebugMonitor_IRQn 0 */\r\n\r\n  /* USER CODE END DebugMonitor_IRQn 0 */\r\n  /* USER CODE BEGIN DebugMonitor_IRQn 1 */\r\n\r\n  /* USER CODE END DebugMonitor_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles Pendable request for system service.\r\n  */\r\n__attribute__((weak)) void PendSV_Handler(void)\r\n{\r\n  /* USER CODE BEGIN PendSV_IRQn 0 */\r\n\r\n  /* USER CODE END PendSV_IRQn 0 */\r\n  /* USER CODE BEGIN PendSV_IRQn 1 */\r\n\r\n  /* USER CODE END PendSV_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles System tick timer.\r\n  */\r\n__attribute__((weak)) void SysTick_Handler(void)\r\n{\r\n  /* USER CODE BEGIN SysTick_IRQn 0 */\r\n\r\n  /* USER CODE END SysTick_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN SysTick_IRQn 1 */\r\n\r\n  /* USER CODE END SysTick_IRQn 1 */\r\n}\r\n\r\n/******************************************************************************/\r\n/* STM32H7xx Peripheral Interrupt Handlers                                    */\r\n/* Add here the Interrupt Handlers for the used peripherals.                  */\r\n/* For the available peripheral interrupt handler names,                      */\r\n/* please refer to the startup file (startup_stm32h7xx.s).                    */\r\n/******************************************************************************/\r\n\r\n/**\r\n  * @brief This function handles TIM1 update interrupt.\r\n  */\r\nvoid TIM1_UP_IRQHandler(void)\r\n{\r\n  /* USER CODE BEGIN TIM1_UP_IRQn 0 */\r\n\r\n  /* USER CODE END TIM1_UP_IRQn 0 */\r\n  HAL_TIM_IRQHandler(&htim1);\r\n  /* USER CODE BEGIN TIM1_UP_IRQn 1 */\r\n\r\n  /* USER CODE END TIM1_UP_IRQn 1 */\r\n}\r\n\r\n/**\r\n  * @brief This function handles TIM8 update interrupt and TIM13 global interrupt.\r\n  */\r\nvoid TIM8_UP_TIM13_IRQHandler(void)\r\n{\r\n  /* USER CODE BEGIN TIM8_UP_TIM13_IRQn 0 */\r\n\r\n  /* USER CODE END TIM8_UP_TIM13_IRQn 0 */\r\n  HAL_TIM_IRQHandler(&htim13);\r\n  /* USER CODE BEGIN TIM8_UP_TIM13_IRQn 1 */\r\n\r\n  /* USER CODE END TIM8_UP_TIM13_IRQn 1 */\r\n}\r\n\r\n/* USER CODE BEGIN 1 */\r\n\r\n/* USER CODE END 1 */\r\n\r\n"},{"name":"stm32h7xx_ll_exti.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_ll_exti.c\r\n  * @author  MCD Application Team\r\n  * @brief   EXTI LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_ll_exti.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32H7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (EXTI)\r\n\r\n/** @defgroup EXTI_LL EXTI\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup EXTI_LL_Private_Macros\r\n  * @{\r\n  */\r\n\r\n#define IS_LL_EXTI_LINE_0_31(__VALUE__)              (((__VALUE__) & ~LL_EXTI_LINE_ALL_0_31)  == 0x00000000U)\r\n#define IS_LL_EXTI_LINE_32_63(__VALUE__)             (((__VALUE__) & ~LL_EXTI_LINE_ALL_32_63) == 0x00000000U)\r\n#define IS_LL_EXTI_LINE_64_95(__VALUE__)             (((__VALUE__) & ~LL_EXTI_LINE_ALL_64_95) == 0x00000000U)\r\n\r\n#define IS_LL_EXTI_MODE(__VALUE__)                   (((__VALUE__) == LL_EXTI_MODE_IT)            \\\r\n                                                   || ((__VALUE__) == LL_EXTI_MODE_EVENT)         \\\r\n                                                   || ((__VALUE__) == LL_EXTI_MODE_IT_EVENT))\r\n\r\n\r\n#define IS_LL_EXTI_TRIGGER(__VALUE__)                (((__VALUE__) == LL_EXTI_TRIGGER_NONE)       \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_RISING)     \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_FALLING)    \\\r\n                                                   || ((__VALUE__) == LL_EXTI_TRIGGER_RISING_FALLING))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup EXTI_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup EXTI_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize the EXTI registers to their default reset values.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: EXTI registers are de-initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_EXTI_DeInit(void)\r\n{\r\n  /* Rising Trigger selection register set to default reset values */\r\n  LL_EXTI_WriteReg(RTSR1,  0x00000000U);\r\n  LL_EXTI_WriteReg(RTSR2,  0x00000000U);\r\n  LL_EXTI_WriteReg(RTSR3,  0x00000000U);\r\n\r\n  /* Falling Trigger selection register set to default reset values */\r\n  LL_EXTI_WriteReg(FTSR1,  0x00000000U);\r\n  LL_EXTI_WriteReg(FTSR2,  0x00000000U);\r\n  LL_EXTI_WriteReg(FTSR3,  0x00000000U);\r\n\r\n  /* Software interrupt event register set to default reset values */\r\n  LL_EXTI_WriteReg(SWIER1, 0x00000000U);\r\n  LL_EXTI_WriteReg(SWIER2, 0x00000000U);\r\n  LL_EXTI_WriteReg(SWIER3, 0x00000000U);\r\n\r\n  /* D3 Pending register set to default reset values */\r\n  LL_EXTI_WriteReg(D3PMR1, 0x00000000U);\r\n  LL_EXTI_WriteReg(D3PMR2, 0x00000000U);\r\n  LL_EXTI_WriteReg(D3PMR3, 0x00000000U);\r\n\r\n  /* D3 Pending clear selection register low to default reset values */\r\n  LL_EXTI_WriteReg(D3PCR1L, 0x00000000U);\r\n  LL_EXTI_WriteReg(D3PCR2L, 0x00000000U);\r\n  LL_EXTI_WriteReg(D3PCR3L, 0x00000000U);\r\n\r\n  /* D3 Pending clear selection register high to default reset values */\r\n  LL_EXTI_WriteReg(D3PCR1H, 0x00000000U);\r\n  LL_EXTI_WriteReg(D3PCR2H, 0x00000000U);\r\n  LL_EXTI_WriteReg(D3PCR3H, 0x00000000U);\r\n\r\n  /* Interrupt mask register reset */\r\n  LL_EXTI_WriteReg(IMR1, 0x00000000U);\r\n  LL_EXTI_WriteReg(IMR2, 0x00000000U);\r\n  LL_EXTI_WriteReg(IMR3, 0x00000000U);\r\n\r\n  /*  Event mask register reset */\r\n  LL_EXTI_WriteReg(EMR1, 0x00000000U);\r\n  LL_EXTI_WriteReg(EMR2, 0x00000000U);\r\n  LL_EXTI_WriteReg(EMR3, 0x00000000U);\r\n\r\n  /* Clear Pending requests */\r\n  LL_EXTI_WriteReg(PR1, EXTI_PR1_PR_Msk);\r\n  LL_EXTI_WriteReg(PR2, EXTI_PR2_PR_Msk);\r\n  LL_EXTI_WriteReg(PR3, EXTI_PR3_PR_Msk);\r\n\r\n#if defined(DUAL_CORE)\r\n  /* Interrupt mask register set to default reset values  for Core 2 (Coretx-M4)*/\r\n  LL_EXTI_WriteReg(C2IMR1, 0x00000000U);\r\n  LL_EXTI_WriteReg(C2IMR2, 0x00000000U);\r\n  LL_EXTI_WriteReg(C2IMR3, 0x00000000U);\r\n\r\n  /*  Event mask register set to default reset values */\r\n  LL_EXTI_WriteReg(C2EMR1, 0x00000000U);\r\n  LL_EXTI_WriteReg(C2EMR2, 0x00000000U);\r\n  LL_EXTI_WriteReg(C2EMR3, 0x00000000U);\r\n\r\n  /* Clear Pending requests */\r\n  LL_EXTI_WriteReg(C2PR1, EXTI_PR1_PR_Msk);\r\n  LL_EXTI_WriteReg(C2PR2, EXTI_PR2_PR_Msk);\r\n  LL_EXTI_WriteReg(C2PR3, EXTI_PR3_PR_Msk);\r\n\r\n#endif /* DUAL_CORE*/\r\n  return SUCCESS;\r\n}\r\n\r\n/**\r\n  * @brief  Initialize the EXTI registers according to the specified parameters in EXTI_InitStruct.\r\n  * @param  EXTI_InitStruct pointer to a @ref LL_EXTI_InitTypeDef structure.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: EXTI registers are initialized\r\n  *          - ERROR: not applicable\r\n  */\r\nErrorStatus LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));\r\n  assert_param(IS_LL_EXTI_LINE_32_63(EXTI_InitStruct->Line_32_63));\r\n  assert_param(IS_LL_EXTI_LINE_64_95(EXTI_InitStruct->Line_64_95));\r\n  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));\r\n  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));\r\n\r\n  /* ENABLE LineCommand */\r\n  if (EXTI_InitStruct->LineCommand != DISABLE)\r\n  {\r\n    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));\r\n\r\n    /* Configure EXTI Lines in range from 0 to 31 */\r\n    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)\r\n    {\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_IT) == LL_EXTI_MODE_IT)\r\n      {\r\n        /* Enable IT on provided Lines for Cortex-M7*/\r\n        LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n      else\r\n      {\r\n        /* Disable IT on provided Lines for Cortex-M7*/\r\n        LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_EVENT) == LL_EXTI_MODE_EVENT)\r\n      {\r\n        /* Enable event on provided Lines for Cortex-M7 */\r\n        LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n      else\r\n      {\r\n        /* Disable event on provided Lines for Cortex-M7 */\r\n        LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n#if defined(DUAL_CORE)\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_C2_IT) == LL_EXTI_MODE_C2_IT)\r\n      {\r\n        /* Enable IT on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_EnableIT_0_31 (EXTI_InitStruct->Line_0_31);\r\n      }\r\n      else\r\n      {\r\n        /* Disable IT on provided Lines for Cortex-M4*/\r\n        LL_C2_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_C2_EVENT) == LL_EXTI_MODE_C2_EVENT)\r\n      {\r\n        /* Enable event on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n      else\r\n      {\r\n        /* Disable event on provided Lines for Cortex-M4*/\r\n        LL_C2_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n      }\r\n#endif /* DUAL_CORE */\r\n\r\n      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)\r\n      {\r\n        switch (EXTI_InitStruct->Trigger)\r\n        {\r\n          case LL_EXTI_TRIGGER_RISING:\r\n            /* First Disable Falling Trigger on provided Lines */\r\n            LL_EXTI_DisableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            /* Then Enable Rising Trigger on provided Lines */\r\n            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          case LL_EXTI_TRIGGER_FALLING:\r\n            /* First Disable Rising Trigger on provided Lines */\r\n            LL_EXTI_DisableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            /* Then Enable Falling Trigger on provided Lines */\r\n            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          case LL_EXTI_TRIGGER_RISING_FALLING:\r\n            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);\r\n            break;\r\n          default:\r\n            status = ERROR;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n    /* Configure EXTI Lines in range from 32 to 63 */\r\n    if (EXTI_InitStruct->Line_32_63 != LL_EXTI_LINE_NONE)\r\n    {\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_IT) == LL_EXTI_MODE_IT)\r\n      {\r\n        /* Enable IT on provided Lines for Cortex-M7*/\r\n        LL_EXTI_EnableIT_32_63(EXTI_InitStruct->Line_32_63);\r\n      }\r\n      else\r\n      {\r\n        /* Disable IT on provided Lines for Cortex-M7*/\r\n        LL_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);\r\n      }\r\n\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_EVENT) == LL_EXTI_MODE_EVENT)\r\n      {\r\n        /* Enable event on provided Lines for Cortex-M7 */\r\n        LL_EXTI_EnableEvent_32_63(EXTI_InitStruct->Line_32_63);\r\n      }\r\n      else\r\n      {\r\n        /* Disable event on provided Lines for Cortex-M7 */\r\n        LL_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);\r\n      }\r\n#if defined(DUAL_CORE)\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_C2_IT) == LL_EXTI_MODE_C2_IT)\r\n      {\r\n        /* Enable IT on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_EnableIT_32_63 (EXTI_InitStruct->Line_32_63);\r\n      }\r\n      else\r\n      {\r\n        /* Disable IT on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_DisableIT_32_63 (EXTI_InitStruct->Line_32_63);\r\n      }\r\n\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_C2_EVENT) == LL_EXTI_MODE_C2_EVENT)\r\n      {\r\n        /* Enable event on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_EnableEvent_32_63(EXTI_InitStruct->Line_32_63);\r\n      }\r\n      else\r\n      {\r\n        /* Disable event on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);\r\n      }\r\n#endif /* DUAL_CORE */\r\n\r\n      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)\r\n      {\r\n        switch (EXTI_InitStruct->Trigger)\r\n        {\r\n          case LL_EXTI_TRIGGER_RISING:\r\n            /* First Disable Falling Trigger on provided Lines */\r\n            LL_EXTI_DisableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);\r\n            /* Then Enable IT on provided Lines */\r\n            LL_EXTI_EnableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);\r\n            break;\r\n          case LL_EXTI_TRIGGER_FALLING:\r\n            /* First Disable Rising Trigger on provided Lines */\r\n            LL_EXTI_DisableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);\r\n            /* Then Enable Falling Trigger on provided Lines */\r\n            LL_EXTI_EnableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);\r\n            break;\r\n          case LL_EXTI_TRIGGER_RISING_FALLING:\r\n            LL_EXTI_EnableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);\r\n            LL_EXTI_EnableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);\r\n            break;\r\n          default:\r\n            status = ERROR;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n    /* Configure EXTI Lines in range from 64 to 95 */\r\n    if (EXTI_InitStruct->Line_64_95 != LL_EXTI_LINE_NONE)\r\n    {\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_IT) == LL_EXTI_MODE_IT)\r\n      {\r\n        /* Enable IT on provided Lines for Cortex-M7*/\r\n        LL_EXTI_EnableIT_64_95(EXTI_InitStruct->Line_64_95);\r\n      }\r\n      else\r\n      {\r\n        /* Disable IT on provided Lines for Cortex-M7*/\r\n        LL_EXTI_DisableIT_64_95(EXTI_InitStruct->Line_64_95);\r\n      }\r\n\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_EVENT) == LL_EXTI_MODE_EVENT)\r\n      {\r\n        /* Enable event on provided Lines for Cortex-M7 */\r\n        LL_EXTI_EnableEvent_64_95(EXTI_InitStruct->Line_64_95);\r\n      }\r\n      else\r\n      {\r\n        /* Disable event on provided Lines for Cortex-M7 */\r\n        LL_EXTI_DisableEvent_64_95(EXTI_InitStruct->Line_64_95);\r\n      }\r\n\r\n#if defined(DUAL_CORE)\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_C2_IT) == LL_EXTI_MODE_C2_IT)\r\n      {\r\n        /* Enable IT on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_EnableIT_64_95 (EXTI_InitStruct->Line_64_95);\r\n      }\r\n      else\r\n      {\r\n        /* Disable IT on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_DisableIT_64_95 (EXTI_InitStruct->Line_64_95);\r\n      }\r\n\r\n      if((EXTI_InitStruct->Mode & LL_EXTI_MODE_C2_EVENT) == LL_EXTI_MODE_C2_EVENT)\r\n      {\r\n        /* Enable event on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_EnableEvent_64_95(EXTI_InitStruct->Line_64_95);\r\n      }\r\n      else\r\n      {\r\n        /* Disable event on provided Lines for Cortex-M4 */\r\n        LL_C2_EXTI_DisableEvent_64_95(EXTI_InitStruct->Line_64_95);\r\n      }\r\n#endif /* DUAL_CORE */\r\n\r\n      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)\r\n      {\r\n        switch (EXTI_InitStruct->Trigger)\r\n        {\r\n          case LL_EXTI_TRIGGER_RISING:\r\n            /* First Disable Falling Trigger on provided Lines */\r\n            LL_EXTI_DisableFallingTrig_64_95(EXTI_InitStruct->Line_64_95);\r\n            /* Then Enable IT on provided Lines */\r\n            LL_EXTI_EnableRisingTrig_64_95(EXTI_InitStruct->Line_64_95);\r\n            break;\r\n          case LL_EXTI_TRIGGER_FALLING:\r\n            /* First Disable Rising Trigger on provided Lines */\r\n            LL_EXTI_DisableRisingTrig_64_95(EXTI_InitStruct->Line_64_95);\r\n            /* Then Enable Falling Trigger on provided Lines */\r\n            LL_EXTI_EnableFallingTrig_64_95(EXTI_InitStruct->Line_64_95);\r\n            break;\r\n          case LL_EXTI_TRIGGER_RISING_FALLING:\r\n            LL_EXTI_EnableRisingTrig_64_95(EXTI_InitStruct->Line_64_95);\r\n            LL_EXTI_EnableFallingTrig_64_95(EXTI_InitStruct->Line_64_95);\r\n            break;\r\n          default:\r\n            status = ERROR;\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else /* DISABLE LineCommand */\r\n  {\r\n    /* Disable IT on provided Lines for Cortex-M7*/\r\n    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n    LL_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);\r\n    LL_EXTI_DisableIT_64_95(EXTI_InitStruct->Line_64_95);\r\n\r\n    /* Disable event on provided Lines for Cortex-M7 */\r\n    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n    LL_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);\r\n    LL_EXTI_DisableEvent_64_95(EXTI_InitStruct->Line_64_95);\r\n\r\n#if defined(DUAL_CORE)\r\n    /* Disable IT on provided Lines for Cortex-M4*/\r\n    LL_C2_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);\r\n    LL_C2_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);\r\n    LL_C2_EXTI_DisableIT_64_95(EXTI_InitStruct->Line_64_95);\r\n\r\n    /* Disable event on provided Lines for Cortex-M4 */\r\n    LL_C2_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);\r\n    LL_C2_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);\r\n    LL_C2_EXTI_DisableEvent_64_95(EXTI_InitStruct->Line_64_95);\r\n#endif /* DUAL_CORE */\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Set each @ref LL_EXTI_InitTypeDef field to default value.\r\n  * @param  EXTI_InitStruct Pointer to a @ref LL_EXTI_InitTypeDef structure.\r\n  * @retval None\r\n  */\r\nvoid LL_EXTI_StructInit(LL_EXTI_InitTypeDef *EXTI_InitStruct)\r\n{\r\n  EXTI_InitStruct->Line_0_31      = LL_EXTI_LINE_NONE;\r\n  EXTI_InitStruct->Line_32_63     = LL_EXTI_LINE_NONE;\r\n  EXTI_InitStruct->Line_64_95     = LL_EXTI_LINE_NONE;\r\n  EXTI_InitStruct->LineCommand    = DISABLE;\r\n  EXTI_InitStruct->Mode           = LL_EXTI_MODE_IT;\r\n  EXTI_InitStruct->Trigger        = LL_EXTI_TRIGGER_FALLING;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined (EXTI) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n"},{"name":"stm32h7xx_ll_gpio.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_ll_gpio.c\r\n  * @author  MCD Application Team\r\n  * @brief   GPIO LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n  \r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_ll_gpio.h\"\r\n#include \"stm32h7xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n#include \"stm32_assert.h\"\r\n#else\r\n#define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32H7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) || defined (GPIOJ) || defined (GPIOK)\r\n\r\n/** @addtogroup GPIO_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup GPIO_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_GPIO_PIN(__VALUE__)          (((0x00000000U) < (__VALUE__)) && ((__VALUE__) <= (LL_GPIO_PIN_ALL)))\r\n\r\n#define IS_LL_GPIO_MODE(__VALUE__)         (((__VALUE__) == LL_GPIO_MODE_INPUT)     ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_OUTPUT)    ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_ALTERNATE) ||\\\r\n                                            ((__VALUE__) == LL_GPIO_MODE_ANALOG))\r\n\r\n#define IS_LL_GPIO_OUTPUT_TYPE(__VALUE__)  (((__VALUE__) == LL_GPIO_OUTPUT_PUSHPULL)  ||\\\r\n                                            ((__VALUE__) == LL_GPIO_OUTPUT_OPENDRAIN))\r\n\r\n#define IS_LL_GPIO_SPEED(__VALUE__)        (((__VALUE__) == LL_GPIO_SPEED_FREQ_LOW)       ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_MEDIUM)    ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_HIGH)      ||\\\r\n                                            ((__VALUE__) == LL_GPIO_SPEED_FREQ_VERY_HIGH))\r\n\r\n#define IS_LL_GPIO_PULL(__VALUE__)         (((__VALUE__) == LL_GPIO_PULL_NO)   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_PULL_UP)   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_PULL_DOWN))\r\n\r\n#define IS_LL_GPIO_ALTERNATE(__VALUE__)    (((__VALUE__) == LL_GPIO_AF_0  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_1  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_2  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_3  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_4  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_5  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_6  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_7  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_8  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_9  )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_10 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_11 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_12 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_13 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_14 )   ||\\\r\n                                            ((__VALUE__) == LL_GPIO_AF_15 ))\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup GPIO_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup GPIO_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  De-initialize GPIO registers (Registers restored to their default values).\r\n  * @param  GPIOx GPIO Port\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: GPIO registers are de-initialized\r\n  *          - ERROR:   Wrong GPIO Port\r\n  */\r\nErrorStatus LL_GPIO_DeInit(GPIO_TypeDef *GPIOx)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n\r\n  /* Force and Release reset on clock of GPIOx Port */\r\n  if (GPIOx == GPIOA)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOA);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOA);\r\n  }\r\n  else if (GPIOx == GPIOB)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOB);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOB);\r\n  }\r\n  else if (GPIOx == GPIOC)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOC);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOC);\r\n  }\r\n#if defined(GPIOD)\r\n  else if (GPIOx == GPIOD)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOD);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOD);\r\n  }\r\n#endif /* GPIOD */\r\n#if defined(GPIOE)\r\n  else if (GPIOx == GPIOE)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOE);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOE);\r\n  }\r\n#endif /* GPIOE */\r\n#if defined(GPIOF)\r\n  else if (GPIOx == GPIOF)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOF);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOF);\r\n  }\r\n#endif /* GPIOF */\r\n#if defined(GPIOG)\r\n  else if (GPIOx == GPIOG)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOG);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOG);\r\n  }\r\n#endif /* GPIOG */\r\n#if defined(GPIOH)\r\n  else if (GPIOx == GPIOH)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOH);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOH);\r\n  }\r\n#endif /* GPIOH */\r\n#if defined(GPIOI)\r\n  else if (GPIOx == GPIOI)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOI);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOI);\r\n  }\r\n#endif /* GPIOI */\r\n#if defined(GPIOJ)\r\n  else if (GPIOx == GPIOJ)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOJ);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOJ);\r\n  }\r\n#endif /* GPIOJ */\r\n#if defined(GPIOK)\r\n  else if (GPIOx == GPIOK)\r\n  {\r\n    LL_AHB4_GRP1_ForceReset(LL_AHB4_GRP1_PERIPH_GPIOK);\r\n    LL_AHB4_GRP1_ReleaseReset(LL_AHB4_GRP1_PERIPH_GPIOK);\r\n  }\r\n#endif /* GPIOK */\r\n  else\r\n  {\r\n    status = ERROR;\r\n  }\r\n\r\n  return (status);\r\n}\r\n\r\n/**\r\n  * @brief  Initialize GPIO registers according to the specified parameters in GPIO_InitStruct.\r\n  * @param  GPIOx GPIO Port\r\n  * @param GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure\r\n  *         that contains the configuration information for the specified GPIO peripheral.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content\r\n  *          - ERROR:   Not applicable\r\n  */\r\nErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)\r\n{\r\n  uint32_t pinpos, currentpin;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\r\n  assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));\r\n  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));\r\n  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));\r\n\r\n  /* ------------------------- Configure the port pins ---------------- */\r\n  /* Initialize  pinpos on first pin set */\r\n  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);\r\n\r\n  /* Configure the port pins */\r\n  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)\r\n  {\r\n    /* Get current io position */\r\n    currentpin = (GPIO_InitStruct->Pin) & (0x00000001UL << pinpos);\r\n\r\n    if (currentpin != 0x00000000U)\r\n    {\r\n\r\n      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))\r\n      {\r\n        /* Check Speed mode parameters */\r\n        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));\r\n\r\n        /* Speed mode configuration */\r\n        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);\r\n\r\n        /* Check Output mode parameters */\r\n        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));\r\n\r\n        /* Output mode configuration*/\r\n        LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);\r\n\r\n      }\r\n\r\n      /* Pull-up Pull down resistor configuration*/\r\n      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);\r\n\r\n      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)\r\n      {\r\n        /* Check Alternate parameter */\r\n        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));\r\n\r\n        /* Alternate function configuration */\r\n        if (currentpin < LL_GPIO_PIN_8)\r\n        {\r\n          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);\r\n        }\r\n        else\r\n        {\r\n          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);\r\n        }\r\n      }\r\n\r\n      /* Pin Mode configuration */\r\n      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);\r\n    }\r\n    pinpos++;\r\n  }\r\n\r\n  return (SUCCESS);\r\n}\r\n\r\n/**\r\n  * @brief Set each @ref LL_GPIO_InitTypeDef field to default value.\r\n  * @param GPIO_InitStruct pointer to a @ref LL_GPIO_InitTypeDef structure\r\n  *                          whose fields will be set to default values.\r\n  * @retval None\r\n  */\r\n\r\nvoid LL_GPIO_StructInit(LL_GPIO_InitTypeDef *GPIO_InitStruct)\r\n{\r\n  /* Reset GPIO init structure parameters values */\r\n  GPIO_InitStruct->Pin        = LL_GPIO_PIN_ALL;\r\n  GPIO_InitStruct->Mode       = LL_GPIO_MODE_ANALOG;\r\n  GPIO_InitStruct->Speed      = LL_GPIO_SPEED_FREQ_LOW;\r\n  GPIO_InitStruct->OutputType = LL_GPIO_OUTPUT_PUSHPULL;\r\n  GPIO_InitStruct->Pull       = LL_GPIO_PULL_NO;\r\n  GPIO_InitStruct->Alternate  = LL_GPIO_AF_0;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined (GPIOA) || defined (GPIOB) || defined (GPIOC) || defined (GPIOD) || defined (GPIOE) || defined (GPIOF) || defined (GPIOG) || defined (GPIOH) || defined (GPIOI) || defined (GPIOJ) || defined (GPIOK) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n\r\n"},{"name":"stm32h7xx_ll_rcc.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_ll_rcc.c\r\n  * @author  MCD Application Team\r\n  * @brief   RCC LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  ******************************************************************************\r\n  */\r\n#if defined(USE_FULL_LL_DRIVER)\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_ll_rcc.h\"\r\n#include \"stm32h7xx_ll_bus.h\"\r\n#ifdef  USE_FULL_ASSERT\r\n  #include \"stm32_assert.h\"\r\n#else\r\n  #define assert_param(expr) ((void)0U)\r\n#endif\r\n\r\n/** @addtogroup STM32H7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n#if defined(RCC)\r\n\r\n/** @addtogroup RCC_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\nconst uint8_t LL_RCC_PrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};\r\n/* Private constants ---------------------------------------------------------*/\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup RCC_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART16_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_USART234578_CLKSOURCE))\r\n\r\n\r\n#define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C123_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_I2C4_CLKSOURCE))\r\n\r\n#define IS_LL_RCC_LPTIM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_LPTIM1_CLKSOURCE)  \\\r\n                                            || ((__VALUE__) == LL_RCC_LPTIM2_CLKSOURCE)  \\\r\n                                            || ((__VALUE__) == LL_RCC_LPTIM345_CLKSOURCE))\r\n\r\n#if defined(SAI3)\r\n#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI23_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI4A_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI4B_CLKSOURCE))\r\n#elif defined(SAI4)\r\n#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI4A_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI4B_CLKSOURCE))\r\n#else\r\n#define IS_LL_RCC_SAI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SAI1_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI2A_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SAI2B_CLKSOURCE))\r\n#endif /* SAI3 */\r\n\r\n#define IS_LL_RCC_SPI_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_SPI123_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SPI45_CLKSOURCE) \\\r\n                                            || ((__VALUE__) == LL_RCC_SPI6_CLKSOURCE))\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup RCC_LL_Private_Functions RCC Private functions\r\n  * @{\r\n  */\r\nstatic uint32_t RCC_GetSystemClockFreq(void);\r\nstatic uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency);\r\nstatic uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency);\r\nstatic uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency);\r\nstatic uint32_t RCC_GetPCLK3ClockFreq(uint32_t HCLK_Frequency);\r\nstatic uint32_t RCC_GetPCLK4ClockFreq(uint32_t HCLK_Frequency);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup RCC_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup RCC_LL_EF_Init\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Resets the RCC clock configuration to the default reset state.\r\n  * @note   The default reset state of the clock configuration is given below:\r\n  *            - HSI ON and used as system clock source\r\n  *            - HSE, PLL1, PLL2 and PLL3 OFF\r\n  *            - AHB, APB Bus pre-scaler set to 1.\r\n  *            - CSS, MCO1 and MCO2 OFF\r\n  *            - All interrupts disabled\r\n  * @note   This function doesn't modify the configuration of the\r\n  *            - Peripheral clocks\r\n  *            - LSI, LSE and RTC clocks\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_DeInit(void)\r\n{\r\n   /* Increasing the CPU frequency */\r\n  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));\r\n  }\r\n\r\n  /* Set HSION bit */\r\n  SET_BIT(RCC->CR, RCC_CR_HSION);\r\n\r\n  /* Wait for HSI READY bit */\r\n  while(LL_RCC_HSI_IsReady() == 0U)\r\n  {}\r\n\r\n  /* Reset CFGR register */\r\n  CLEAR_REG(RCC->CFGR);\r\n\r\n  /* Reset CSION , CSIKERON, HSEON, HSI48ON, HSECSSON,HSIDIV, PLL1ON, PLL2ON, PLL3ON bits */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON |  RCC_CR_HSI48ON  \\\r\n  |RCC_CR_CSSHSEON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);\r\n\r\n  /* Wait for PLL1 READY bit to be reset */\r\n  while(LL_RCC_PLL1_IsReady() != 0U)\r\n  {}\r\n\r\n  /* Wait for PLL2 READY bit to be reset */\r\n  while(LL_RCC_PLL2_IsReady() != 0U)\r\n  {}\r\n\r\n  /* Wait for PLL3 READY bit to be reset */\r\n  while(LL_RCC_PLL3_IsReady() != 0U)\r\n  {}\r\n\r\n#if defined(RCC_D1CFGR_HPRE)\r\n  /* Reset D1CFGR register */\r\n  CLEAR_REG(RCC->D1CFGR);\r\n\r\n  /* Reset D2CFGR register */\r\n  CLEAR_REG(RCC->D2CFGR);\r\n\r\n  /* Reset D3CFGR register */\r\n  CLEAR_REG(RCC->D3CFGR);\r\n#else\r\n  /* Reset CDCFGR1 register */\r\n  CLEAR_REG(RCC->CDCFGR1);\r\n\r\n  /* Reset CDCFGR2 register */\r\n  CLEAR_REG(RCC->CDCFGR2);\r\n\r\n  /* Reset SRDCFGR register */\r\n  CLEAR_REG(RCC->SRDCFGR);\r\n\r\n#endif /* RCC_D1CFGR_HPRE */\r\n\r\n  /* Reset PLLCKSELR register to default value */\r\n  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;\r\n\r\n  /* Reset PLLCFGR register to default value */\r\n  LL_RCC_WriteReg(PLLCFGR, 0x01FF0000U);\r\n\r\n  /* Reset PLL1DIVR register to default value */\r\n  LL_RCC_WriteReg(PLL1DIVR, 0x01010280U);\r\n\r\n  /* Reset PLL1FRACR register */\r\n  CLEAR_REG(RCC->PLL1FRACR);\r\n\r\n  /* Reset PLL2DIVR register to default value */\r\n  LL_RCC_WriteReg(PLL2DIVR, 0x01010280U);\r\n\r\n  /* Reset PLL2FRACR register */\r\n  CLEAR_REG(RCC->PLL2FRACR);\r\n\r\n  /* Reset PLL3DIVR register to default value */\r\n  LL_RCC_WriteReg(PLL3DIVR, 0x01010280U);\r\n\r\n  /* Reset PLL3FRACR register */\r\n  CLEAR_REG(RCC->PLL3FRACR);\r\n\r\n  /* Reset HSEBYP bit */\r\n  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);\r\n\r\n  /* Disable all interrupts */\r\n  CLEAR_REG(RCC->CIER);\r\n\r\n  /* Clear all interrupts */\r\n  SET_BIT(RCC->CICR, RCC_CICR_LSIRDYC | RCC_CICR_LSERDYC | RCC_CICR_HSIRDYC | RCC_CICR_HSERDYC\r\n                   | RCC_CICR_CSIRDYC | RCC_CICR_HSI48RDYC | RCC_CICR_PLLRDYC | RCC_CICR_PLL2RDYC\r\n                   | RCC_CICR_PLL3RDYC | RCC_CICR_LSECSSC | RCC_CICR_HSECSSC);\r\n\r\n  /* Clear reset source flags */\r\n  SET_BIT(RCC->RSR, RCC_RSR_RMVF);\r\n  \r\n   /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));\r\n  }\r\n\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup RCC_LL_EF_Get_Freq\r\n  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1, APB2, APB3 and APB4 buses clocks.\r\n  *         and different peripheral clocks available on the device.\r\n  * @note   If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)\r\n  * @note   If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)\r\n  * @note   If SYSCLK source is CSI, function returns values based on CSI_VALUE(***)\r\n  * @note   If SYSCLK source is PLL, function returns values based on HSE_VALUE(**)\r\n  *         or HSI_VALUE(*) multiplied/divided by the PLL factors.\r\n  * @note   (*) HSI_VALUE is a constant defined in header file (default value\r\n  *             64 MHz) divider by HSIDIV, but the real value may vary depending on\r\n  *             on the variations in voltage and temperature.\r\n  * @note   (**) HSE_VALUE is a constant defined in header file (default value\r\n  *              25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *              frequency of the crystal used. Otherwise, this function may\r\n  *              have wrong result.\r\n  * @note   (***) CSI_VALUE is a constant defined in header file (default value\r\n  *               4 MHz) but the real value may vary depending on the variations\r\n  *               in voltage and temperature.\r\n  * @note   The result of this function could be incorrect when using fractional\r\n  *         value for HSE crystal.\r\n  * @note   This function can be used by the user application to compute the\r\n  *         baud-rate for the communication peripherals or configure other parameters.\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1, APB2, APB3 and APB4 buses clocks.\r\n  * @note   Each time SYSCLK, HCLK, PCLK1, PCLK2, PCLK3 and/or PCLK4 clock changes, this function\r\n  *         must be called to update structure fields. Otherwise, any\r\n  *         configuration based on this function will be incorrect.\r\n  * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)\r\n{\r\n  /* Get SYSCLK frequency */\r\n  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();\r\n\r\n  /* HCLK clock frequency */\r\n  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);\r\n\r\n  /* PCLK1 clock frequency */\r\n  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n\r\n  /* PCLK2 clock frequency */\r\n  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n\r\n  /* PCLK3 clock frequency */\r\n  RCC_Clocks->PCLK3_Frequency  = RCC_GetPCLK3ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n\r\n  /* PCLK4 clock frequency */\r\n  RCC_Clocks->PCLK4_Frequency  = RCC_GetPCLK4ClockFreq(RCC_Clocks->HCLK_Frequency);\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL1 clocks frequencies\r\n  * @note   LL_RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_GetPLL1ClockFreq(LL_PLL_ClocksTypeDef *PLL_Clocks)\r\n{\r\n  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;\r\n  uint32_t m, n, fracn = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)\r\n     SYSCLK = PLL_VCO / PLLP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:\r\n      if (LL_RCC_HSE_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = HSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_NONE:\r\n    default:\r\n      /* PLL clock disabled */\r\n      break;\r\n  }\r\n\r\n  PLL_Clocks->PLL_P_Frequency = 0U;\r\n  PLL_Clocks->PLL_Q_Frequency = 0U;\r\n  PLL_Clocks->PLL_R_Frequency = 0U;\r\n\r\n  m = LL_RCC_PLL1_GetM();\r\n  n = LL_RCC_PLL1_GetN();\r\n  if (LL_RCC_PLL1FRACN_IsEnabled() != 0U)\r\n  {\r\n    fracn = LL_RCC_PLL1_GetFRACN();\r\n  }\r\n\r\n  if (m != 0U)\r\n  {\r\n    if (LL_RCC_PLL1P_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetP());\r\n    }\r\n\r\n    if (LL_RCC_PLL1Q_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetQ());\r\n    }\r\n\r\n    if (LL_RCC_PLL1R_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL1_GetR());\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL2 clocks frequencies\r\n  * @note   LL_RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_GetPLL2ClockFreq(LL_PLL_ClocksTypeDef *PLL_Clocks)\r\n{\r\n  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;\r\n  uint32_t m, n, fracn = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)\r\n     SYSCLK = PLL_VCO / PLLP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:\r\n      if (LL_RCC_HSE_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = HSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_NONE:\r\n    default:\r\n      /* PLL clock disabled */\r\n      break;\r\n  }\r\n\r\n  PLL_Clocks->PLL_P_Frequency = 0U;\r\n  PLL_Clocks->PLL_Q_Frequency = 0U;\r\n  PLL_Clocks->PLL_R_Frequency = 0U;\r\n\r\n  m = LL_RCC_PLL2_GetM();\r\n  n = LL_RCC_PLL2_GetN();\r\n  if (LL_RCC_PLL2FRACN_IsEnabled() != 0U)\r\n  {\r\n    fracn = LL_RCC_PLL2_GetFRACN();\r\n  }\r\n\r\n  if (m != 0U)\r\n  {\r\n    if (LL_RCC_PLL2P_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetP());\r\n    }\r\n\r\n    if (LL_RCC_PLL2Q_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetQ());\r\n    }\r\n\r\n    if (LL_RCC_PLL2R_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL2_GetR());\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Return PLL3 clocks frequencies\r\n  * @note   LL_RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready\r\n  * @retval None\r\n  */\r\nvoid LL_RCC_GetPLL3ClockFreq(LL_PLL_ClocksTypeDef *PLL_Clocks)\r\n{\r\n  uint32_t pllinputfreq = LL_RCC_PERIPH_FREQUENCY_NO, pllsource;\r\n  uint32_t m, n, fracn = 0U;\r\n\r\n  /* PLL_VCO = (HSE_VALUE, CSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)\r\n     SYSCLK = PLL_VCO / PLLP\r\n  */\r\n  pllsource = LL_RCC_PLL_GetSource();\r\n\r\n  switch (pllsource)\r\n  {\r\n    case LL_RCC_PLLSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_HSE:\r\n      if (LL_RCC_HSE_IsReady() != 0U)\r\n      {\r\n        pllinputfreq = HSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_PLLSOURCE_NONE:\r\n    default:\r\n      /* PLL clock disabled */\r\n      break;\r\n  }\r\n\r\n  PLL_Clocks->PLL_P_Frequency = 0U;\r\n  PLL_Clocks->PLL_Q_Frequency = 0U;\r\n  PLL_Clocks->PLL_R_Frequency = 0U;\r\n\r\n  m = LL_RCC_PLL3_GetM();\r\n  n = LL_RCC_PLL3_GetN();\r\n  if (LL_RCC_PLL3FRACN_IsEnabled() != 0U)\r\n  {\r\n    fracn = LL_RCC_PLL3_GetFRACN();\r\n  }\r\n\r\n  if ((m != 0U) && (pllinputfreq != 0U))\r\n  {\r\n    if (LL_RCC_PLL3P_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_P_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL3_GetP());\r\n    }\r\n\r\n    if (LL_RCC_PLL3Q_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_Q_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL3_GetQ());\r\n    }\r\n\r\n    if (LL_RCC_PLL3R_IsEnabled() != 0U)\r\n    {\r\n      PLL_Clocks->PLL_R_Frequency = LL_RCC_CalcPLLClockFreq(pllinputfreq, m, n, fracn, LL_RCC_PLL3_GetR());\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Helper function to calculate the PLL frequency output\r\n  * @note ex: @ref LL_RCC_CalcPLLClockFreq (HSE_VALUE, @ref LL_RCC_PLL1_GetM (),\r\n  *             @ref LL_RCC_PLL1_GetN (), @ref LL_RCC_PLL1_GetFRACN (), @ref LL_RCC_PLL1_GetP ());\r\n  * @param  PLLInputFreq PLL Input frequency (based on HSE/(HSI/HSIDIV)/CSI)\r\n  * @param  M      Between 1 and 63\r\n  * @param  N      Between 4 and 512\r\n  * @param  FRACN  Between 0 and 0x1FFF\r\n  * @param  PQR    VCO output divider (P, Q or R)\r\n  *                Between 1 and 128, except for PLL1P Odd value not allowed\r\n  * @retval PLL1 clock frequency (in Hz)\r\n  */\r\nuint32_t LL_RCC_CalcPLLClockFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t PQR)\r\n{\r\n  float_t freq;\r\n\r\n  freq = ((float_t)PLLInputFreq / (float_t)M) * ((float_t)N + ((float_t)FRACN/(float_t)0x2000));\r\n\r\n  freq = freq/(float_t)PQR;\r\n\r\n  return (uint32_t)freq;\r\n}\r\n\r\n/**\r\n  * @brief  Return USARTx clock frequency\r\n  * @param  USARTxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_USART16_CLKSOURCE\r\n  *         @arg @ref LL_RCC_USART234578_CLKSOURCE\r\n  * @retval USART clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)\r\n{\r\n  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_USART_CLKSOURCE(USARTxSource));\r\n\r\n  switch (LL_RCC_GetUSARTClockSource(USARTxSource))\r\n  {\r\n    case LL_RCC_USART16_CLKSOURCE_PCLK2:\r\n      usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_USART234578_CLKSOURCE_PCLK1:\r\n      usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_USART16_CLKSOURCE_PLL2Q:\r\n    case LL_RCC_USART234578_CLKSOURCE_PLL2Q:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        usart_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USART16_CLKSOURCE_PLL3Q:\r\n    case LL_RCC_USART234578_CLKSOURCE_PLL3Q:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        usart_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USART16_CLKSOURCE_HSI:\r\n    case LL_RCC_USART234578_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USART16_CLKSOURCE_CSI:\r\n    case LL_RCC_USART234578_CLKSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        usart_frequency = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USART16_CLKSOURCE_LSE:\r\n    case LL_RCC_USART234578_CLKSOURCE_LSE:\r\n      if (LL_RCC_LSE_IsReady() != 0U)\r\n      {\r\n        usart_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return usart_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return LPUART clock frequency\r\n  * @param  LPUARTxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE\r\n  * @retval LPUART clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetLPUARTClockFreq(uint32_t LPUARTxSource)\r\n{\r\n  uint32_t lpuart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))\r\n  {\r\n    case LL_RCC_LPUART1_CLKSOURCE_PCLK4:\r\n      lpuart_frequency = RCC_GetPCLK4ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_LPUART1_CLKSOURCE_PLL2Q:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        lpuart_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPUART1_CLKSOURCE_PLL3Q:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        lpuart_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPUART1_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPUART1_CLKSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        lpuart_frequency = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPUART1_CLKSOURCE_LSE:\r\n      if (LL_RCC_LSE_IsReady() != 0U)\r\n      {\r\n        lpuart_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return lpuart_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return I2Cx clock frequency\r\n  * @param  I2CxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_I2C123_CLKSOURCE\r\n  *         @arg @ref LL_RCC_I2C4_CLKSOURCE\r\n  * @retval I2C clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetI2CClockFreq(uint32_t I2CxSource)\r\n{\r\n  uint32_t i2c_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_I2C_CLKSOURCE(I2CxSource));\r\n\r\n  switch (LL_RCC_GetI2CClockSource(I2CxSource))\r\n  {\r\n    case LL_RCC_I2C123_CLKSOURCE_PCLK1:\r\n      i2c_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_I2C4_CLKSOURCE_PCLK4:\r\n      i2c_frequency = RCC_GetPCLK4ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_I2C123_CLKSOURCE_PLL3R:\r\n    case LL_RCC_I2C4_CLKSOURCE_PLL3R:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        i2c_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_I2C123_CLKSOURCE_HSI:\r\n    case LL_RCC_I2C4_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_I2C123_CLKSOURCE_CSI:\r\n    case LL_RCC_I2C4_CLKSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        i2c_frequency = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return i2c_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return LPTIMx clock frequency\r\n  * @param  LPTIMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_LPTIM1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_LPTIM2_CLKSOURCE\r\n  *         @arg @ref LL_RCC_LPTIM345_CLKSOURCE\r\n  * @retval LPTIM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetLPTIMClockFreq(uint32_t LPTIMxSource)\r\n{\r\n  uint32_t lptim_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_LPTIM_CLKSOURCE(LPTIMxSource));\r\n\r\n  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))\r\n  {\r\n    case LL_RCC_LPTIM1_CLKSOURCE_PCLK1:\r\n      lptim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_LPTIM2_CLKSOURCE_PCLK4:\r\n    case LL_RCC_LPTIM345_CLKSOURCE_PCLK4:\r\n      lptim_frequency = RCC_GetPCLK4ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_LPTIM1_CLKSOURCE_PLL2P:\r\n    case LL_RCC_LPTIM2_CLKSOURCE_PLL2P:\r\n    case LL_RCC_LPTIM345_CLKSOURCE_PLL2P:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        lptim_frequency = PLL_Clocks.PLL_P_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPTIM1_CLKSOURCE_PLL3R:\r\n    case LL_RCC_LPTIM2_CLKSOURCE_PLL3R:\r\n    case LL_RCC_LPTIM345_CLKSOURCE_PLL3R:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        lptim_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPTIM1_CLKSOURCE_LSE:\r\n    case LL_RCC_LPTIM2_CLKSOURCE_LSE:\r\n    case LL_RCC_LPTIM345_CLKSOURCE_LSE:\r\n      if (LL_RCC_LSE_IsReady() != 0U)\r\n      {\r\n        lptim_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPTIM1_CLKSOURCE_LSI:\r\n    case LL_RCC_LPTIM2_CLKSOURCE_LSI:\r\n    case LL_RCC_LPTIM345_CLKSOURCE_LSI:\r\n      if (LL_RCC_LSI_IsReady() != 0U)\r\n      {\r\n        lptim_frequency = LSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_LPTIM1_CLKSOURCE_CLKP:\r\n    case LL_RCC_LPTIM2_CLKSOURCE_CLKP:\r\n    case LL_RCC_LPTIM345_CLKSOURCE_CLKP:\r\n      lptim_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return lptim_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return SAIx clock frequency\r\n  * @param  SAIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SAI1_CLKSOURCE\r\n  *         @arg @ref LL_RCC_SAI23_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI2A_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI2B_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI4A_CLKSOURCE (*)\r\n  *         @arg @ref LL_RCC_SAI4B_CLKSOURCE (*)\r\n  * @retval SAI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  *\r\n  * (*) : Available on some STM32H7 lines only.\r\n  */\r\nuint32_t LL_RCC_GetSAIClockFreq(uint32_t SAIxSource)\r\n{\r\n  uint32_t sai_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SAI_CLKSOURCE(SAIxSource));\r\n\r\n  switch (LL_RCC_GetSAIClockSource(SAIxSource))\r\n  {\r\n    case LL_RCC_SAI1_CLKSOURCE_PLL1Q:\r\n#if defined(SAI3)\r\n    case LL_RCC_SAI23_CLKSOURCE_PLL1Q:\r\n#endif /* SAI3 */\r\n#if defined(SAI4)\r\n    case LL_RCC_SAI4A_CLKSOURCE_PLL1Q:\r\n    case LL_RCC_SAI4B_CLKSOURCE_PLL1Q:\r\n#endif /* SAI4 */\r\n#if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)\r\n    case LL_RCC_SAI2A_CLKSOURCE_PLL1Q:\r\n    case LL_RCC_SAI2B_CLKSOURCE_PLL1Q:\r\n#endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */ \r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        sai_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SAI1_CLKSOURCE_PLL2P:\r\n#if defined(SAI3)\r\n    case LL_RCC_SAI23_CLKSOURCE_PLL2P:\r\n#endif /* SAI3 */\r\n#if defined(SAI4)\r\n    case LL_RCC_SAI4A_CLKSOURCE_PLL2P:\r\n    case LL_RCC_SAI4B_CLKSOURCE_PLL2P:\r\n#endif /* SAI4 */\r\n#if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)\r\n    case LL_RCC_SAI2A_CLKSOURCE_PLL2P:\r\n    case LL_RCC_SAI2B_CLKSOURCE_PLL2P:\r\n#endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        sai_frequency = PLL_Clocks.PLL_P_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SAI1_CLKSOURCE_PLL3P:\r\n#if defined(SAI3)\r\n    case LL_RCC_SAI23_CLKSOURCE_PLL3P:\r\n#endif /* SAI3 */\r\n#if defined(SAI4)\r\n    case LL_RCC_SAI4A_CLKSOURCE_PLL3P:\r\n    case LL_RCC_SAI4B_CLKSOURCE_PLL3P:\r\n#endif /* SAI4 */\r\n#if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)\r\n    case LL_RCC_SAI2A_CLKSOURCE_PLL3P:\r\n    case LL_RCC_SAI2B_CLKSOURCE_PLL3P:\r\n#endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        sai_frequency = PLL_Clocks.PLL_P_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:\r\n#if defined(SAI3)\r\n    case LL_RCC_SAI23_CLKSOURCE_I2S_CKIN:\r\n#endif /* SAI3 */\r\n#if defined(SAI4)\r\n    case LL_RCC_SAI4A_CLKSOURCE_I2S_CKIN:\r\n    case LL_RCC_SAI4B_CLKSOURCE_I2S_CKIN:\r\n#endif /* SAI4 */\r\n#if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)\r\n    case LL_RCC_SAI2A_CLKSOURCE_I2S_CKIN:\r\n    case LL_RCC_SAI2B_CLKSOURCE_I2S_CKIN:\r\n#endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */\r\n      sai_frequency = EXTERNAL_CLOCK_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SAI1_CLKSOURCE_CLKP:\r\n#if defined(SAI3)\r\n    case LL_RCC_SAI23_CLKSOURCE_CLKP:\r\n#endif /* SAI3 */\r\n#if defined(SAI4)\r\n    case LL_RCC_SAI4A_CLKSOURCE_CLKP:\r\n    case LL_RCC_SAI4B_CLKSOURCE_CLKP:\r\n#endif /* SAI4 */\r\n#if defined (RCC_CDCCIP1R_SAI2ASEL) || defined(RCC_CDCCIP1R_SAI2BSEL)\r\n    case LL_RCC_SAI2A_CLKSOURCE_CLKP:\r\n    case LL_RCC_SAI2B_CLKSOURCE_CLKP:\r\n#endif /* RCC_CDCCIP1R_SAI2ASEL || RCC_CDCCIP1R_SAI2BSEL */\r\n      sai_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return sai_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return ADC clock frequency\r\n  * @param  ADCxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_ADC_CLKSOURCE\r\n  * @retval ADC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetADCClockFreq(uint32_t ADCxSource)\r\n{\r\n  uint32_t adc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetADCClockSource(ADCxSource))\r\n  {\r\n    case LL_RCC_ADC_CLKSOURCE_PLL2P:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        adc_frequency = PLL_Clocks.PLL_P_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_ADC_CLKSOURCE_PLL3R:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        adc_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_ADC_CLKSOURCE_CLKP:\r\n      adc_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return adc_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return SDMMC clock frequency\r\n  * @param  SDMMCxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SDMMC_CLKSOURCE\r\n  * @retval SDMMC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSDMMCClockFreq(uint32_t SDMMCxSource)\r\n{\r\n  uint32_t sdmmc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))\r\n  {\r\n    case LL_RCC_SDMMC_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        sdmmc_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SDMMC_CLKSOURCE_PLL2R:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        sdmmc_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return sdmmc_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return RNG clock frequency\r\n  * @param  RNGxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_RNG_CLKSOURCE\r\n  * @retval RNG clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetRNGClockFreq(uint32_t RNGxSource)\r\n{\r\n  uint32_t rng_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetRNGClockSource(RNGxSource))\r\n  {\r\n    case LL_RCC_RNG_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        rng_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_RNG_CLKSOURCE_HSI48:\r\n      if (LL_RCC_HSI48_IsReady() != 0U)\r\n      {\r\n        rng_frequency = 48000000U;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_RNG_CLKSOURCE_LSE:\r\n      if (LL_RCC_LSE_IsReady() != 0U)\r\n      {\r\n        rng_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_RNG_CLKSOURCE_LSI:\r\n      if (LL_RCC_LSI_IsReady() != 0U)\r\n      {\r\n        rng_frequency = LSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return rng_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return CEC clock frequency\r\n  * @param  CECxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_RNG_CLKSOURCE\r\n  * @retval CEC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetCECClockFreq(uint32_t CECxSource)\r\n{\r\n  uint32_t cec_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  switch (LL_RCC_GetCECClockSource(CECxSource))\r\n  {\r\n    case LL_RCC_CEC_CLKSOURCE_LSE:\r\n      if (LL_RCC_LSE_IsReady() != 0U)\r\n      {\r\n        cec_frequency = LSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_CEC_CLKSOURCE_LSI:\r\n      if (LL_RCC_LSI_IsReady() != 0U)\r\n      {\r\n        cec_frequency = LSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_CEC_CLKSOURCE_CSI_DIV122:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        cec_frequency = CSI_VALUE / 122U;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return cec_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return USB clock frequency\r\n  * @param  USBxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_USB_CLKSOURCE\r\n  * @retval USB clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled\r\n  */\r\nuint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)\r\n{\r\n  uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetUSBClockSource(USBxSource))\r\n  {\r\n    case LL_RCC_USB_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        usb_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USB_CLKSOURCE_PLL3Q:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        usb_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USB_CLKSOURCE_HSI48:\r\n      if (LL_RCC_HSI48_IsReady() != 0U)\r\n      {\r\n        usb_frequency = HSI48_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_USB_CLKSOURCE_DISABLE:\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return usb_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return DFSDM clock frequency\r\n  * @param  DFSDMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DFSDM1_CLKSOURCE\r\n  * @retval DFSDM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetDFSDMClockFreq(uint32_t DFSDMxSource)\r\n{\r\n  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  switch (LL_RCC_GetDFSDMClockSource(DFSDMxSource))\r\n  {\r\n    case LL_RCC_DFSDM1_CLKSOURCE_SYSCLK:\r\n      dfsdm_frequency = RCC_GetSystemClockFreq();\r\n      break;\r\n\r\n    case LL_RCC_DFSDM1_CLKSOURCE_PCLK2:\r\n      dfsdm_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return dfsdm_frequency;\r\n}\r\n\r\n#if defined(DFSDM2_BASE)\r\n/**\r\n  * @brief  Return DFSDM clock frequency\r\n  * @param  DFSDMxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DFSDM2_CLKSOURCE\r\n  * @retval DFSDM clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetDFSDM2ClockFreq(uint32_t DFSDMxSource)\r\n{\r\n  uint32_t dfsdm_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n\r\n  switch (LL_RCC_GetDFSDM2ClockSource(DFSDMxSource))\r\n  {\r\n\r\n    case LL_RCC_DFSDM2_CLKSOURCE_SYSCLK:\r\n      dfsdm_frequency = RCC_GetSystemClockFreq();\r\n      break;\r\n\r\n    case LL_RCC_DFSDM2_CLKSOURCE_PCLK4:\r\n      dfsdm_frequency = RCC_GetPCLK4ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return dfsdm_frequency;\r\n}\r\n#endif /* DFSDM2_BASE */\r\n\r\n#if defined(DSI)\r\n/**\r\n  * @brief  Return DSI clock frequency\r\n  * @param  DSIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_DSI_CLKSOURCE\r\n  * @retval DSI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NA indicates that external clock is used\r\n  */\r\nuint32_t LL_RCC_GetDSIClockFreq(uint32_t DSIxSource)\r\n{\r\n  uint32_t dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetDSIClockSource(DSIxSource))\r\n  {\r\n    case LL_RCC_DSI_CLKSOURCE_PLL2Q:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        dsi_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_DSI_CLKSOURCE_PHY:\r\n      dsi_frequency = LL_RCC_PERIPH_FREQUENCY_NA;\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return dsi_frequency;\r\n}\r\n#endif /* DSI */\r\n\r\n/**\r\n  * @brief  Return SPDIF clock frequency\r\n  * @param  SPDIFxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SPDIF_CLKSOURCE\r\n  * @retval SPDIF clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSPDIFClockFreq(uint32_t SPDIFxSource)\r\n{\r\n  uint32_t spdif_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetSPDIFClockSource(SPDIFxSource))\r\n  {\r\n    case LL_RCC_SPDIF_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        spdif_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPDIF_CLKSOURCE_PLL2R:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        spdif_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPDIF_CLKSOURCE_PLL3R:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        spdif_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPDIF_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        spdif_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return spdif_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return SPIx clock frequency\r\n  * @param  SPIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SPI123_CLKSOURCE\r\n  *         @arg @ref LL_RCC_SPI45_CLKSOURCE\r\n  *         @arg @ref LL_RCC_SPI6_CLKSOURCE\r\n  * @retval SPI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSPIClockFreq(uint32_t SPIxSource)\r\n{\r\n  uint32_t spi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  /* Check parameter */\r\n  assert_param(IS_LL_RCC_SPI_CLKSOURCE(SPIxSource));\r\n\r\n  switch (LL_RCC_GetSPIClockSource(SPIxSource))\r\n  {\r\n    case LL_RCC_SPI123_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        spi_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI123_CLKSOURCE_PLL2P:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        spi_frequency = PLL_Clocks.PLL_P_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI123_CLKSOURCE_PLL3P:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        spi_frequency = PLL_Clocks.PLL_P_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI123_CLKSOURCE_I2S_CKIN:\r\n#if defined(LL_RCC_SPI6_CLKSOURCE_I2S_CKIN)\r\n    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:\r\n#endif /* LL_RCC_SPI6_CLKSOURCE_I2S_CKIN */\r\n      spi_frequency = EXTERNAL_CLOCK_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SPI123_CLKSOURCE_CLKP:\r\n      spi_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    case LL_RCC_SPI45_CLKSOURCE_PCLK2:\r\n      spi_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_SPI6_CLKSOURCE_PCLK4:\r\n      spi_frequency = RCC_GetPCLK4ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_SPI45_CLKSOURCE_PLL2Q:\r\n    case LL_RCC_SPI6_CLKSOURCE_PLL2Q:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        spi_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI45_CLKSOURCE_PLL3Q:\r\n    case LL_RCC_SPI6_CLKSOURCE_PLL3Q:\r\n      if (LL_RCC_PLL3_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL3ClockFreq(&PLL_Clocks);\r\n        spi_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI45_CLKSOURCE_HSI:\r\n    case LL_RCC_SPI6_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI45_CLKSOURCE_CSI:\r\n    case LL_RCC_SPI6_CLKSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        spi_frequency = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_SPI45_CLKSOURCE_HSE:\r\n    case LL_RCC_SPI6_CLKSOURCE_HSE:\r\n      if (LL_RCC_HSE_IsReady() != 0U)\r\n      {\r\n        spi_frequency = HSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return spi_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return SWP clock frequency\r\n  * @param  SWPxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_SWP_CLKSOURCE\r\n  * @retval SWP clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetSWPClockFreq(uint32_t SWPxSource)\r\n{\r\n  uint32_t swp_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  switch (LL_RCC_GetSWPClockSource(SWPxSource))\r\n  {\r\n    case LL_RCC_SWP_CLKSOURCE_PCLK1:\r\n      swp_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler())));\r\n      break;\r\n\r\n    case LL_RCC_SWP_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        swp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return swp_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return FDCAN clock frequency\r\n  * @param  FDCANxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_FDCAN_CLKSOURCE\r\n  * @retval FDCAN clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetFDCANClockFreq(uint32_t FDCANxSource)\r\n{\r\n  uint32_t fdcan_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))\r\n  {\r\n    case LL_RCC_FDCAN_CLKSOURCE_HSE:\r\n      if (LL_RCC_HSE_IsReady() != 0U)\r\n      {\r\n        fdcan_frequency = HSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_FDCAN_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        fdcan_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_FDCAN_CLKSOURCE_PLL2Q:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        fdcan_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* Kernel clock disabled */\r\n      break;\r\n  }\r\n\r\n  return fdcan_frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return FMC clock frequency\r\n  * @param  FMCxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_FMC_CLKSOURCE\r\n  * @retval FMC clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetFMCClockFreq(uint32_t FMCxSource)\r\n{\r\n  uint32_t fmc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetFMCClockSource(FMCxSource))\r\n  {\r\n    case LL_RCC_FMC_CLKSOURCE_HCLK:\r\n      fmc_frequency = RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler()));\r\n      break;\r\n\r\n    case LL_RCC_FMC_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        fmc_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_FMC_CLKSOURCE_PLL2R:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        fmc_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_FMC_CLKSOURCE_CLKP:\r\n      fmc_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return fmc_frequency;\r\n}\r\n\r\n#if defined(QUADSPI)\r\n/**\r\n  * @brief  Return QSPI clock frequency\r\n  * @param  QSPIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_QSPI_CLKSOURCE\r\n  * @retval QSPI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetQSPIClockFreq(uint32_t QSPIxSource)\r\n{\r\n  uint32_t qspi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetQSPIClockSource(QSPIxSource))\r\n  {\r\n    case LL_RCC_QSPI_CLKSOURCE_HCLK:\r\n      qspi_frequency = RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler()));\r\n      break;\r\n\r\n    case LL_RCC_QSPI_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        qspi_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_QSPI_CLKSOURCE_PLL2R:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        qspi_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_QSPI_CLKSOURCE_CLKP:\r\n      qspi_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return qspi_frequency;\r\n}\r\n#endif /* QUADSPI */\r\n\r\n#if defined(OCTOSPI1) || defined(OCTOSPI2)\r\n/**\r\n  * @brief  Return OSPI clock frequency\r\n  * @param  OSPIxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_OSPI_CLKSOURCE\r\n  * @retval OSPI clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\n\r\nuint32_t LL_RCC_GetOSPIClockFreq(uint32_t OSPIxSource)\r\n{\r\n  uint32_t ospi_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  switch (LL_RCC_GetOSPIClockSource(OSPIxSource))\r\n  {\r\n    case LL_RCC_OSPI_CLKSOURCE_HCLK:\r\n      ospi_frequency = RCC_GetHCLKClockFreq(LL_RCC_CALC_SYSCLK_FREQ(RCC_GetSystemClockFreq(),LL_RCC_GetSysPrescaler()));\r\n      break;\r\n\r\n    case LL_RCC_OSPI_CLKSOURCE_PLL1Q:\r\n      if (LL_RCC_PLL1_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n        ospi_frequency = PLL_Clocks.PLL_Q_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_OSPI_CLKSOURCE_PLL2R:\r\n      if (LL_RCC_PLL2_IsReady() != 0U)\r\n      {\r\n        LL_RCC_GetPLL2ClockFreq(&PLL_Clocks);\r\n        ospi_frequency = PLL_Clocks.PLL_R_Frequency;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_OSPI_CLKSOURCE_CLKP:\r\n      ospi_frequency = LL_RCC_GetCLKPClockFreq(LL_RCC_CLKP_CLKSOURCE);\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return ospi_frequency;\r\n}\r\n#endif /* defined(OCTOSPI1) || defined(OCTOSPI2) */\r\n\r\n/**\r\n  * @brief  Return CLKP clock frequency\r\n  * @param  CLKPxSource This parameter can be one of the following values:\r\n  *         @arg @ref LL_RCC_CLKP_CLKSOURCE\r\n  * @retval CLKP clock frequency (in Hz)\r\n  *         - @ref  LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready\r\n  */\r\nuint32_t LL_RCC_GetCLKPClockFreq(uint32_t CLKPxSource)\r\n{\r\n  uint32_t clkp_frequency = LL_RCC_PERIPH_FREQUENCY_NO;\r\n\r\n  switch (LL_RCC_GetCLKPClockSource(CLKPxSource))\r\n  {\r\n    case LL_RCC_CLKP_CLKSOURCE_HSI:\r\n      if (LL_RCC_HSI_IsReady() != 0U)\r\n      {\r\n        clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_CLKP_CLKSOURCE_CSI:\r\n      if (LL_RCC_CSI_IsReady() != 0U)\r\n      {\r\n        clkp_frequency = CSI_VALUE;\r\n      }\r\n      break;\r\n\r\n    case LL_RCC_CLKP_CLKSOURCE_HSE:\r\n      if (LL_RCC_HSE_IsReady() != 0U)\r\n      {\r\n        clkp_frequency = HSE_VALUE;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      /* CLKP clock disabled */\r\n      break;\r\n  }\r\n\r\n  return clkp_frequency;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup RCC_LL_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Return SYSTEM clock frequency\r\n  * @retval SYSTEM clock frequency (in Hz)\r\n  */\r\nstatic uint32_t RCC_GetSystemClockFreq(void)\r\n{\r\n  uint32_t frequency = 0U;\r\n  LL_PLL_ClocksTypeDef PLL_Clocks;\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n  switch (LL_RCC_GetSysClkSource())\r\n  {\r\n    /* No check on Ready: Won't be selected by hardware if not */\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:\r\n      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider()>> RCC_CR_HSIDIV_Pos);\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_CSI:\r\n      frequency = CSI_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:\r\n      frequency = HSE_VALUE;\r\n      break;\r\n\r\n    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL1:\r\n      LL_RCC_GetPLL1ClockFreq(&PLL_Clocks);\r\n      frequency = PLL_Clocks.PLL_P_Frequency;\r\n      break;\r\n\r\n    default:\r\n      /* Nothing to do */\r\n      break;\r\n  }\r\n\r\n  return frequency;\r\n}\r\n\r\n/**\r\n  * @brief  Return HCLK clock frequency\r\n  * @param  SYSCLK_Frequency SYSCLK clock frequency\r\n  * @retval HCLK clock frequency (in Hz)\r\n  */\r\nstatic uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)\r\n{\r\n  /* HCLK clock frequency */\r\n  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK1 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK1 clock frequency (in Hz)\r\n  */\r\nstatic uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK1 clock frequency */\r\n  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK2 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK2 clock frequency (in Hz)\r\n  */\r\nstatic uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK2 clock frequency */\r\n  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK3 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK3 clock frequency (in Hz)\r\n  */\r\nstatic uint32_t RCC_GetPCLK3ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK3 clock frequency */\r\n  return LL_RCC_CALC_PCLK3_FREQ(HCLK_Frequency, LL_RCC_GetAPB3Prescaler());\r\n}\r\n\r\n/**\r\n  * @brief  Return PCLK4 clock frequency\r\n  * @param  HCLK_Frequency HCLK clock frequency\r\n  * @retval PCLK4 clock frequency (in Hz)\r\n  */\r\nstatic uint32_t RCC_GetPCLK4ClockFreq(uint32_t HCLK_Frequency)\r\n{\r\n  /* PCLK4 clock frequency */\r\n  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* defined(RCC) */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#endif /* USE_FULL_LL_DRIVER */\r\n\r\n"},{"name":"stm32h7xx_ll_utils.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Drivers\\STM32H7xx_HAL_Driver\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    stm32h7xx_ll_utils.c\r\n  * @author  MCD Application Team\r\n  * @brief   UTILS LL module driver.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file in\r\n  * the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32h7xx_ll_utils.h\"\r\n#include \"stm32h7xx_ll_rcc.h\"\r\n#include \"stm32h7xx_ll_pwr.h\"\r\n\r\n#ifdef  USE_FULL_ASSERT\r\n  #include \"stm32_assert.h\"\r\n#else\r\n  #define assert_param(expr) ((void)0U)\r\n#endif /* USE_FULL_ASSERT */\r\n\r\n/** @addtogroup STM32H7xx_LL_Driver\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup UTILS_LL\r\n  * @{\r\n  */\r\n\r\n/* Private types -------------------------------------------------------------*/\r\n/* Private variables ---------------------------------------------------------*/\r\n/* Private constants ---------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Private_Constants\r\n  * @{\r\n  */\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n#define UTILS_MAX_FREQUENCY_SCALE1  480000000U      /*!< Maximum frequency for system clock at power scale1, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE2  300000000U      /*!< Maximum frequency for system clock at power scale2, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE3  200000000U      /*!< Maximum frequency for system clock at power scale3, in Hz */\r\n#elif (STM32H7_DEV_ID == 0x480UL)\r\n#define UTILS_MAX_FREQUENCY_SCALE0  280000000U      /*!< Maximum frequency for system clock at power scale0, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE1  225000000U      /*!< Maximum frequency for system clock at power scale1, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE2  160000000U      /*!< Maximum frequency for system clock at power scale2, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE3   88000000U      /*!< Maximum frequency for system clock at power scale3, in Hz */\r\n#elif (STM32H7_DEV_ID == 0x483UL)\r\n#define UTILS_MAX_FREQUENCY_SCALE0  550000000U      /*!< Maximum frequency for system clock at power scale0, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE1  200000000U      /*!< Maximum frequency for system clock at power scale1, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE2  150000000U      /*!< Maximum frequency for system clock at power scale2, in Hz */\r\n#define UTILS_MAX_FREQUENCY_SCALE3   85000000U      /*!< Maximum frequency for system clock at power scale3, in Hz */\r\n#endif /*STM32H7_DEV_ID == 0x450UL*/\r\n\r\n/* Defines used for PLL range */\r\n#define UTILS_PLLVCO_INPUT_MIN1       1000000U      /*!< Frequency min for the low range PLLVCO input, in Hz    */\r\n#define UTILS_PLLVCO_INPUT_MAX1       2000000U      /*!< Frequency max for the wide range PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_INPUT_MIN2       2000000U      /*!< Frequency min for the low range PLLVCO input, in Hz    */\r\n#define UTILS_PLLVCO_INPUT_MAX2       4000000U      /*!< Frequency max for the wide range PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_INPUT_MIN3       4000000U      /*!< Frequency min for the low range PLLVCO input, in Hz    */\r\n#define UTILS_PLLVCO_INPUT_MAX3       8000000U      /*!< Frequency max for the wide range PLLVCO input, in Hz   */\r\n#define UTILS_PLLVCO_INPUT_MIN4       8000000U      /*!< Frequency min for the low range PLLVCO input, in Hz    */\r\n#define UTILS_PLLVCO_INPUT_MAX4      16000000U      /*!< Frequency max for the wide range PLLVCO input, in Hz   */\r\n\r\n#if (POWER_DOMAINS_NUMBER == 3U)\r\n#define UTILS_PLLVCO_MEDIUM_OUTPUT_MIN    150000000U      /*!< Frequency min for the medium range PLLVCO output, in Hz   */\r\n#define UTILS_PLLVCO_WIDE_OUTPUT_MIN      192000000U      /*!< Frequency min for the wide range PLLVCO output, in Hz   */\r\n#define UTILS_PLLVCO_MEDIUM_OUTPUT_MAX    420000000U      /*!< Frequency max for the medium range PLLVCO output, in Hz  */\r\n#define UTILS_PLLVCO_WIDE_OUTPUT_MAX      836000000U      /*!< Frequency max for the wide range PLLVCO output, in Hz  */\r\n#else\r\n#define UTILS_PLLVCO_MEDIUM_OUTPUT_MIN    150000000U      /*!< Frequency min for the medium range PLLVCO output, in Hz   */\r\n#define UTILS_PLLVCO_WIDE_OUTPUT_MIN      128000000U      /*!< Frequency min for the wide range PLLVCO output, in Hz   */\r\n#define UTILS_PLLVCO_MEDIUM_OUTPUT_MAX    420000000U      /*!< Frequency max for the medium range PLLVCO output, in Hz  */\r\n#define UTILS_PLLVCO_WIDE_OUTPUT_MAX      560000000U      /*!< Frequency max for the wide range PLLVCO output, in Hz  */\r\n#endif /*POWER_DOMAINS_NUMBER == 3U*/\r\n\r\n/* Defines used for HSE range */\r\n#define UTILS_HSE_FREQUENCY_MIN      4000000U        /*!< Frequency min for HSE frequency, in Hz   */\r\n#define UTILS_HSE_FREQUENCY_MAX     48000000U        /*!< Frequency max for HSE frequency, in Hz   */\r\n\r\n/* Defines used for FLASH latency according to HCLK Frequency */\r\n#if (STM32H7_DEV_ID == 0x480UL)\r\n#define UTILS_SCALE0_LATENCY0_FREQ   44000000U       /*!< HCLK frequency to set FLASH latency 0 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY1_FREQ   88000000U       /*!< HCLK frequency to set FLASH latency 1 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY2_FREQ  132000000U       /*!< HCLK frequency to set FLASH latency 2 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY3_FREQ  176000000U       /*!< HCLK frequency to set FLASH latency 3 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY4_FREQ  220000000U       /*!< HCLK frequency to set FLASH latency 4 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY5_FREQ  264000000U       /*!< HCLK frequency to set FLASH latency 5 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY6_FREQ  280000000U       /*!< HCLK frequency to set FLASH latency 6 in power scale 0  */\r\n\r\n#define UTILS_SCALE1_LATENCY0_FREQ   42000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY1_FREQ   84000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY2_FREQ  126000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY3_FREQ  168000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY4_FREQ  210000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY5_FREQ  225000000U      /*!< HCLK frequency to set FLASH latency 5 in power scale 1  */\r\n\r\n#define UTILS_SCALE2_LATENCY0_FREQ   34000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY1_FREQ   68000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY2_FREQ  102000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY3_FREQ  136000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY4_FREQ  160000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 2  */\r\n\r\n#define UTILS_SCALE3_LATENCY0_FREQ   22000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY1_FREQ   44000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY2_FREQ   66000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY3_FREQ   88000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 3  */\r\n\r\n#elif (STM32H7_DEV_ID == 0x450UL)\r\n\r\n#define UTILS_SCALE1_LATENCY0_FREQ   70000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY1_FREQ  140000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY2_FREQ  240000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 1  */\r\n\r\n#define UTILS_SCALE2_LATENCY0_FREQ   55000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY1_FREQ  110000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY2_FREQ  165000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY3_FREQ  220000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 2  */\r\n\r\n#define UTILS_SCALE3_LATENCY0_FREQ   45000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY1_FREQ   90000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY2_FREQ  135000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY3_FREQ  180000000U      /*!< HCLK frequency to set FLASH latency 3 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY4_FREQ  225000000U      /*!< HCLK frequency to set FLASH latency 4 in power scale 3  */\r\n\r\n#elif (STM32H7_DEV_ID == 0x483UL)\r\n\r\n#define UTILS_SCALE0_LATENCY0_FREQ   70000000U       /*!< HCLK frequency to set FLASH latency 0 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY1_FREQ  140000000U       /*!< HCLK frequency to set FLASH latency 1 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY2_FREQ  210000000U       /*!< HCLK frequency to set FLASH latency 2 in power scale 0  */\r\n#define UTILS_SCALE0_LATENCY3_FREQ  275000000U       /*!< HCLK frequency to set FLASH latency 3 in power scale 0  */\r\n\r\n#define UTILS_SCALE1_LATENCY0_FREQ   67000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY1_FREQ  133000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 1  */\r\n#define UTILS_SCALE1_LATENCY2_FREQ  200000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 1  */\r\n\r\n#define UTILS_SCALE2_LATENCY0_FREQ   50000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY1_FREQ  100000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 2  */\r\n#define UTILS_SCALE2_LATENCY2_FREQ  150000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 2  */\r\n\r\n#define UTILS_SCALE3_LATENCY0_FREQ   35000000U      /*!< HCLK frequency to set FLASH latency 0 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY1_FREQ   70000000U      /*!< HCLK frequency to set FLASH latency 1 in power scale 3  */\r\n#define UTILS_SCALE3_LATENCY2_FREQ   85000000U      /*!< HCLK frequency to set FLASH latency 2 in power scale 3  */\r\n\r\n#endif /*STM32H7_DEV_ID == 0x480UL*/\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macros ------------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Private_Macros\r\n  * @{\r\n  */\r\n#define IS_LL_UTILS_SYSCLK_DIV(__VALUE__) (((__VALUE__) == LL_RCC_SYSCLK_DIV_1)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_2)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_4)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_8)   \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_16)  \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_64)  \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_128) \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_256) \\\r\n                                        || ((__VALUE__) == LL_RCC_SYSCLK_DIV_512))\r\n\r\n#define IS_LL_UTILS_AHB_DIV(__VALUE__)    (((__VALUE__) == LL_RCC_AHB_DIV_1)   \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_2)   \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_4)   \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_8)   \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_16)  \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_64)  \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_128) \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_256) \\\r\n                                        || ((__VALUE__) == LL_RCC_AHB_DIV_512))\r\n\r\n#define IS_LL_UTILS_APB1_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB1_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB1_DIV_16))\r\n\r\n#define IS_LL_UTILS_APB2_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB2_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB2_DIV_16))\r\n\r\n#define IS_LL_UTILS_APB3_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB3_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB3_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB3_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB3_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB3_DIV_16))\r\n\r\n#define IS_LL_UTILS_APB4_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB4_DIV_1) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB4_DIV_2) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB4_DIV_4) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB4_DIV_8) \\\r\n                                      || ((__VALUE__) == LL_RCC_APB4_DIV_16))\r\n\r\n#define IS_LL_UTILS_PLLM_VALUE(__VALUE__) ((1U <= (__VALUE__)) && ((__VALUE__) <= 63U))\r\n\r\n#if (POWER_DOMAINS_NUMBER == 3U)\r\n#define IS_LL_UTILS_PLLN_VALUE(__VALUE__) ((4U <= (__VALUE__)) && ((__VALUE__) <= 512U))\r\n#else\r\n#define IS_LL_UTILS_PLLN_VALUE(__VALUE__) ((8U <= (__VALUE__)) && ((__VALUE__) <= 420U))\r\n#endif /*POWER_DOMAINS_NUMBER == 3U*/\r\n\r\n#define IS_LL_UTILS_PLLP_VALUE(__VALUE__) ((1U <= (__VALUE__)) && ((__VALUE__) <= 128U))\r\n\r\n#define IS_LL_UTILS_FRACN_VALUE(__VALUE__) ((__VALUE__) <= 0x1FFFU)\r\n\r\n#define IS_LL_UTILS_PLLVCO_INPUT(__VALUE__, __RANGE__)  ( \\\r\n(((__RANGE__) == LL_RCC_PLLINPUTRANGE_1_2) && (UTILS_PLLVCO_INPUT_MIN1 <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_INPUT_MAX1)) || \\\r\n(((__RANGE__) == LL_RCC_PLLINPUTRANGE_2_4) && (UTILS_PLLVCO_INPUT_MIN2 <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_INPUT_MAX2)) || \\\r\n(((__RANGE__) == LL_RCC_PLLINPUTRANGE_4_8) && (UTILS_PLLVCO_INPUT_MIN3 <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_INPUT_MAX3)) || \\\r\n(((__RANGE__) == LL_RCC_PLLINPUTRANGE_8_16) && (UTILS_PLLVCO_INPUT_MIN4 <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_INPUT_MAX4)))\r\n\r\n#define IS_LL_UTILS_PLLVCO_OUTPUT(__VALUE__, __RANGE__) ( \\\r\n(((__RANGE__) == LL_RCC_PLLVCORANGE_MEDIUM) && (UTILS_PLLVCO_MEDIUM_OUTPUT_MIN <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_MEDIUM_OUTPUT_MAX)) || \\\r\n(((__RANGE__) == LL_RCC_PLLVCORANGE_WIDE) && (UTILS_PLLVCO_WIDE_OUTPUT_MIN <= (__VALUE__)) && ((__VALUE__) <= UTILS_PLLVCO_WIDE_OUTPUT_MAX)))\r\n\r\n#define IS_LL_UTILS_CHECK_VCO_RANGES(__RANGEIN__, __RANGEOUT__) ( \\\r\n(((__RANGEIN__) == LL_RCC_PLLINPUTRANGE_1_2) && ((__RANGEOUT__) == LL_RCC_PLLVCORANGE_MEDIUM)) || \\\r\n(((__RANGEIN__) != LL_RCC_PLLINPUTRANGE_1_2) && ((__RANGEOUT__) == LL_RCC_PLLVCORANGE_WIDE)))\r\n\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n#define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE1) : \\\r\n                                              (LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE2) : \\\r\n                                              ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE3))\r\n#else\r\n#define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE0) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE0) : \\\r\n                                              (LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE1) : \\\r\n                                              (LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2) ? ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE2) : \\\r\n                                              ((__VALUE__) <= UTILS_MAX_FREQUENCY_SCALE3))\r\n#endif /* STM32H7_DEV_ID == 0x450UL */\r\n\r\n#define IS_LL_UTILS_HSE_BYPASS(__STATE__) (((__STATE__) == LL_UTILS_HSEBYPASS_ON) \\\r\n                                        || ((__STATE__) == LL_UTILS_HSEBYPASS_OFF))\r\n\r\n#define IS_LL_UTILS_HSE_FREQUENCY(__FREQUENCY__) (((__FREQUENCY__) >= UTILS_HSE_FREQUENCY_MIN) && ((__FREQUENCY__) <= UTILS_HSE_FREQUENCY_MAX))\r\n/**\r\n  * @}\r\n  */\r\n/* Private function prototypes -----------------------------------------------*/\r\n/** @defgroup UTILS_LL_Private_Functions UTILS Private functions\r\n  * @{\r\n  */\r\nstatic uint32_t    UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct);\r\nstatic ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);\r\nstatic ErrorStatus UTILS_IsPLLsReady(void);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Exported functions --------------------------------------------------------*/\r\n/** @addtogroup UTILS_LL_Exported_Functions\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup UTILS_LL_EF_DELAY\r\n  * @{\r\n  */\r\n#if defined (DUAL_CORE)\r\n/**\r\n  * @brief  This function configures the Cortex-M SysTick source to have 1ms time base.\r\n  * @note   When a RTOS is used, it is recommended to avoid changing the Systick\r\n  *         configuration by calling this function, for a delay use rather osDelay RTOS service.\r\n  * @param  CPU_Frequency Core frequency in Hz\r\n  * @note   CPU_Frequency can be calculated thanks to RCC helper macro or function\r\n  *         @ref LL_RCC_GetSystemClocksFreq\r\n  *         LL_RCC_GetSystemClocksFreq() is used to calculate the CM7 clock frequency\r\n  *         and __LL_RCC_CALC_HCLK_FREQ is used to calculate the CM4 clock frequency.\r\n  * @retval None\r\n  */\r\n#else\r\n/**\r\n  * @brief  This function configures the Cortex-M SysTick source to have 1ms time base.\r\n  * @note   When a RTOS is used, it is recommended to avoid changing the Systick\r\n  *         configuration by calling this function, for a delay use rather osDelay RTOS service.\r\n  * @param  CPU_Frequency Core frequency in Hz\r\n  * @note   CPU_Frequency can be calculated thanks to RCC helper macro or function\r\n  *         @ref LL_RCC_GetSystemClocksFreq\r\n  * @retval None\r\n  */\r\n#endif /* DUAL_CORE */\r\nvoid LL_Init1msTick(uint32_t CPU_Frequency)\r\n{\r\n  /* Use frequency provided in argument */\r\n  LL_InitTick(CPU_Frequency, 1000U);\r\n}\r\n\r\n\r\n/**\r\n  * @brief  This function provides accurate delay (in milliseconds) based\r\n  *         on SysTick counter flag\r\n  * @note   When a RTOS is used, it is recommended to avoid using blocking delay\r\n  *         and use rather osDelay service.\r\n  * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which\r\n  *         will configure Systick to 1ms\r\n  * @param  Delay specifies the delay time length, in milliseconds.\r\n  * @retval None\r\n  */\r\nvoid LL_mDelay(uint32_t Delay)\r\n{\r\n  uint32_t count = Delay;\r\n  __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */\r\n  /* Add this code to indicate that local variable is not used */\r\n  ((void)tmp);\r\n\r\n  /* Add a period to guaranty minimum wait */\r\n  if(count < LL_MAX_DELAY)\r\n  {\r\n    count++;\r\n  }\r\n\r\n  while (count != 0U)\r\n  {\r\n    if((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)\r\n    {\r\n      count--;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n/** @addtogroup UTILS_EF_SYSTEM\r\n  *  @brief    System Configuration functions\r\n  *\r\n  @verbatim\r\n ===============================================================================\r\n           ##### System Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n         System, AHB and APB buses clocks configuration\r\n\r\n         (+) The maximum frequency of the SYSCLK is 480 MHz(*) and HCLK is 240 MHz.\r\n         (+) The maximum frequency of the PCLK1, PCLK2, PCLK3 and PCLK4 is 120 MHz.\r\n  @endverbatim\r\n  @internal\r\n             Depending on the device voltage range, the maximum frequency should be\r\n             adapted accordingly:\r\n             (++) +----------------------------------------------------------------------------+\r\n             (++) |  Wait states   |                           HCLK clock frequency (MHz)      |\r\n             (++) |                |-----------------------------------------------------------|\r\n             (++) |  (Latency)     |   voltage range 1 |   voltage range 2 |   voltage range 3 |\r\n             (++) |                |    1.15V - 1.26V  |    1.05V - 1.15V  |    0.95V - 1.05V  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|\r\n             (++) |0WS(1CPU cycle) |   0 < HCLK <= 70  |   0 < HCLK <= 55  |   0 < HCLK <= 45  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|\r\n             (++) |1WS(2CPU cycle) |  70 < HCLK <= 140 |  55 < HCLK <= 110 |  45 < HCLK <= 90  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|\r\n             (++) |2WS(3CPU cycle) | 140 < HCLK <= 240 | 110 < HCLK <= 165 |  90 < HCLK <= 135 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|\r\n             (++) |3WS(4CPU cycle) |        --         | 165 < HCLK <= 220 | 135 < HCLK <= 180 |\r\n             (++) |----------------|-------------------|-------------------|-------------------|\r\n             (++) |4WS(5CPU cycle) |        --         |        --         | 180 < HCLK <= 225 |\r\n             (++) +----------------------------------------------------------------------------+\r\n\r\n  (*) : For stm32h74xxx and stm32h75xxx family lines and requires the board to be connected on LDO regulator not SMPS, 400MHZ otherwise.\r\n  @endinternal\r\n  * @{\r\n  */\r\n\r\n#elif (STM32H7_DEV_ID == 0x480UL)\r\n/** @addtogroup UTILS_EF_SYSTEM\r\n  *  @brief    System Configuration functions\r\n  *\r\n  @verbatim\r\n ===============================================================================\r\n           ##### System Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n         System, AHB and APB buses clocks configuration\r\n\r\n         (+) The maximum frequency of the SYSCLK is 280 MHz and HCLK is 280 MHz.\r\n         (+) The maximum frequency of the PCLK1, PCLK2, PCLK3 and PCLK4 is 140 MHz.\r\n  @endverbatim\r\n  @internal\r\n             Depending on the device voltage range, the maximum frequency should be\r\n             adapted accordingly:\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n             (++) |  Wait states   |                          HCLK clock frequency (MHz)                           |\r\n             (++) |                |-------------------------------------------------------------------------------|\r\n             (++) |  (Latency)     |   voltage range 0 |   voltage range 1 |   voltage range 2 |   voltage range 3 |\r\n             (++) |                |    1.26V - 1.35V  |    1.15V - 1.26V  |    1.05V - 1.15V  |    0.95V - 1.05V  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |0WS(1CPU cycle) |   0 < HCLK <= 44  |   0 < HCLK <= 42  |   0 < HCLK <= 34  |   0 < HCLK <= 22  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |1WS(2CPU cycle) |  44 < HCLK <= 88  |  42 < HCLK <= 84  |  34 < HCLK <= 68  |  22 < HCLK <= 44  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |2WS(3CPU cycle) |  88 < HCLK <= 132 |  84 < HCLK <= 126 |  68 < HCLK <= 102 |  44 < HCLK <= 66  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |3WS(4CPU cycle) | 132 < HCLK <= 176 | 126 < HCLK <= 168 | 102 < HCLK <= 136 |  66 < HCLK <= 88  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |4WS(5CPU cycle) | 176 < HCLK <= 220 | 168 < HCLK <= 210 | 136 < HCLK <= 160 |        --         |\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n             (++) |5WS(6CPU cycle) | 220 < HCLK <= 264 | 210 < HCLK <= 225 |        --         |        --         |\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n             (++) |6WS(7CPU cycle) | 264 < HCLK <= 280 |        --         |        --         |        --         |\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n             (++) |7WS(8CPU cycle) |        --         |        --         |        --         |        --         |\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n\r\n  @endinternal\r\n  * @{\r\n  */\r\n\r\n#elif (STM32H7_DEV_ID == 0x483UL)\r\n/** @addtogroup UTILS_EF_SYSTEM\r\n  *  @brief    System Configuration functions\r\n  *\r\n  @verbatim\r\n ===============================================================================\r\n           ##### System Configuration functions #####\r\n ===============================================================================\r\n    [..]\r\n         System, AHB and APB buses clocks configuration\r\n\r\n         (+) The maximum frequency of the SYSCLK is 550 MHz(*) and HCLK is 275 MHz.\r\n         (+) The maximum frequency of the PCLK1, PCLK2, PCLK3 and PCLK4 is 137.5 MHz.\r\n  @endverbatim\r\n  @internal\r\n             Depending on the device voltage range, the maximum frequency should be\r\n             adapted accordingly:\r\n             (++) +------------------------------------------------------------------------------------------------+\r\n             (++) |  Wait states   |                          HCLK clock frequency (MHz)                           |\r\n             (++) |                |-------------------------------------------------------------------------------|\r\n             (++) |  (Latency)     |   voltage range 0 |   voltage range 1 |   voltage range 2 |   voltage range 3 |\r\n             (++) |                |    1.26V - 1.40V  |    1.15V - 1.26V  |    1.05V - 1.15V  |    0.95V - 1.05V  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |0WS(1CPU cycle) |   0 < HCLK <= 70  |   0 < HCLK <= 67  |   0 < HCLK <= 50  |   0 < HCLK <= 35  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |1WS(2CPU cycle) |  70 < HCLK <= 140 |  67 < HCLK <= 133 |  50 < HCLK <= 100 |  35 < HCLK <= 70  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |2WS(3CPU cycle) | 140 < HCLK <= 210 | 133 < HCLK <= 200 | 100 < HCLK <= 150 |  70 < HCLK <= 85  |\r\n             (++) |----------------|-------------------|-------------------|-------------------|-------------------|\r\n             (++) |3WS(4CPU cycle) | 210 < HCLK <= 275 |        --         |        --         |        --         |\r\n             (++) +----------------|-------------------|-------------------|-------------------|-------------------|\r\n\r\n  (*)  : For stm32h72xxx and stm32h73xxx family lines and requires to enable the CPU_FREQ_BOOST flash option byte, 520MHZ otherwise.\r\n  @endinternal\r\n  * @{\r\n  */\r\n#endif /* STM32H7_DEV_ID == 0x450UL */\r\n\r\n#if defined (DUAL_CORE)\r\n/**\r\n  * @brief  This function sets directly SystemCoreClock CMSIS variable.\r\n  * @note   Variable can be calculated also through SystemCoreClockUpdate function.\r\n  * @param  CPU_Frequency Core frequency in Hz\r\n  * @note   CPU_Frequency can be calculated thanks to RCC helper macro or function\r\n  *         @ref LL_RCC_GetSystemClocksFreq\r\n  *         LL_RCC_GetSystemClocksFreq() is used to calculate the CM7 clock frequency\r\n  *         and __LL_RCC_CALC_HCLK_FREQ is used to calculate the CM4 clock frequency.\r\n  * @retval None\r\n  */\r\n#else\r\n/**\r\n  * @brief  This function sets directly SystemCoreClock CMSIS variable.\r\n  * @note   Variable can be calculated also through SystemCoreClockUpdate function.\r\n  * @param  CPU_Frequency Core frequency in Hz\r\n  * @note   CPU_Frequency can be calculated thanks to RCC helper macro or function\r\n  *         @ref LL_RCC_GetSystemClocksFreq\r\n  * @retval None\r\n  */\r\n#endif /* DUAL_CORE */\r\nvoid LL_SetSystemCoreClock(uint32_t CPU_Frequency)\r\n{\r\n  /* HCLK clock frequency */\r\n  SystemCoreClock = CPU_Frequency;\r\n}\r\n\r\n/**\r\n  * @brief  This function configures system clock at maximum frequency with HSI as clock source of the PLL\r\n  * @note   The application need to ensure that PLL is disabled.\r\n  * @note   Function is based on the following formula:\r\n  *         - PLL output frequency = (((HSI frequency / PLLM) * PLLN) / PLLP)\r\n  *         - PLLM: ensure that the VCO input frequency ranges from 1 to 16 MHz (PLLVCO_input = HSI frequency / PLLM)\r\n  *         - PLLN: ensure that the VCO output frequency is between 150 and 836 MHz or 128 to 560 MHz(***) (PLLVCO_output = PLLVCO_input * PLLN)\r\n  *         - PLLP: ensure that max frequency at 550000000 Hz(*), 480000000 Hz(**) or 280000000 Hz(***) is reach (PLLVCO_output / PLLP)\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Max frequency configuration done\r\n  *          - ERROR: Max frequency configuration not done\r\n  *\r\n  * (*)  : For stm32h72xxx and stm32h73xxx family lines and requires to enable the CPU_FREQ_BOOST flash option byte, 520MHZ otherwise.\r\n  * (**) : For stm32h74xxx and stm32h75xxx family lines and requires the board to be connected on LDO regulator not SMPS, 400MHZ otherwise.\r\n  * (***): For stm32h7a3xx, stm32h7b3xx and stm32h7b0xx family lines.\r\n  *\r\n  */\r\nErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,\r\n                                         LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status;\r\n#ifdef  USE_FULL_ASSERT\r\n  uint32_t vcoinput_freq, vcooutput_freq;\r\n#endif\r\n  uint32_t pllfreq, hsi_clk;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));\r\n  assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));\r\n  assert_param(IS_LL_UTILS_PLLP_VALUE(UTILS_PLLInitStruct->PLLP));\r\n  assert_param(IS_LL_UTILS_FRACN_VALUE(UTILS_PLLInitStruct->FRACN));\r\n\r\n  hsi_clk = (HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_CR_HSIDIV_Pos));\r\n\r\n  /* Check VCO Input frequency */\r\n#ifdef  USE_FULL_ASSERT\r\n  vcoinput_freq = hsi_clk / UTILS_PLLInitStruct->PLLM;\r\n#endif\r\n  assert_param(IS_LL_UTILS_PLLVCO_INPUT(vcoinput_freq, UTILS_PLLInitStruct->VCO_Input));\r\n\r\n  /* Check VCO Output frequency */\r\n#ifdef  USE_FULL_ASSERT\r\n  vcooutput_freq = LL_RCC_CalcPLLClockFreq(hsi_clk, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN, UTILS_PLLInitStruct->FRACN, 1UL);\r\n#endif\r\n  assert_param(IS_LL_UTILS_PLLVCO_OUTPUT(vcooutput_freq, UTILS_PLLInitStruct->VCO_Output));\r\n\r\n  /* Check VCO Input ranges */\r\n  assert_param(IS_LL_UTILS_CHECK_VCO_RANGES(UTILS_PLLInitStruct->VCO_Input, UTILS_PLLInitStruct->VCO_Output));\r\n\r\n  /* Check if one of the PLL is enabled */\r\n  if(UTILS_IsPLLsReady() == SUCCESS)\r\n  {\r\n    /* Calculate the new PLL output frequency */\r\n    pllfreq = UTILS_GetPLLOutputFrequency(hsi_clk, UTILS_PLLInitStruct);\r\n\r\n    /* Enable HSI if not enabled */\r\n    if(LL_RCC_HSI_IsReady() != 1U)\r\n    {\r\n      LL_RCC_HSI_Enable();\r\n      while (LL_RCC_HSI_IsReady() != 1U)\r\n      {\r\n        /* Wait for HSI ready */\r\n      }\r\n    }\r\n\r\n    /* Configure PLL */\r\n    LL_RCC_PLL1P_Enable();\r\n    LL_RCC_PLL1FRACN_Enable();\r\n    LL_RCC_PLL_SetSource(LL_RCC_PLLSOURCE_HSI);\r\n    LL_RCC_PLL1_SetVCOInputRange(UTILS_PLLInitStruct->VCO_Input);\r\n    LL_RCC_PLL1_SetVCOOutputRange(UTILS_PLLInitStruct->VCO_Output);\r\n    LL_RCC_PLL1_SetM(UTILS_PLLInitStruct->PLLM);\r\n    LL_RCC_PLL1_SetN(UTILS_PLLInitStruct->PLLN);\r\n    LL_RCC_PLL1_SetP(UTILS_PLLInitStruct->PLLP);\r\n    LL_RCC_PLL1_SetFRACN(UTILS_PLLInitStruct->FRACN);\r\n\r\n    /* Enable PLL and switch system clock to PLL */\r\n    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);\r\n  }\r\n  else\r\n  {\r\n    /* Current PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  This function configures system clock with HSE as clock source of the PLL\r\n  * @note   The application need to ensure that PLL is disabled.\r\n  * @note   Function is based on the following formula:\r\n  *         - PLL output frequency = (((HSE frequency / PLLM) * PLLN) / PLLP)\r\n  *         - PLLM: ensure that the VCO input frequency ranges from 0.95 to 2.10 MHz (PLLVCO_input = HSE frequency / PLLM)\r\n  *         - PLLN: ensure that the VCO output frequency is between 150 and 836 MHz or 128 to 560 MHz(***) (PLLVCO_output = PLLVCO_input * PLLN)\r\n  *         - PLLP: ensure that max frequency at 550000000 Hz(*), 480000000 Hz(**) or 280000000 Hz(***) is reached (PLLVCO_output / PLLP)\r\n  * @param  HSEFrequency Value between Min_Data = 4000000 and Max_Data = 48000000\r\n  * @param  HSEBypass This parameter can be one of the following values:\r\n  *         @arg @ref LL_UTILS_HSEBYPASS_ON\r\n  *         @arg @ref LL_UTILS_HSEBYPASS_OFF\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Max frequency configuration done\r\n  *          - ERROR: Max frequency configuration not done\r\n  *\r\n  * (*)  : For stm32h72xxx and stm32h73xxx family lines and requires to enable the CPU_FREQ_BOOST flash option byte, 520MHZ otherwise.\r\n  * (**) : For stm32h74xxx and stm32h75xxx family lines and requires the board to be connected on LDO regulator not SMPS, 400MHZ otherwise.\r\n  * (***): For stm32h7a3xx, stm32h7b3xx and stm32h7b0xx family lines.\r\n  *\r\n  */\r\nErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,\r\n                                         LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status;\r\n#ifdef  USE_FULL_ASSERT\r\n  uint32_t vcoinput_freq, vcooutput_freq;\r\n#endif\r\n  uint32_t pllfreq;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));\r\n  assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));\r\n  assert_param(IS_LL_UTILS_PLLP_VALUE(UTILS_PLLInitStruct->PLLP));\r\n  assert_param(IS_LL_UTILS_FRACN_VALUE(UTILS_PLLInitStruct->FRACN));\r\n  assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));\r\n  assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));\r\n\r\n  /* Check VCO Input frequency */\r\n#ifdef  USE_FULL_ASSERT\r\n  vcoinput_freq = HSEFrequency / UTILS_PLLInitStruct->PLLM;\r\n#endif\r\n  assert_param(IS_LL_UTILS_PLLVCO_INPUT(vcoinput_freq, UTILS_PLLInitStruct->VCO_Input));\r\n\r\n  /* Check VCO output frequency */\r\n#ifdef  USE_FULL_ASSERT\r\n  vcooutput_freq = LL_RCC_CalcPLLClockFreq(HSEFrequency, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN, UTILS_PLLInitStruct->FRACN, 1U);\r\n#endif\r\n  assert_param(IS_LL_UTILS_PLLVCO_OUTPUT(vcooutput_freq, UTILS_PLLInitStruct->VCO_Output));\r\n\r\n  /* Check VCO Input/output ranges compatibility */\r\n  assert_param(IS_LL_UTILS_CHECK_VCO_RANGES(UTILS_PLLInitStruct->VCO_Input, UTILS_PLLInitStruct->VCO_Output));\r\n\r\n  /* Check if one of the PLL is enabled */\r\n  if(UTILS_IsPLLsReady() == SUCCESS)\r\n  {\r\n    /* Calculate the new PLL output frequency */\r\n    pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);\r\n\r\n    /* Enable HSE if not enabled */\r\n    if(LL_RCC_HSE_IsReady() != 1U)\r\n    {\r\n      /* Check if need to enable HSE bypass feature or not */\r\n      if(HSEBypass == LL_UTILS_HSEBYPASS_ON)\r\n      {\r\n        LL_RCC_HSE_EnableBypass();\r\n      }\r\n      else\r\n      {\r\n        LL_RCC_HSE_DisableBypass();\r\n      }\r\n\r\n      /* Enable HSE */\r\n      LL_RCC_HSE_Enable();\r\n      while (LL_RCC_HSE_IsReady() != 1U)\r\n      {\r\n        /* Wait for HSE ready */\r\n      }\r\n    }\r\n\r\n    /* Configure PLL */\r\n    LL_RCC_PLL1P_Enable();\r\n    LL_RCC_PLL1FRACN_Enable();\r\n    LL_RCC_PLL_SetSource(LL_RCC_PLLSOURCE_HSE);\r\n    LL_RCC_PLL1_SetVCOInputRange(UTILS_PLLInitStruct->VCO_Input);\r\n    LL_RCC_PLL1_SetVCOOutputRange(UTILS_PLLInitStruct->VCO_Output);\r\n    LL_RCC_PLL1_SetM(UTILS_PLLInitStruct->PLLM);\r\n    LL_RCC_PLL1_SetN(UTILS_PLLInitStruct->PLLN);\r\n    LL_RCC_PLL1_SetP(UTILS_PLLInitStruct->PLLP);\r\n    LL_RCC_PLL1_SetFRACN(UTILS_PLLInitStruct->FRACN);\r\n\r\n    /* Enable PLL and switch system clock to PLL */\r\n    status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);\r\n  }\r\n  else\r\n  {\r\n    /* Current PLL configuration cannot be modified */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @brief  Update number of Flash wait states in line with new frequency and current\r\n            voltage range.\r\n  * @param  HCLK_Frequency  HCLK frequency\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: Latency has been modified\r\n  *          - ERROR: Latency cannot be modified\r\n  */\r\nErrorStatus LL_SetFlashLatency(uint32_t HCLK_Frequency)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t timeout;\r\n  uint32_t getlatency;\r\n  uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */\r\n\r\n\r\n\r\n  /* Frequency cannot be equal to 0 */\r\n  if (HCLK_Frequency == 0U)\r\n  {\r\n    status = ERROR;\r\n  }\r\n  else\r\n  {\r\n#if (STM32H7_DEV_ID == 0x480UL) || (STM32H7_DEV_ID == 0x483UL)\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE0)\r\n    {\r\n#if (STM32H7_DEV_ID == 0x480UL)\r\n      if((HCLK_Frequency > UTILS_SCALE0_LATENCY5_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY6_FREQ))\r\n      {\r\n        /* 264 < HCLK <= 280 => 6WS (7 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_6;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE0_LATENCY4_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY5_FREQ))\r\n      {\r\n        /* 220 < HCLK <= 264 => 5WS (6 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_5;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE0_LATENCY3_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY4_FREQ))\r\n      {\r\n        /* 176 < HCLK <= 220 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE0_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY3_FREQ))\r\n#elif (STM32H7_DEV_ID == 0x483UL)\r\n      if((HCLK_Frequency > UTILS_SCALE0_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY3_FREQ))\r\n#endif /* STM32H7_DEV_ID == 0x480UL */\r\n      {\r\n        /* 132 < HCLK <= 176 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE0_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY2_FREQ))\r\n      {\r\n        /* 88 < HCLK <= 132 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE0_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE0_LATENCY1_FREQ))\r\n      {\r\n        /* 44 < HCLK <= 88 => 1WS (2 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_1;\r\n      }\r\n      else if(HCLK_Frequency <= UTILS_SCALE0_LATENCY0_FREQ)\r\n      {\r\n        /* HCLK <= 44 => 0WS (1 CPU cycles) : Do nothing keep latency to default  LL_FLASH_LATENCY_0 */\r\n      }\r\n      else\r\n      {\r\n        status = ERROR;\r\n      }\r\n    }\r\n#if (STM32H7_DEV_ID == 0x480UL)\r\n    else if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)\r\n    {\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY5_FREQ))\r\n      {\r\n        /* 210 < HCLK <= 225 => 5WS (6 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_5;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY4_FREQ))\r\n      {\r\n        /* 168 < HCLK <= 210 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY3_FREQ))\r\n      {\r\n        /* 126 < HCLK <= 168 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY2_FREQ))\r\n#else\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)\r\n    {\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY2_FREQ))\r\n#endif /* STM32H7_DEV_ID == 0x480UL */\r\n#else\r\n    if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)\r\n    {\r\n      if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY2_FREQ))\r\n#endif /* STM32H7_DEV_ID == 0x480UL || STM32H7_DEV_ID == 0x483UL */\r\n      {\r\n        /* 140 < HCLK <= 210 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE1_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE1_LATENCY1_FREQ))\r\n      {\r\n        /* 70 < HCLK <= 140 => 1WS (2 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_1;\r\n      }\r\n      else if(HCLK_Frequency <= UTILS_SCALE1_LATENCY0_FREQ)\r\n      {\r\n        /* HCLK <= 70 => 0WS (1 CPU cycles) : Do nothing keep latency to default  LL_FLASH_LATENCY_0 */\r\n      }\r\n      else\r\n      {\r\n        status = ERROR;\r\n      }\r\n    }\r\n    else if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)\r\n    {\r\n#if (STM32H7_DEV_ID == 0x480UL) || (STM32H7_DEV_ID == 0x450UL)\r\n#if (STM32H7_DEV_ID == 0x480UL)\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY4_FREQ))\r\n      {\r\n        /* 136 < HCLK <= 160 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY3_FREQ))\r\n#else\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY3_FREQ))\r\n#endif /* STM32H7_DEV_ID == 0x480UL */\r\n      {\r\n        /* 165 < HCLK <= 220 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY2_FREQ))\r\n#else\r\n      if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY2_FREQ))\r\n#endif /* STM32H7_DEV_ID == 0x480UL || STM32H7_DEV_ID == 0x450UL */\r\n      {\r\n        /* 110 < HCLK <= 165 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE2_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE2_LATENCY1_FREQ))\r\n      {\r\n        /* 55 < HCLK <= 110 => 1WS (2 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_1;\r\n      }\r\n      else if(HCLK_Frequency <= UTILS_SCALE2_LATENCY0_FREQ)\r\n      {\r\n        /* HCLK <= 55 => 0WS (1 CPU cycles) : Do nothing keep latency to default  LL_FLASH_LATENCY_0 */\r\n      }\r\n      else\r\n      {\r\n        status = ERROR;\r\n      }\r\n    }\r\n    else /* Scale 3 */\r\n    {\r\n#if (STM32H7_DEV_ID == 0x450UL) || (STM32H7_DEV_ID == 0x480UL)\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n      if((HCLK_Frequency > UTILS_SCALE3_LATENCY3_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY4_FREQ))\r\n      {\r\n        /* 180 < HCLK <= 225 => 4WS (5 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_4;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE3_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY3_FREQ))\r\n#else\r\n      if((HCLK_Frequency > UTILS_SCALE3_LATENCY2_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY3_FREQ))\r\n#endif /*STM32H7_DEV_ID == 0x450UL*/\r\n      {\r\n        /* 135 < HCLK <= 180 => 3WS (4 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_3;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE3_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY2_FREQ))\r\n#else\r\n      if((HCLK_Frequency > UTILS_SCALE3_LATENCY1_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY2_FREQ))\r\n#endif /* STM32H7_DEV_ID == 0x450UL || STM32H7_DEV_ID == 0x480UL */\r\n      {\r\n        /* 90 < HCLK <= 135 => 2WS (3 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_2;\r\n      }\r\n      else if((HCLK_Frequency > UTILS_SCALE3_LATENCY0_FREQ) && (HCLK_Frequency <= UTILS_SCALE3_LATENCY1_FREQ))\r\n      {\r\n        /* 45 < HCLK <= 90 => 1WS (2 CPU cycles) */\r\n        latency = LL_FLASH_LATENCY_1;\r\n      }\r\n      else if(HCLK_Frequency <= UTILS_SCALE3_LATENCY0_FREQ)\r\n      {\r\n        /* HCLK <= 45 => 0WS (1 CPU cycles) : Do nothing keep latency to default  LL_FLASH_LATENCY_0 */\r\n      }\r\n      else\r\n      {\r\n        status = ERROR;\r\n      }\r\n    }\r\n\r\n    if(status == SUCCESS)\r\n    {\r\n      LL_FLASH_SetLatency(latency);\r\n\r\n      /* Check that the new number of wait states is taken into account to access the Flash\r\n      memory by reading the FLASH_ACR register */\r\n      timeout = 2;\r\n      do\r\n      {\r\n        /* Wait for Flash latency to be updated */\r\n        getlatency = LL_FLASH_GetLatency();\r\n        timeout--;\r\n      } while ((getlatency != latency) && (timeout > 0U));\r\n\r\n      if(getlatency != latency)\r\n      {\r\n        status = ERROR;\r\n      }\r\n    }\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup UTILS_LL_Private_Functions\r\n  * @{\r\n  */\r\n\r\n\r\n/**\r\n  * @brief  Function to check that PLL can be modified\r\n  * @param  PLL_InputFrequency  PLL input frequency (in Hz)\r\n  * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains\r\n  *                             the configuration information for the PLL.\r\n  * @retval PLL output frequency (in Hz)\r\n  */\r\nstatic uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)\r\n{\r\n  uint32_t pllfreq;\r\n\r\n  /* Check the parameters */\r\n  assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));\r\n  assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));\r\n  assert_param(IS_LL_UTILS_PLLP_VALUE(UTILS_PLLInitStruct->PLLP));\r\n  assert_param(IS_LL_UTILS_FRACN_VALUE(UTILS_PLLInitStruct->FRACN));\r\n\r\n  pllfreq = LL_RCC_CalcPLLClockFreq(PLL_InputFrequency, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN, UTILS_PLLInitStruct->FRACN, UTILS_PLLInitStruct->PLLP);\r\n\r\n  return pllfreq;\r\n}\r\n\r\n/**\r\n  * @brief  Check that all PLLs are ready therefore configuration can be done\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: All PLLs are ready so configuration can be done\r\n  *          - ERROR: One PLL at least is busy\r\n  */\r\nstatic ErrorStatus UTILS_IsPLLsReady(void)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n\r\n  /* Check if one of the PLL1 is busy */\r\n  if(LL_RCC_PLL1_IsReady() != 0U)\r\n  {\r\n    /* PLL1 configuration cannot be done */\r\n    status = ERROR;\r\n  }\r\n\r\n  /* Check if one of the PLL2 is busy */\r\n  if(LL_RCC_PLL2_IsReady() != 0U)\r\n  {\r\n    /* PLL2 configuration cannot be done */\r\n    status = ERROR;\r\n  }\r\n\r\n  /* Check if one of the PLL3 is busy */\r\n  if(LL_RCC_PLL3_IsReady() != 0U)\r\n  {\r\n    /* PLL3 configuration cannot be done */\r\n    status = ERROR;\r\n  }\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @brief  Function to enable PLL and switch system clock to PLL\r\n  * @param  SYSCLK_Frequency SYSCLK frequency\r\n  * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains\r\n  *                             the configuration information for the BUS prescalers.\r\n  * @retval An ErrorStatus enumeration value:\r\n  *          - SUCCESS: No problem to switch system to PLL\r\n  *          - ERROR: Problem to switch system to PLL\r\n  */\r\nstatic ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)\r\n{\r\n  ErrorStatus status = SUCCESS;\r\n  uint32_t new_hclk_frequency;\r\n\r\n  assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->SYSCLKDivider));\r\n  assert_param(IS_LL_UTILS_AHB_DIV(UTILS_ClkInitStruct->AHBCLKDivider));\r\n  assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));\r\n  assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));\r\n  assert_param(IS_LL_UTILS_APB3_DIV(UTILS_ClkInitStruct->APB3CLKDivider));\r\n  assert_param(IS_LL_UTILS_APB4_DIV(UTILS_ClkInitStruct->APB4CLKDivider));\r\n\r\n  /* Calculate the new HCLK frequency */\r\n  new_hclk_frequency = LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);\r\n\r\n    /* Increasing the number of wait states because of higher CPU frequency */\r\n  if (SystemD2Clock < new_hclk_frequency)\r\n    {\r\n    /* Set FLASH latency to highest latency */\r\n    status = LL_SetFlashLatency(new_hclk_frequency);\r\n    }\r\n\r\n  /* Update system clock configuration */\r\n  if(status == SUCCESS)\r\n  {\r\n    /* Enable PLL */\r\n    LL_RCC_PLL1_Enable();\r\n    while (LL_RCC_PLL1_IsReady() != 1U)\r\n    {\r\n      /* Wait for PLL ready */\r\n    }\r\n\r\n    /* Set All APBxPrescaler to the Highest Divider */\r\n    LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_16);\r\n    LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_16);\r\n    LL_RCC_SetAPB3Prescaler(LL_RCC_APB3_DIV_16);\r\n    LL_RCC_SetAPB4Prescaler(LL_RCC_APB4_DIV_16);\r\n\r\n    /* Set SYS prescaler*/\r\n    LL_RCC_SetSysPrescaler(UTILS_ClkInitStruct->SYSCLKDivider);\r\n\r\n    /* Set AHB prescaler*/\r\n    LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);\r\n\r\n    /* Sysclk activation on the main PLL */\r\n    LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL1);\r\n    while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL1)\r\n    {\r\n      /* Wait for system clock switch to PLL */\r\n    }\r\n\r\n    /* Set APBn prescaler*/\r\n    LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);\r\n    LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);\r\n    LL_RCC_SetAPB3Prescaler(UTILS_ClkInitStruct->APB3CLKDivider);\r\n    LL_RCC_SetAPB4Prescaler(UTILS_ClkInitStruct->APB4CLKDivider);\r\n\r\n    /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if (SystemD2Clock > new_hclk_frequency)\r\n  {\r\n    /* Set FLASH latency to lowest latency */\r\n    status = LL_SetFlashLatency(new_hclk_frequency);\r\n  }\r\n\r\n      /* Update the SystemD2Clock global variable */\r\n#if defined(RCC_D1CFGR_HPRE)\r\n      SystemD2Clock = (SYSCLK_Frequency >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\r\n#else\r\n      SystemD2Clock = (SYSCLK_Frequency >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\r\n#endif\r\n\r\n      /* Update SystemCoreClock variable */\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n      LL_SetSystemCoreClock(SystemD2Clock);\r\n#else\r\n      LL_SetSystemCoreClock(SYSCLK_Frequency);\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n\r\n    }\r\n\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n"},{"name":"syscalls.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\STM32CubeIDE\\Application\\User\\Core","tag":"","groupDisplay":"Other files","code":"/**\n ******************************************************************************\n * @file      syscalls.c\n * @author    Auto-generated by STM32CubeIDE\n * @brief     STM32CubeIDE Minimal System calls file\n *\n *            For more information about which c-functions\n *            need which of these lowlevel functions\n *            please consult the Newlib libc-manual\n ******************************************************************************\n * @attention\n *\n * Copyright (c) 2021 STMicroelectronics.\n * All rights reserved.\n *\n * This software is licensed under terms that can be found in the LICENSE file\n * in the root directory of this software component.\n * If no LICENSE file comes with this software, it is provided AS-IS.\n *\n ******************************************************************************\n */\n\n/* Includes */\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/times.h>\n\n\n/* Variables */\nextern int __io_putchar(int ch) __attribute__((weak));\nextern int __io_getchar(void) __attribute__((weak));\n\n\nchar *__env[1] = { 0 };\nchar **environ = __env;\n\n\n/* Functions */\nvoid initialise_monitor_handles()\n{\n}\n\nint _getpid(void)\n{\n\treturn 1;\n}\n\nint _kill(int pid, int sig)\n{\n\terrno = EINVAL;\n\treturn -1;\n}\n\nvoid _exit (int status)\n{\n\t_kill(status, -1);\n\twhile (1) {}\t\t/* Make sure we hang here */\n}\n\n__attribute__((weak)) int _read(int file, char *ptr, int len)\n{\n\tint DataIdx;\n\n\tfor (DataIdx = 0; DataIdx < len; DataIdx++)\n\t{\n\t\t*ptr++ = __io_getchar();\n\t}\n\nreturn len;\n}\n\n__attribute__((weak)) int _write(int file, char *ptr, int len)\n{\n\tint DataIdx;\n\n\tfor (DataIdx = 0; DataIdx < len; DataIdx++)\n\t{\n\t\t__io_putchar(*ptr++);\n\t}\n\treturn len;\n}\n\nint _close(int file)\n{\n\treturn -1;\n}\n\n\nint _fstat(int file, struct stat *st)\n{\n\tst->st_mode = S_IFCHR;\n\treturn 0;\n}\n\nint _isatty(int file)\n{\n\treturn 1;\n}\n\nint _lseek(int file, int ptr, int dir)\n{\n\treturn 0;\n}\n\nint _open(char *path, int flags, ...)\n{\n\t/* Pretend like we always fail */\n\treturn -1;\n}\n\nint _wait(int *status)\n{\n\terrno = ECHILD;\n\treturn -1;\n}\n\nint _unlink(char *name)\n{\n\terrno = ENOENT;\n\treturn -1;\n}\n\nint _times(struct tms *buf)\n{\n\treturn -1;\n}\n\nint _stat(char *file, struct stat *st)\n{\n\tst->st_mode = S_IFCHR;\n\treturn 0;\n}\n\nint _link(char *old, char *new)\n{\n\terrno = EMLINK;\n\treturn -1;\n}\n\nint _fork(void)\n{\n\terrno = EAGAIN;\n\treturn -1;\n}\n\nint _execve(char *name, char **argv, char **env)\n{\n\terrno = ENOMEM;\n\treturn -1;\n}\n"},{"name":"sysmem.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\STM32CubeIDE\\Application\\User\\Core","tag":"","groupDisplay":"Other files","code":"/**\n ******************************************************************************\n * @file      sysmem.c\n * @author    Generated by STM32CubeIDE\n * @brief     STM32CubeIDE System Memory calls file\n *\n *            For more information about which C functions\n *            need which of these lowlevel functions\n *            please consult the newlib libc manual\n ******************************************************************************\n * @attention\n *\n * Copyright (c) 2021 STMicroelectronics.\n * All rights reserved.\n *\n * This software is licensed under terms that can be found in the LICENSE file\n * in the root directory of this software component.\n * If no LICENSE file comes with this software, it is provided AS-IS.\n *\n ******************************************************************************\n */\n\n/* Includes */\n#include <errno.h>\n#include <stdint.h>\n\n/**\n * Pointer to the current high watermark of the heap usage\n */\nstatic uint8_t *__sbrk_heap_end = NULL;\n\n/**\n * @brief _sbrk() allocates memory to the newlib heap and is used by malloc\n *        and others from the C library\n *\n * @verbatim\n * ############################################################################\n * #  .data  #  .bss  #       newlib heap       #          MSP stack          #\n * #         #        #                         # Reserved by _Min_Stack_Size #\n * ############################################################################\n * ^-- RAM start      ^-- _end                             _estack, RAM end --^\n * @endverbatim\n *\n * This implementation starts allocating at the '_end' linker symbol\n * The '_Min_Stack_Size' linker symbol reserves a memory for the MSP stack\n * The implementation considers '_estack' linker symbol to be RAM end\n * NOTE: If the MSP stack, at any point during execution, grows larger than the\n * reserved size, please increase the '_Min_Stack_Size'.\n *\n * @param incr Memory size\n * @return Pointer to allocated memory\n */\nvoid *_sbrk(ptrdiff_t incr)\n{\n  extern uint8_t _end; /* Symbol defined in the linker script */\n  extern uint8_t _estack; /* Symbol defined in the linker script */\n  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */\n  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;\n  const uint8_t *max_heap = (uint8_t *)stack_limit;\n  uint8_t *prev_heap_end;\n\n  /* Initialize heap end at first call */\n  if (NULL == __sbrk_heap_end)\n  {\n    __sbrk_heap_end = &_end;\n  }\n\n  /* Protect heap from growing into the reserved MSP stack */\n  if (__sbrk_heap_end + incr > max_heap)\n  {\n    errno = ENOMEM;\n    return (void *)-1;\n  }\n\n  prev_heap_end = __sbrk_heap_end;\n  __sbrk_heap_end += incr;\n\n  return (void *)prev_heap_end;\n}\n"},{"name":"system_stm32h7xx.c","type":"source","group":"legacy","path":"C:\\Users\\HUB4RT\\Desktop\\WorkStuff\\Simulink - Copy\\AccGyrXSim_ert_rtw\\..\\..\\..\\WorkStuff - Copy\\STM32_IMU\\Core\\Src","tag":"","groupDisplay":"Other files","code":"/**\r\n  ******************************************************************************\r\n  * @file    system_stm32h7xx.c\r\n  * @author  MCD Application Team\r\n  * @brief   CMSIS Cortex-Mx Device Peripheral Access Layer System Source File.\r\n  *\r\n  *   This file provides two functions and one global variable to be called from\r\n  *   user application:\r\n  *      - SystemInit(): This function is called at startup just after reset and\r\n  *                      before branch to main program. This call is made inside\r\n  *                      the \"startup_stm32h7xx.s\" file.\r\n  *\r\n  *      - SystemCoreClock variable: Contains the core clock, it can be used\r\n  *                                  by the user application to setup the SysTick\r\n  *                                  timer or configure other parameters.\r\n  *\r\n  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must\r\n  *                                 be called whenever the core clock is changed\r\n  *                                 during program execution.\r\n  *\r\n  *\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2017 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/** @addtogroup CMSIS\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup stm32h7xx_system\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_Includes\r\n  * @{\r\n  */\r\n\r\n#include \"stm32h7xx.h\"\r\n#include <math.h>\r\n#if !defined  (HSE_VALUE)\r\n#define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */\r\n#endif /* HSE_VALUE */\r\n\r\n#if !defined  (CSI_VALUE)\r\n  #define CSI_VALUE    ((uint32_t)4000000) /*!< Value of the Internal oscillator in Hz*/\r\n#endif /* CSI_VALUE */\r\n\r\n#if !defined  (HSI_VALUE)\r\n  #define HSI_VALUE    ((uint32_t)64000000) /*!< Value of the Internal oscillator in Hz*/\r\n#endif /* HSI_VALUE */\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_TypesDefinitions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_Defines\r\n  * @{\r\n  */\r\n\r\n/************************* Miscellaneous Configuration ************************/\r\n/*!< Uncomment the following line if you need to use initialized data in D2 domain SRAM (AHB SRAM) */\r\n/* #define DATA_IN_D2_SRAM */\r\n\r\n/* Note: Following vector table addresses must be defined in line with linker\r\n         configuration. */\r\n/*!< Uncomment the following line if you need to relocate the vector table\r\n     anywhere in FLASH BANK1 or AXI SRAM, else the vector table is kept at the automatic\r\n     remap of boot address selected */\r\n/* #define USER_VECT_TAB_ADDRESS */\r\n\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n/*!< Uncomment the following line if you need to relocate your vector Table\r\n     in D2 AXI SRAM else user remap will be done in FLASH BANK2. */\r\n/* #define VECT_TAB_SRAM */\r\n#if defined(VECT_TAB_SRAM)\r\n#define VECT_TAB_BASE_ADDRESS   D2_AXISRAM_BASE   /*!< Vector Table base address field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#else\r\n#define VECT_TAB_BASE_ADDRESS   FLASH_BANK2_BASE  /*!< Vector Table base address field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#endif /* VECT_TAB_SRAM */\r\n#else\r\n/*!< Uncomment the following line if you need to relocate your vector Table\r\n     in D1 AXI SRAM else user remap will be done in FLASH BANK1. */\r\n/* #define VECT_TAB_SRAM */\r\n#if defined(VECT_TAB_SRAM)\r\n#define VECT_TAB_BASE_ADDRESS   D1_AXISRAM_BASE   /*!< Vector Table base address field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#else\r\n#define VECT_TAB_BASE_ADDRESS   FLASH_BANK1_BASE  /*!< Vector Table base address field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.\r\n                                                       This value must be a multiple of 0x200. */\r\n#endif /* VECT_TAB_SRAM */\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n/******************************************************************************/\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_Macros\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_Variables\r\n  * @{\r\n  */\r\n  /* This variable is updated in three ways:\r\n      1) by calling CMSIS function SystemCoreClockUpdate()\r\n      2) by calling HAL API function HAL_RCC_GetHCLKFreq()\r\n      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency\r\n         Note: If you use this function to configure the system clock; then there\r\n               is no need to call the 2 first functions listed above, since SystemCoreClock\r\n               variable is updated automatically.\r\n  */\r\n  uint32_t SystemCoreClock = 64000000;\r\n  uint32_t SystemD2Clock = 64000000;\r\n  const  uint8_t D1CorePrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_FunctionPrototypes\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @addtogroup STM32H7xx_System_Private_Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Setup the microcontroller system\r\n  *         Initialize the FPU setting and  vector table location\r\n  *         configuration.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemInit (void)\r\n{\r\n#if defined (DATA_IN_D2_SRAM)\r\n __IO uint32_t tmpreg;\r\n#endif /* DATA_IN_D2_SRAM */\r\n\r\n  /* FPU settings ------------------------------------------------------------*/\r\n  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)\r\n    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */\r\n  #endif\r\n  /* Reset the RCC clock configuration to the default reset state ------------*/\r\n\r\n   /* Increasing the CPU frequency */\r\n  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n\tMODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));\r\n  }\r\n\r\n  /* Set HSION bit */\r\n  RCC->CR |= RCC_CR_HSION;\r\n\r\n  /* Reset CFGR register */\r\n  RCC->CFGR = 0x00000000;\r\n\r\n  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */\r\n  RCC->CR &= 0xEAF6ED7FU;\r\n  \r\n   /* Decreasing the number of wait states because of lower CPU frequency */\r\n  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))\r\n  {\r\n    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */\r\n\tMODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));\r\n  }\r\n\r\n#if defined(D3_SRAM_BASE)\r\n  /* Reset D1CFGR register */\r\n  RCC->D1CFGR = 0x00000000;\r\n\r\n  /* Reset D2CFGR register */\r\n  RCC->D2CFGR = 0x00000000;\r\n\r\n  /* Reset D3CFGR register */\r\n  RCC->D3CFGR = 0x00000000;\r\n#else\r\n  /* Reset CDCFGR1 register */\r\n  RCC->CDCFGR1 = 0x00000000;\r\n\r\n  /* Reset CDCFGR2 register */\r\n  RCC->CDCFGR2 = 0x00000000;\r\n\r\n  /* Reset SRDCFGR register */\r\n  RCC->SRDCFGR = 0x00000000;\r\n#endif\r\n  /* Reset PLLCKSELR register */\r\n  RCC->PLLCKSELR = 0x02020200;\r\n\r\n  /* Reset PLLCFGR register */\r\n  RCC->PLLCFGR = 0x01FF0000;\r\n  /* Reset PLL1DIVR register */\r\n  RCC->PLL1DIVR = 0x01010280;\r\n  /* Reset PLL1FRACR register */\r\n  RCC->PLL1FRACR = 0x00000000;\r\n\r\n  /* Reset PLL2DIVR register */\r\n  RCC->PLL2DIVR = 0x01010280;\r\n\r\n  /* Reset PLL2FRACR register */\r\n\r\n  RCC->PLL2FRACR = 0x00000000;\r\n  /* Reset PLL3DIVR register */\r\n  RCC->PLL3DIVR = 0x01010280;\r\n\r\n  /* Reset PLL3FRACR register */\r\n  RCC->PLL3FRACR = 0x00000000;\r\n\r\n  /* Reset HSEBYP bit */\r\n  RCC->CR &= 0xFFFBFFFFU;\r\n\r\n  /* Disable all interrupts */\r\n  RCC->CIER = 0x00000000;\r\n\r\n#if (STM32H7_DEV_ID == 0x450UL)\r\n  /* dual core CM7 or single core line */\r\n  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)\r\n  {\r\n    /* if stm32h7 revY*/\r\n    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */\r\n    *((__IO uint32_t*)0x51008108) = 0x000000001U;\r\n  }\r\n#endif\r\n\r\n#if defined (DATA_IN_D2_SRAM)\r\n  /* in case of initialized data in D2 SRAM (AHB SRAM) , enable the D2 SRAM clock (AHB SRAM clock) */\r\n#if defined(RCC_AHB2ENR_D2SRAM3EN)\r\n  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN | RCC_AHB2ENR_D2SRAM3EN);\r\n#elif defined(RCC_AHB2ENR_D2SRAM2EN)\r\n  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN);\r\n#else\r\n  RCC->AHB2ENR |= (RCC_AHB2ENR_AHBSRAM1EN | RCC_AHB2ENR_AHBSRAM2EN);\r\n#endif /* RCC_AHB2ENR_D2SRAM3EN */\r\n\r\n  tmpreg = RCC->AHB2ENR;\r\n  (void) tmpreg;\r\n#endif /* DATA_IN_D2_SRAM */\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  /* Configure the Vector Table location add offset address for cortex-M4 ------------------*/\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n\r\n#else\r\n\r\n  /*\r\n   * Disable the FMC bank1 (enabled after reset).\r\n   * This, prevents CPU speculation access on this bank which blocks the use of FMC during\r\n   * 24us. During this time the others FMC master (such as LTDC) cannot use it!\r\n   */\r\n  FMC_Bank1_R->BTCR[0] = 0x000030D2;\r\n\r\n  /* Configure the Vector Table location -------------------------------------*/\r\n#if defined(USER_VECT_TAB_ADDRESS)\r\n  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */\r\n#endif /* USER_VECT_TAB_ADDRESS */\r\n\r\n#endif /*DUAL_CORE && CORE_CM4*/\r\n\r\n}\r\n\r\n/**\r\n   * @brief  Update SystemCoreClock variable according to Clock Register Values.\r\n  *         The SystemCoreClock variable contains the core clock , it can\r\n  *         be used by the user application to setup the SysTick timer or configure\r\n  *         other parameters.\r\n  *\r\n  * @note   Each time the core clock changes, this function must be called\r\n  *         to update SystemCoreClock variable value. Otherwise, any configuration\r\n  *         based on this variable will be incorrect.\r\n  *\r\n  * @note   - The system frequency computed by this function is not the real\r\n  *           frequency in the chip. It is calculated based on the predefined\r\n  *           constant and the selected clock source:\r\n  *\r\n  *           - If SYSCLK source is CSI, SystemCoreClock will contain the CSI_VALUE(*)\r\n  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(**)\r\n  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(***)\r\n  *           - If SYSCLK source is PLL, SystemCoreClock will contain the CSI_VALUE(*),\r\n  *             HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.\r\n  *\r\n  *         (*) CSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value\r\n  *             4 MHz) but the real value may vary depending on the variations\r\n  *             in voltage and temperature.\r\n  *         (**) HSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value\r\n  *             64 MHz) but the real value may vary depending on the variations\r\n  *             in voltage and temperature.\r\n  *\r\n  *         (***)HSE_VALUE is a constant defined in stm32h7xx_hal.h file (default value\r\n  *              25 MHz), user has to ensure that HSE_VALUE is same as the real\r\n  *              frequency of the crystal used. Otherwise, this function may\r\n  *              have wrong result.\r\n  *\r\n  *         - The result of this function could be not correct when using fractional\r\n  *           value for HSE crystal.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid SystemCoreClockUpdate (void)\r\n{\r\n  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue, tmp;\r\n  uint32_t common_system_clock;\r\n  float_t fracn1, pllvco;\r\n\r\n\r\n  /* Get SYSCLK source -------------------------------------------------------*/\r\n\r\n  switch (RCC->CFGR & RCC_CFGR_SWS)\r\n  {\r\n  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */\r\n    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));\r\n    break;\r\n\r\n  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */\r\n    common_system_clock = CSI_VALUE;\r\n    break;\r\n\r\n  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */\r\n    common_system_clock = HSE_VALUE;\r\n    break;\r\n\r\n  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */\r\n\r\n    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN\r\n    SYSCLK = PLL_VCO / PLLR\r\n    */\r\n    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);\r\n    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;\r\n    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);\r\n    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));\r\n\r\n    if (pllm != 0U)\r\n    {\r\n      switch (pllsource)\r\n      {\r\n        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */\r\n\r\n        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;\r\n        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n\r\n        break;\r\n\r\n        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */\r\n          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        break;\r\n\r\n        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */\r\n          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        break;\r\n\r\n      default:\r\n          hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;\r\n          pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );\r\n        break;\r\n      }\r\n      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;\r\n      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);\r\n    }\r\n    else\r\n    {\r\n      common_system_clock = 0U;\r\n    }\r\n    break;\r\n\r\n  default:\r\n    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));\r\n    break;\r\n  }\r\n\r\n  /* Compute SystemClock frequency --------------------------------------------------*/\r\n#if defined (RCC_D1CFGR_D1CPRE)\r\n  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];\r\n\r\n  /* common_system_clock frequency : CM7 CPU frequency  */\r\n  common_system_clock >>= tmp;\r\n\r\n  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));\r\n\r\n#else\r\n  tmp = D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos];\r\n\r\n  /* common_system_clock frequency : CM7 CPU frequency  */\r\n  common_system_clock >>= tmp;\r\n\r\n  /* SystemD2Clock frequency : AXI and AHBs Clock frequency  */\r\n  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));\r\n\r\n#endif\r\n\r\n#if defined(DUAL_CORE) && defined(CORE_CM4)\r\n  SystemCoreClock = SystemD2Clock;\r\n#else\r\n  SystemCoreClock = common_system_clock;\r\n#endif /* DUAL_CORE && CORE_CM4 */\r\n}\r\n\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};